(window.webpackJsonp = window.webpackJsonp || []).push([[1], { 0: function (t, e, n) { t.exports = n("zUnb") }, yLV6: function (t, e, n) { var i; !function (r, s, o, l) { "use strict"; var a, c = ["", "webkit", "Moz", "MS", "ms", "o"], u = s.createElement("div"), h = Math.round, d = Math.abs, p = Date.now; function f(t, e, n) { return setTimeout(w(t, n), e) } function m(t, e, n) { return !!Array.isArray(t) && (g(t, n[e], n), !0) } function g(t, e, n) { var i; if (t) if (t.forEach) t.forEach(e, n); else if (void 0 !== t.length) for (i = 0; i < t.length;)e.call(n, t[i], i, t), i++; else for (i in t) t.hasOwnProperty(i) && e.call(n, t[i], i, t) } function _(t, e, n) { var i = "DEPRECATED METHOD: " + e + "\n" + n + " AT \n"; return function () { var e = new Error("get-stack-trace"), n = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace", s = r.console && (r.console.warn || r.console.log); return s && s.call(r.console, i, n), t.apply(this, arguments) } } a = "function" != typeof Object.assign ? function (t) { if (null == t) throw new TypeError("Cannot convert undefined or null to object"); for (var e = Object(t), n = 1; n < arguments.length; n++) { var i = arguments[n]; if (null != i) for (var r in i) i.hasOwnProperty(r) && (e[r] = i[r]) } return e } : Object.assign; var y = _((function (t, e, n) { for (var i = Object.keys(e), r = 0; r < i.length;)(!n || n && void 0 === t[i[r]]) && (t[i[r]] = e[i[r]]), r++; return t }), "extend", "Use `assign`."), v = _((function (t, e) { return y(t, e, !0) }), "merge", "Use `assign`."); function b(t, e, n) { var i, r = e.prototype; (i = t.prototype = Object.create(r)).constructor = t, i._super = r, n && a(i, n) } function w(t, e) { return function () { return t.apply(e, arguments) } } function C(t, e) { return "function" == typeof t ? t.apply(e && e[0] || void 0, e) : t } function S(t, e) { return void 0 === t ? e : t } function E(t, e, n) { g(P(e), (function (e) { t.addEventListener(e, n, !1) })) } function x(t, e, n) { g(P(e), (function (e) { t.removeEventListener(e, n, !1) })) } function T(t, e) { for (; t;) { if (t == e) return !0; t = t.parentNode } return !1 } function k(t, e) { return t.indexOf(e) > -1 } function P(t) { return t.trim().split(/\s+/g) } function O(t, e, n) { if (t.indexOf && !n) return t.indexOf(e); for (var i = 0; i < t.length;) { if (n && t[i][n] == e || !n && t[i] === e) return i; i++ } return -1 } function I(t) { return Array.prototype.slice.call(t, 0) } function A(t, e, n) { for (var i = [], r = [], s = 0; s < t.length;) { var o = e ? t[s][e] : t[s]; O(r, o) < 0 && i.push(t[s]), r[s] = o, s++ } return n && (i = e ? i.sort((function (t, n) { return t[e] > n[e] })) : i.sort()), i } function R(t, e) { for (var n, i, r = e[0].toUpperCase() + e.slice(1), s = 0; s < c.length;) { if ((i = (n = c[s]) ? n + r : e) in t) return i; s++ } } var N = 1; function M(t) { var e = t.ownerDocument || t; return e.defaultView || e.parentWindow || r } var D = "ontouchstart" in r, F = void 0 !== R(r, "PointerEvent"), L = D && /mobile|tablet|ip(ad|hone|od)|android/i.test(navigator.userAgent), V = ["x", "y"], z = ["clientX", "clientY"]; function j(t, e) { var n = this; this.manager = t, this.callback = e, this.element = t.element, this.target = t.options.inputTarget, this.domHandler = function (e) { C(t.options.enable, [t]) && n.handler(e) }, this.init() } function U(t, e, n) { var i = n.pointers.length, r = n.changedPointers.length, s = 1 & e && i - r == 0, o = 12 & e && i - r == 0; n.isFirst = !!s, n.isFinal = !!o, s && (t.session = {}), n.eventType = e, function (t, e) { var n = t.session, i = e.pointers, r = i.length; n.firstInput || (n.firstInput = H(e)), r > 1 && !n.firstMultiple ? n.firstMultiple = H(e) : 1 === r && (n.firstMultiple = !1); var s = n.firstInput, o = n.firstMultiple, l = o ? o.center : s.center, a = e.center = B(i); e.timeStamp = p(), e.deltaTime = e.timeStamp - s.timeStamp, e.angle = G(l, a), e.distance = q(l, a), function (t, e) { var n = e.center, i = t.offsetDelta || {}, r = t.prevDelta || {}, s = t.prevInput || {}; 1 !== e.eventType && 4 !== s.eventType || (r = t.prevDelta = { x: s.deltaX || 0, y: s.deltaY || 0 }, i = t.offsetDelta = { x: n.x, y: n.y }), e.deltaX = r.x + (n.x - i.x), e.deltaY = r.y + (n.y - i.y) }(n, e), e.offsetDirection = W(e.deltaX, e.deltaY); var c, u, h = $(e.deltaTime, e.deltaX, e.deltaY); e.overallVelocityX = h.x, e.overallVelocityY = h.y, e.overallVelocity = d(h.x) > d(h.y) ? h.x : h.y, e.scale = o ? (c = o.pointers, q((u = i)[0], u[1], z) / q(c[0], c[1], z)) : 1, e.rotation = o ? function (t, e) { return G(e[1], e[0], z) + G(t[1], t[0], z) }(o.pointers, i) : 0, e.maxPointers = n.prevInput ? e.pointers.length > n.prevInput.maxPointers ? e.pointers.length : n.prevInput.maxPointers : e.pointers.length, function (t, e) { var n, i, r, s, o = t.lastInterval || e, l = e.timeStamp - o.timeStamp; if (8 != e.eventType && (l > 25 || void 0 === o.velocity)) { var a = e.deltaX - o.deltaX, c = e.deltaY - o.deltaY, u = $(l, a, c); i = u.x, r = u.y, n = d(u.x) > d(u.y) ? u.x : u.y, s = W(a, c), t.lastInterval = e } else n = o.velocity, i = o.velocityX, r = o.velocityY, s = o.direction; e.velocity = n, e.velocityX = i, e.velocityY = r, e.direction = s }(n, e); var f = t.element; T(e.srcEvent.target, f) && (f = e.srcEvent.target), e.target = f }(t, n), t.emit("hammer.input", n), t.recognize(n), t.session.prevInput = n } function H(t) { for (var e = [], n = 0; n < t.pointers.length;)e[n] = { clientX: h(t.pointers[n].clientX), clientY: h(t.pointers[n].clientY) }, n++; return { timeStamp: p(), pointers: e, center: B(e), deltaX: t.deltaX, deltaY: t.deltaY } } function B(t) { var e = t.length; if (1 === e) return { x: h(t[0].clientX), y: h(t[0].clientY) }; for (var n = 0, i = 0, r = 0; r < e;)n += t[r].clientX, i += t[r].clientY, r++; return { x: h(n / e), y: h(i / e) } } function $(t, e, n) { return { x: e / t || 0, y: n / t || 0 } } function W(t, e) { return t === e ? 1 : d(t) >= d(e) ? t < 0 ? 2 : 4 : e < 0 ? 8 : 16 } function q(t, e, n) { n || (n = V); var i = e[n[0]] - t[n[0]], r = e[n[1]] - t[n[1]]; return Math.sqrt(i * i + r * r) } function G(t, e, n) { return n || (n = V), 180 * Math.atan2(e[n[1]] - t[n[1]], e[n[0]] - t[n[0]]) / Math.PI } j.prototype = { handler: function () { }, init: function () { this.evEl && E(this.element, this.evEl, this.domHandler), this.evTarget && E(this.target, this.evTarget, this.domHandler), this.evWin && E(M(this.element), this.evWin, this.domHandler) }, destroy: function () { this.evEl && x(this.element, this.evEl, this.domHandler), this.evTarget && x(this.target, this.evTarget, this.domHandler), this.evWin && x(M(this.element), this.evWin, this.domHandler) } }; var Z = { mousedown: 1, mousemove: 2, mouseup: 4 }; function Q() { this.evEl = "mousedown", this.evWin = "mousemove mouseup", this.pressed = !1, j.apply(this, arguments) } b(Q, j, { handler: function (t) { var e = Z[t.type]; 1 & e && 0 === t.button && (this.pressed = !0), 2 & e && 1 !== t.which && (e = 4), this.pressed && (4 & e && (this.pressed = !1), this.callback(this.manager, e, { pointers: [t], changedPointers: [t], pointerType: "mouse", srcEvent: t })) } }); var K = { pointerdown: 1, pointermove: 2, pointerup: 4, pointercancel: 8, pointerout: 8 }, Y = { 2: "touch", 3: "pen", 4: "mouse", 5: "kinect" }, X = "pointerdown", J = "pointermove pointerup pointercancel"; function tt() { this.evEl = X, this.evWin = J, j.apply(this, arguments), this.store = this.manager.session.pointerEvents = [] } r.MSPointerEvent && !r.PointerEvent && (X = "MSPointerDown", J = "MSPointerMove MSPointerUp MSPointerCancel"), b(tt, j, { handler: function (t) { var e = this.store, n = !1, i = t.type.toLowerCase().replace("ms", ""), r = K[i], s = Y[t.pointerType] || t.pointerType, o = "touch" == s, l = O(e, t.pointerId, "pointerId"); 1 & r && (0 === t.button || o) ? l < 0 && (e.push(t), l = e.length - 1) : 12 & r && (n = !0), l < 0 || (e[l] = t, this.callback(this.manager, r, { pointers: e, changedPointers: [t], pointerType: s, srcEvent: t }), n && e.splice(l, 1)) } }); var et = { touchstart: 1, touchmove: 2, touchend: 4, touchcancel: 8 }; function nt() { this.evTarget = "touchstart", this.evWin = "touchstart touchmove touchend touchcancel", this.started = !1, j.apply(this, arguments) } function it(t, e) { var n = I(t.touches), i = I(t.changedTouches); return 12 & e && (n = A(n.concat(i), "identifier", !0)), [n, i] } b(nt, j, { handler: function (t) { var e = et[t.type]; if (1 === e && (this.started = !0), this.started) { var n = it.call(this, t, e); 12 & e && n[0].length - n[1].length == 0 && (this.started = !1), this.callback(this.manager, e, { pointers: n[0], changedPointers: n[1], pointerType: "touch", srcEvent: t }) } } }); var rt = { touchstart: 1, touchmove: 2, touchend: 4, touchcancel: 8 }; function st() { this.evTarget = "touchstart touchmove touchend touchcancel", this.targetIds = {}, j.apply(this, arguments) } function ot(t, e) { var n = I(t.touches), i = this.targetIds; if (3 & e && 1 === n.length) return i[n[0].identifier] = !0, [n, n]; var r, s, o = I(t.changedTouches), l = [], a = this.target; if (s = n.filter((function (t) { return T(t.target, a) })), 1 === e) for (r = 0; r < s.length;)i[s[r].identifier] = !0, r++; for (r = 0; r < o.length;)i[o[r].identifier] && l.push(o[r]), 12 & e && delete i[o[r].identifier], r++; return l.length ? [A(s.concat(l), "identifier", !0), l] : void 0 } function lt() { j.apply(this, arguments); var t = w(this.handler, this); this.touch = new st(this.manager, t), this.mouse = new Q(this.manager, t), this.primaryTouch = null, this.lastTouches = [] } function at(t, e) { 1 & t ? (this.primaryTouch = e.changedPointers[0].identifier, ct.call(this, e)) : 12 & t && ct.call(this, e) } function ct(t) { var e = t.changedPointers[0]; if (e.identifier === this.primaryTouch) { var n = { x: e.clientX, y: e.clientY }; this.lastTouches.push(n); var i = this.lastTouches; setTimeout((function () { var t = i.indexOf(n); t > -1 && i.splice(t, 1) }), 2500) } } function ut(t) { for (var e = t.srcEvent.clientX, n = t.srcEvent.clientY, i = 0; i < this.lastTouches.length; i++) { var r = this.lastTouches[i], s = Math.abs(e - r.x), o = Math.abs(n - r.y); if (s <= 25 && o <= 25) return !0 } return !1 } b(st, j, { handler: function (t) { var e = rt[t.type], n = ot.call(this, t, e); n && this.callback(this.manager, e, { pointers: n[0], changedPointers: n[1], pointerType: "touch", srcEvent: t }) } }), b(lt, j, { handler: function (t, e, n) { var i = "mouse" == n.pointerType; if (!(i && n.sourceCapabilities && n.sourceCapabilities.firesTouchEvents)) { if ("touch" == n.pointerType) at.call(this, e, n); else if (i && ut.call(this, n)) return; this.callback(t, e, n) } }, destroy: function () { this.touch.destroy(), this.mouse.destroy() } }); var ht = R(u.style, "touchAction"), dt = void 0 !== ht, pt = function () { if (!dt) return !1; var t = {}, e = r.CSS && r.CSS.supports; return ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach((function (n) { t[n] = !e || r.CSS.supports("touch-action", n) })), t }(); function ft(t, e) { this.manager = t, this.set(e) } function mt(t) { this.options = a({}, this.defaults, t || {}), this.id = N++, this.manager = null, this.options.enable = S(this.options.enable, !0), this.state = 1, this.simultaneous = {}, this.requireFail = [] } function gt(t) { return 16 & t ? "cancel" : 8 & t ? "end" : 4 & t ? "move" : 2 & t ? "start" : "" } function _t(t) { return 16 == t ? "down" : 8 == t ? "up" : 2 == t ? "left" : 4 == t ? "right" : "" } function yt(t, e) { var n = e.manager; return n ? n.get(t) : t } function vt() { mt.apply(this, arguments) } function bt() { vt.apply(this, arguments), this.pX = null, this.pY = null } function wt() { vt.apply(this, arguments) } function Ct() { mt.apply(this, arguments), this._timer = null, this._input = null } function St() { vt.apply(this, arguments) } function Et() { vt.apply(this, arguments) } function xt() { mt.apply(this, arguments), this.pTime = !1, this.pCenter = !1, this._timer = null, this._input = null, this.count = 0 } function Tt(t, e) { return (e = e || {}).recognizers = S(e.recognizers, Tt.defaults.preset), new kt(t, e) } function kt(t, e) { var n; this.options = a({}, Tt.defaults, e || {}), this.options.inputTarget = this.options.inputTarget || t, this.handlers = {}, this.session = {}, this.recognizers = [], this.oldCssProps = {}, this.element = t, this.input = new ((n = this).options.inputClass || (F ? tt : L ? st : D ? lt : Q))(n, U), this.touchAction = new ft(this, this.options.touchAction), Pt(this, !0), g(this.options.recognizers, (function (t) { var e = this.add(new t[0](t[1])); t[2] && e.recognizeWith(t[2]), t[3] && e.requireFailure(t[3]) }), this) } function Pt(t, e) { var n, i = t.element; i.style && (g(t.options.cssProps, (function (r, s) { n = R(i.style, s), e ? (t.oldCssProps[n] = i.style[n], i.style[n] = r) : i.style[n] = t.oldCssProps[n] || "" })), e || (t.oldCssProps = {})) } ft.prototype = { set: function (t) { "compute" == t && (t = this.compute()), dt && this.manager.element.style && pt[t] && (this.manager.element.style[ht] = t), this.actions = t.toLowerCase().trim() }, update: function () { this.set(this.manager.options.touchAction) }, compute: function () { var t = []; return g(this.manager.recognizers, (function (e) { C(e.options.enable, [e]) && (t = t.concat(e.getTouchAction())) })), function (t) { if (k(t, "none")) return "none"; var e = k(t, "pan-x"), n = k(t, "pan-y"); return e && n ? "none" : e || n ? e ? "pan-x" : "pan-y" : k(t, "manipulation") ? "manipulation" : "auto" }(t.join(" ")) }, preventDefaults: function (t) { var e = t.srcEvent, n = t.offsetDirection; if (this.manager.session.prevented) e.preventDefault(); else { var i = this.actions, r = k(i, "none") && !pt.none, s = k(i, "pan-y") && !pt["pan-y"], o = k(i, "pan-x") && !pt["pan-x"]; if (r && 1 === t.pointers.length && t.distance < 2 && t.deltaTime < 250) return; if (!o || !s) return r || s && 6 & n || o && 24 & n ? this.preventSrc(e) : void 0 } }, preventSrc: function (t) { this.manager.session.prevented = !0, t.preventDefault() } }, mt.prototype = { defaults: {}, set: function (t) { return a(this.options, t), this.manager && this.manager.touchAction.update(), this }, recognizeWith: function (t) { if (m(t, "recognizeWith", this)) return this; var e = this.simultaneous; return e[(t = yt(t, this)).id] || (e[t.id] = t, t.recognizeWith(this)), this }, dropRecognizeWith: function (t) { return m(t, "dropRecognizeWith", this) || (t = yt(t, this), delete this.simultaneous[t.id]), this }, requireFailure: function (t) { if (m(t, "requireFailure", this)) return this; var e = this.requireFail; return -1 === O(e, t = yt(t, this)) && (e.push(t), t.requireFailure(this)), this }, dropRequireFailure: function (t) { if (m(t, "dropRequireFailure", this)) return this; t = yt(t, this); var e = O(this.requireFail, t); return e > -1 && this.requireFail.splice(e, 1), this }, hasRequireFailures: function () { return this.requireFail.length > 0 }, canRecognizeWith: function (t) { return !!this.simultaneous[t.id] }, emit: function (t) { var e = this, n = this.state; function i(n) { e.manager.emit(n, t) } n < 8 && i(e.options.event + gt(n)), i(e.options.event), t.additionalEvent && i(t.additionalEvent), n >= 8 && i(e.options.event + gt(n)) }, tryEmit: function (t) { if (this.canEmit()) return this.emit(t); this.state = 32 }, canEmit: function () { for (var t = 0; t < this.requireFail.length;) { if (!(33 & this.requireFail[t].state)) return !1; t++ } return !0 }, recognize: function (t) { var e = a({}, t); if (!C(this.options.enable, [this, e])) return this.reset(), void (this.state = 32); 56 & this.state && (this.state = 1), this.state = this.process(e), 30 & this.state && this.tryEmit(e) }, process: function (t) { }, getTouchAction: function () { }, reset: function () { } }, b(vt, mt, { defaults: { pointers: 1 }, attrTest: function (t) { var e = this.options.pointers; return 0 === e || t.pointers.length === e }, process: function (t) { var e = this.state, n = t.eventType, i = 6 & e, r = this.attrTest(t); return i && (8 & n || !r) ? 16 | e : i || r ? 4 & n ? 8 | e : 2 & e ? 4 | e : 2 : 32 } }), b(bt, vt, { defaults: { event: "pan", threshold: 10, pointers: 1, direction: 30 }, getTouchAction: function () { var t = this.options.direction, e = []; return 6 & t && e.push("pan-y"), 24 & t && e.push("pan-x"), e }, directionTest: function (t) { var e = this.options, n = !0, i = t.distance, r = t.direction, s = t.deltaX, o = t.deltaY; return r & e.direction || (6 & e.direction ? (r = 0 === s ? 1 : s < 0 ? 2 : 4, n = s != this.pX, i = Math.abs(t.deltaX)) : (r = 0 === o ? 1 : o < 0 ? 8 : 16, n = o != this.pY, i = Math.abs(t.deltaY))), t.direction = r, n && i > e.threshold && r & e.direction }, attrTest: function (t) { return vt.prototype.attrTest.call(this, t) && (2 & this.state || !(2 & this.state) && this.directionTest(t)) }, emit: function (t) { this.pX = t.deltaX, this.pY = t.deltaY; var e = _t(t.direction); e && (t.additionalEvent = this.options.event + e), this._super.emit.call(this, t) } }), b(wt, vt, { defaults: { event: "pinch", threshold: 0, pointers: 2 }, getTouchAction: function () { return ["none"] }, attrTest: function (t) { return this._super.attrTest.call(this, t) && (Math.abs(t.scale - 1) > this.options.threshold || 2 & this.state) }, emit: function (t) { 1 !== t.scale && (t.additionalEvent = this.options.event + (t.scale < 1 ? "in" : "out")), this._super.emit.call(this, t) } }), b(Ct, mt, { defaults: { event: "press", pointers: 1, time: 251, threshold: 9 }, getTouchAction: function () { return ["auto"] }, process: function (t) { var e = this.options, n = t.pointers.length === e.pointers, i = t.distance < e.threshold, r = t.deltaTime > e.time; if (this._input = t, !i || !n || 12 & t.eventType && !r) this.reset(); else if (1 & t.eventType) this.reset(), this._timer = f((function () { this.state = 8, this.tryEmit() }), e.time, this); else if (4 & t.eventType) return 8; return 32 }, reset: function () { clearTimeout(this._timer) }, emit: function (t) { 8 === this.state && (t && 4 & t.eventType ? this.manager.emit(this.options.event + "up", t) : (this._input.timeStamp = p(), this.manager.emit(this.options.event, this._input))) } }), b(St, vt, { defaults: { event: "rotate", threshold: 0, pointers: 2 }, getTouchAction: function () { return ["none"] }, attrTest: function (t) { return this._super.attrTest.call(this, t) && (Math.abs(t.rotation) > this.options.threshold || 2 & this.state) } }), b(Et, vt, { defaults: { event: "swipe", threshold: 10, velocity: .3, direction: 30, pointers: 1 }, getTouchAction: function () { return bt.prototype.getTouchAction.call(this) }, attrTest: function (t) { var e, n = this.options.direction; return 30 & n ? e = t.overallVelocity : 6 & n ? e = t.overallVelocityX : 24 & n && (e = t.overallVelocityY), this._super.attrTest.call(this, t) && n & t.offsetDirection && t.distance > this.options.threshold && t.maxPointers == this.options.pointers && d(e) > this.options.velocity && 4 & t.eventType }, emit: function (t) { var e = _t(t.offsetDirection); e && this.manager.emit(this.options.event + e, t), this.manager.emit(this.options.event, t) } }), b(xt, mt, { defaults: { event: "tap", pointers: 1, taps: 1, interval: 300, time: 250, threshold: 9, posThreshold: 10 }, getTouchAction: function () { return ["manipulation"] }, process: function (t) { var e = this.options, n = t.pointers.length === e.pointers, i = t.distance < e.threshold, r = t.deltaTime < e.time; if (this.reset(), 1 & t.eventType && 0 === this.count) return this.failTimeout(); if (i && r && n) { if (4 != t.eventType) return this.failTimeout(); var s = !this.pTime || t.timeStamp - this.pTime < e.interval, o = !this.pCenter || q(this.pCenter, t.center) < e.posThreshold; if (this.pTime = t.timeStamp, this.pCenter = t.center, o && s ? this.count += 1 : this.count = 1, this._input = t, 0 == this.count % e.taps) return this.hasRequireFailures() ? (this._timer = f((function () { this.state = 8, this.tryEmit() }), e.interval, this), 2) : 8 } return 32 }, failTimeout: function () { return this._timer = f((function () { this.state = 32 }), this.options.interval, this), 32 }, reset: function () { clearTimeout(this._timer) }, emit: function () { 8 == this.state && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input)) } }), Tt.VERSION = "2.0.7", Tt.defaults = { domEvents: !1, touchAction: "compute", enable: !0, inputTarget: null, inputClass: null, preset: [[St, { enable: !1 }], [wt, { enable: !1 }, ["rotate"]], [Et, { direction: 6 }], [bt, { direction: 6 }, ["swipe"]], [xt], [xt, { event: "doubletap", taps: 2 }, ["tap"]], [Ct]], cssProps: { userSelect: "none", touchSelect: "none", touchCallout: "none", contentZooming: "none", userDrag: "none", tapHighlightColor: "rgba(0,0,0,0)" } }, kt.prototype = { set: function (t) { return a(this.options, t), t.touchAction && this.touchAction.update(), t.inputTarget && (this.input.destroy(), this.input.target = t.inputTarget, this.input.init()), this }, stop: function (t) { this.session.stopped = t ? 2 : 1 }, recognize: function (t) { var e = this.session; if (!e.stopped) { var n; this.touchAction.preventDefaults(t); var i = this.recognizers, r = e.curRecognizer; (!r || r && 8 & r.state) && (r = e.curRecognizer = null); for (var s = 0; s < i.length;)n = i[s], 2 === e.stopped || r && n != r && !n.canRecognizeWith(r) ? n.reset() : n.recognize(t), !r && 14 & n.state && (r = e.curRecognizer = n), s++ } }, get: function (t) { if (t instanceof mt) return t; for (var e = this.recognizers, n = 0; n < e.length; n++)if (e[n].options.event == t) return e[n]; return null }, add: function (t) { if (m(t, "add", this)) return this; var e = this.get(t.options.event); return e && this.remove(e), this.recognizers.push(t), t.manager = this, this.touchAction.update(), t }, remove: function (t) { if (m(t, "remove", this)) return this; if (t = this.get(t)) { var e = this.recognizers, n = O(e, t); -1 !== n && (e.splice(n, 1), this.touchAction.update()) } return this }, on: function (t, e) { if (void 0 !== t && void 0 !== e) { var n = this.handlers; return g(P(t), (function (t) { n[t] = n[t] || [], n[t].push(e) })), this } }, off: function (t, e) { if (void 0 !== t) { var n = this.handlers; return g(P(t), (function (t) { e ? n[t] && n[t].splice(O(n[t], e), 1) : delete n[t] })), this } }, emit: function (t, e) { this.options.domEvents && function (t, e) { var n = s.createEvent("Event"); n.initEvent(t, !0, !0), n.gesture = e, e.target.dispatchEvent(n) }(t, e); var n = this.handlers[t] && this.handlers[t].slice(); if (n && n.length) { e.type = t, e.preventDefault = function () { e.srcEvent.preventDefault() }; for (var i = 0; i < n.length;)n[i](e), i++ } }, destroy: function () { this.element && Pt(this, !1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null } }, a(Tt, { INPUT_START: 1, INPUT_MOVE: 2, INPUT_END: 4, INPUT_CANCEL: 8, STATE_POSSIBLE: 1, STATE_BEGAN: 2, STATE_CHANGED: 4, STATE_ENDED: 8, STATE_RECOGNIZED: 8, STATE_CANCELLED: 16, STATE_FAILED: 32, DIRECTION_NONE: 1, DIRECTION_LEFT: 2, DIRECTION_RIGHT: 4, DIRECTION_UP: 8, DIRECTION_DOWN: 16, DIRECTION_HORIZONTAL: 6, DIRECTION_VERTICAL: 24, DIRECTION_ALL: 30, Manager: kt, Input: j, TouchAction: ft, TouchInput: st, MouseInput: Q, PointerEventInput: tt, TouchMouseInput: lt, SingleTouchInput: nt, Recognizer: mt, AttrRecognizer: vt, Tap: xt, Pan: bt, Swipe: Et, Pinch: wt, Rotate: St, Press: Ct, on: E, off: x, each: g, merge: v, extend: y, assign: a, inherit: b, bindFn: w, prefixed: R }), (void 0 !== r ? r : "undefined" != typeof self ? self : {}).Hammer = Tt, void 0 === (i = (function () { return Tt }).call(e, n, e, t)) || (t.exports = i) }(window, document) }, zUnb: function (t, e, n) { "use strict"; function i(t) { return "function" == typeof t } n.r(e), n("yLV6"); let r = !1; const s = { Promise: void 0, set useDeprecatedSynchronousErrorHandling(t) { r = t }, get useDeprecatedSynchronousErrorHandling() { return r } }; function o(t) { setTimeout(() => { throw t }) } const l = { closed: !0, next(t) { }, error(t) { if (s.useDeprecatedSynchronousErrorHandling) throw t; o(t) }, complete() { } }, a = Array.isArray || (t => t && "number" == typeof t.length); function c(t) { return null !== t && "object" == typeof t } function u(t) { return Error.call(this), this.message = t ? `${t.length} errors occurred during unsubscription:\n${t.map((t, e) => `${e + 1}) ${t.toString()}`).join("\n  ")}` : "", this.name = "UnsubscriptionError", this.errors = t, this } u.prototype = Object.create(Error.prototype); const h = u; let d = (() => { class t { constructor(t) { this.closed = !1, this._parent = null, this._parents = null, this._subscriptions = null, t && (this._unsubscribe = t) } unsubscribe() { let t, e = !1; if (this.closed) return; let { _parent: n, _parents: r, _unsubscribe: s, _subscriptions: o } = this; this.closed = !0, this._parent = null, this._parents = null, this._subscriptions = null; let l = -1, u = r ? r.length : 0; for (; n;)n.remove(this), n = ++l < u && r[l] || null; if (i(s)) try { s.call(this) } catch (d) { e = !0, t = d instanceof h ? p(d.errors) : [d] } if (a(o)) for (l = -1, u = o.length; ++l < u;) { const n = o[l]; if (c(n)) try { n.unsubscribe() } catch (d) { e = !0, t = t || [], d instanceof h ? t = t.concat(p(d.errors)) : t.push(d) } } if (e) throw new h(t) } add(e) { let n = e; switch (typeof e) { case "function": n = new t(e); case "object": if (n === this || n.closed || "function" != typeof n.unsubscribe) return n; if (this.closed) return n.unsubscribe(), n; if (!(n instanceof t)) { const e = n; n = new t, n._subscriptions = [e] } break; default: if (!e) return t.EMPTY; throw new Error("unrecognized teardown " + e + " added to Subscription.") }if (n._addParent(this)) { const t = this._subscriptions; t ? t.push(n) : this._subscriptions = [n] } return n } remove(t) { const e = this._subscriptions; if (e) { const n = e.indexOf(t); -1 !== n && e.splice(n, 1) } } _addParent(t) { let { _parent: e, _parents: n } = this; return e !== t && (e ? n ? -1 === n.indexOf(t) && (n.push(t), !0) : (this._parents = [t], !0) : (this._parent = t, !0)) } } return t.EMPTY = function (t) { return t.closed = !0, t }(new t), t })(); function p(t) { return t.reduce((t, e) => t.concat(e instanceof h ? e.errors : e), []) } const f = "function" == typeof Symbol ? Symbol("rxSubscriber") : "@@rxSubscriber_" + Math.random(); class m extends d { constructor(t, e, n) { switch (super(), this.syncErrorValue = null, this.syncErrorThrown = !1, this.syncErrorThrowable = !1, this.isStopped = !1, arguments.length) { case 0: this.destination = l; break; case 1: if (!t) { this.destination = l; break } if ("object" == typeof t) { t instanceof m ? (this.syncErrorThrowable = t.syncErrorThrowable, this.destination = t, t.add(this)) : (this.syncErrorThrowable = !0, this.destination = new g(this, t)); break } default: this.syncErrorThrowable = !0, this.destination = new g(this, t, e, n) } } [f]() { return this } static create(t, e, n) { const i = new m(t, e, n); return i.syncErrorThrowable = !1, i } next(t) { this.isStopped || this._next(t) } error(t) { this.isStopped || (this.isStopped = !0, this._error(t)) } complete() { this.isStopped || (this.isStopped = !0, this._complete()) } unsubscribe() { this.closed || (this.isStopped = !0, super.unsubscribe()) } _next(t) { this.destination.next(t) } _error(t) { this.destination.error(t), this.unsubscribe() } _complete() { this.destination.complete(), this.unsubscribe() } _unsubscribeAndRecycle() { const { _parent: t, _parents: e } = this; return this._parent = null, this._parents = null, this.unsubscribe(), this.closed = !1, this.isStopped = !1, this._parent = t, this._parents = e, this } } class g extends m { constructor(t, e, n, r) { let s; super(), this._parentSubscriber = t; let o = this; i(e) ? s = e : e && (s = e.next, n = e.error, r = e.complete, e !== l && (o = Object.create(e), i(o.unsubscribe) && this.add(o.unsubscribe.bind(o)), o.unsubscribe = this.unsubscribe.bind(this))), this._context = o, this._next = s, this._error = n, this._complete = r } next(t) { if (!this.isStopped && this._next) { const { _parentSubscriber: e } = this; s.useDeprecatedSynchronousErrorHandling && e.syncErrorThrowable ? this.__tryOrSetError(e, this._next, t) && this.unsubscribe() : this.__tryOrUnsub(this._next, t) } } error(t) { if (!this.isStopped) { const { _parentSubscriber: e } = this, { useDeprecatedSynchronousErrorHandling: n } = s; if (this._error) n && e.syncErrorThrowable ? (this.__tryOrSetError(e, this._error, t), this.unsubscribe()) : (this.__tryOrUnsub(this._error, t), this.unsubscribe()); else if (e.syncErrorThrowable) n ? (e.syncErrorValue = t, e.syncErrorThrown = !0) : o(t), this.unsubscribe(); else { if (this.unsubscribe(), n) throw t; o(t) } } } complete() { if (!this.isStopped) { const { _parentSubscriber: t } = this; if (this._complete) { const e = () => this._complete.call(this._context); s.useDeprecatedSynchronousErrorHandling && t.syncErrorThrowable ? (this.__tryOrSetError(t, e), this.unsubscribe()) : (this.__tryOrUnsub(e), this.unsubscribe()) } else this.unsubscribe() } } __tryOrUnsub(t, e) { try { t.call(this._context, e) } catch (n) { if (this.unsubscribe(), s.useDeprecatedSynchronousErrorHandling) throw n; o(n) } } __tryOrSetError(t, e, n) { if (!s.useDeprecatedSynchronousErrorHandling) throw new Error("bad call"); try { e.call(this._context, n) } catch (i) { return s.useDeprecatedSynchronousErrorHandling ? (t.syncErrorValue = i, t.syncErrorThrown = !0, !0) : (o(i), !0) } return !1 } _unsubscribe() { const { _parentSubscriber: t } = this; this._context = null, this._parentSubscriber = null, t.unsubscribe() } } const _ = "function" == typeof Symbol && Symbol.observable || "@@observable"; function y() { } function v(...t) { return b(t) } function b(t) { return t ? 1 === t.length ? t[0] : function (e) { return t.reduce((t, e) => e(t), e) } : y } let w = (() => { class t { constructor(t) { this._isScalar = !1, t && (this._subscribe = t) } lift(e) { const n = new t; return n.source = this, n.operator = e, n } subscribe(t, e, n) { const { operator: i } = this, r = function (t, e, n) { if (t) { if (t instanceof m) return t; if (t[f]) return t[f]() } return t || e || n ? new m(t, e, n) : new m(l) }(t, e, n); if (r.add(i ? i.call(r, this.source) : this.source || s.useDeprecatedSynchronousErrorHandling && !r.syncErrorThrowable ? this._subscribe(r) : this._trySubscribe(r)), s.useDeprecatedSynchronousErrorHandling && r.syncErrorThrowable && (r.syncErrorThrowable = !1, r.syncErrorThrown)) throw r.syncErrorValue; return r } _trySubscribe(t) { try { return this._subscribe(t) } catch (e) { s.useDeprecatedSynchronousErrorHandling && (t.syncErrorThrown = !0, t.syncErrorValue = e), function (t) { for (; t;) { const { closed: e, destination: n, isStopped: i } = t; if (e || i) return !1; t = n && n instanceof m ? n : null } return !0 }(t) ? t.error(e) : console.warn(e) } } forEach(t, e) { return new (e = C(e))((e, n) => { let i; i = this.subscribe(e => { try { t(e) } catch (r) { n(r), i && i.unsubscribe() } }, n, e) }) } _subscribe(t) { const { source: e } = this; return e && e.subscribe(t) } [_]() { return this } pipe(...t) { return 0 === t.length ? this : b(t)(this) } toPromise(t) { return new (t = C(t))((t, e) => { let n; this.subscribe(t => n = t, t => e(t), () => t(n)) }) } } return t.create = e => new t(e), t })(); function C(t) { if (t || (t = s.Promise || Promise), !t) throw new Error("no Promise impl found"); return t } function S() { return Error.call(this), this.message = "object unsubscribed", this.name = "ObjectUnsubscribedError", this } S.prototype = Object.create(Error.prototype); const E = S; class x extends d { constructor(t, e) { super(), this.subject = t, this.subscriber = e, this.closed = !1 } unsubscribe() { if (this.closed) return; this.closed = !0; const t = this.subject, e = t.observers; if (this.subject = null, !e || 0 === e.length || t.isStopped || t.closed) return; const n = e.indexOf(this.subscriber); -1 !== n && e.splice(n, 1) } } class T extends m { constructor(t) { super(t), this.destination = t } } let k = (() => { class t extends w { constructor() { super(), this.observers = [], this.closed = !1, this.isStopped = !1, this.hasError = !1, this.thrownError = null } [f]() { return new T(this) } lift(t) { const e = new P(this, this); return e.operator = t, e } next(t) { if (this.closed) throw new E; if (!this.isStopped) { const { observers: e } = this, n = e.length, i = e.slice(); for (let r = 0; r < n; r++)i[r].next(t) } } error(t) { if (this.closed) throw new E; this.hasError = !0, this.thrownError = t, this.isStopped = !0; const { observers: e } = this, n = e.length, i = e.slice(); for (let r = 0; r < n; r++)i[r].error(t); this.observers.length = 0 } complete() { if (this.closed) throw new E; this.isStopped = !0; const { observers: t } = this, e = t.length, n = t.slice(); for (let i = 0; i < e; i++)n[i].complete(); this.observers.length = 0 } unsubscribe() { this.isStopped = !0, this.closed = !0, this.observers = null } _trySubscribe(t) { if (this.closed) throw new E; return super._trySubscribe(t) } _subscribe(t) { if (this.closed) throw new E; return this.hasError ? (t.error(this.thrownError), d.EMPTY) : this.isStopped ? (t.complete(), d.EMPTY) : (this.observers.push(t), new x(this, t)) } asObservable() { const t = new w; return t.source = this, t } } return t.create = (t, e) => new P(t, e), t })(); class P extends k { constructor(t, e) { super(), this.destination = t, this.source = e } next(t) { const { destination: e } = this; e && e.next && e.next(t) } error(t) { const { destination: e } = this; e && e.error && this.destination.error(t) } complete() { const { destination: t } = this; t && t.complete && this.destination.complete() } _subscribe(t) { const { source: e } = this; return e ? this.source.subscribe(t) : d.EMPTY } } function O(t) { return t && "function" == typeof t.schedule } class I extends m { constructor(t, e, n) { super(), this.parent = t, this.outerValue = e, this.outerIndex = n, this.index = 0 } _next(t) { this.parent.notifyNext(this.outerValue, t, this.outerIndex, this.index++, this) } _error(t) { this.parent.notifyError(t, this), this.unsubscribe() } _complete() { this.parent.notifyComplete(this), this.unsubscribe() } } const A = t => e => { for (let n = 0, i = t.length; n < i && !e.closed; n++)e.next(t[n]); e.closed || e.complete() }, R = t => e => (t.then(t => { e.closed || (e.next(t), e.complete()) }, t => e.error(t)).then(null, o), e); function N() { return "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator" } const M = N(), D = t => e => { const n = t[M](); for (; ;) { const t = n.next(); if (t.done) { e.complete(); break } if (e.next(t.value), e.closed) break } return "function" == typeof n.return && e.add(() => { n.return && n.return() }), e }, F = t => e => { const n = t[_](); if ("function" != typeof n.subscribe) throw new TypeError("Provided object does not correctly implement Symbol.observable"); return n.subscribe(e) }, L = t => t && "number" == typeof t.length && "function" != typeof t; function V(t) { return !!t && "function" != typeof t.subscribe && "function" == typeof t.then } const z = t => { if (t instanceof w) return e => t._isScalar ? (e.next(t.value), void e.complete()) : t.subscribe(e); if (t && "function" == typeof t[_]) return F(t); if (L(t)) return A(t); if (V(t)) return R(t); if (t && "function" == typeof t[M]) return D(t); { const e = c(t) ? "an invalid object" : `'${t}'`; throw new TypeError(`You provided ${e} where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.`) } }; function j(t, e, n, i, r = new I(t, n, i)) { if (!r.closed) return z(e)(r) } class U extends m { notifyNext(t, e, n, i, r) { this.destination.next(e) } notifyError(t, e) { this.destination.error(t) } notifyComplete(t) { this.destination.complete() } } function H(t, e) { return function (n) { if ("function" != typeof t) throw new TypeError("argument is not a function. Are you looking for `mapTo()`?"); return n.lift(new B(t, e)) } } class B { constructor(t, e) { this.project = t, this.thisArg = e } call(t, e) { return e.subscribe(new $(t, this.project, this.thisArg)) } } class $ extends m { constructor(t, e, n) { super(t), this.project = e, this.count = 0, this.thisArg = n || this } _next(t) { let e; try { e = this.project.call(this.thisArg, t, this.count++) } catch (n) { return void this.destination.error(n) } this.destination.next(e) } } function W(t, e) { return new w(e ? n => { const i = new d; let r = 0; return i.add(e.schedule((function () { r !== t.length ? (n.next(t[r++]), n.closed || i.add(this.schedule())) : n.complete() }))), i } : A(t)) } function q(t, e) { if (!e) return t instanceof w ? t : new w(z(t)); if (null != t) { if (function (t) { return t && "function" == typeof t[_] }(t)) return function (t, e) { return new w(e ? n => { const i = new d; return i.add(e.schedule(() => { const r = t[_](); i.add(r.subscribe({ next(t) { i.add(e.schedule(() => n.next(t))) }, error(t) { i.add(e.schedule(() => n.error(t))) }, complete() { i.add(e.schedule(() => n.complete())) } })) })), i } : F(t)) }(t, e); if (V(t)) return function (t, e) { return new w(e ? n => { const i = new d; return i.add(e.schedule(() => t.then(t => { i.add(e.schedule(() => { n.next(t), i.add(e.schedule(() => n.complete())) })) }, t => { i.add(e.schedule(() => n.error(t))) }))), i } : R(t)) }(t, e); if (L(t)) return W(t, e); if (function (t) { return t && "function" == typeof t[M] }(t) || "string" == typeof t) return function (t, e) { if (!t) throw new Error("Iterable cannot be null"); return new w(e ? n => { const i = new d; let r; return i.add(() => { r && "function" == typeof r.return && r.return() }), i.add(e.schedule(() => { r = t[M](), i.add(e.schedule((function () { if (n.closed) return; let t, e; try { const n = r.next(); t = n.value, e = n.done } catch (i) { return void n.error(i) } e ? n.complete() : (n.next(t), this.schedule()) }))) })), i } : D(t)) }(t, e) } throw new TypeError((null !== t && typeof t || t) + " is not observable") } function G(t, e, n = Number.POSITIVE_INFINITY) { return "function" == typeof e ? i => i.pipe(G((n, i) => q(t(n, i)).pipe(H((t, r) => e(n, t, i, r))), n)) : ("number" == typeof e && (n = e), e => e.lift(new Z(t, n))) } class Z { constructor(t, e = Number.POSITIVE_INFINITY) { this.project = t, this.concurrent = e } call(t, e) { return e.subscribe(new Q(t, this.project, this.concurrent)) } } class Q extends U { constructor(t, e, n = Number.POSITIVE_INFINITY) { super(t), this.project = e, this.concurrent = n, this.hasCompleted = !1, this.buffer = [], this.active = 0, this.index = 0 } _next(t) { this.active < this.concurrent ? this._tryNext(t) : this.buffer.push(t) } _tryNext(t) { let e; const n = this.index++; try { e = this.project(t, n) } catch (i) { return void this.destination.error(i) } this.active++, this._innerSub(e, t, n) } _innerSub(t, e, n) { const i = new I(this, void 0, void 0); this.destination.add(i), j(this, t, e, n, i) } _complete() { this.hasCompleted = !0, 0 === this.active && 0 === this.buffer.length && this.destination.complete(), this.unsubscribe() } notifyNext(t, e, n, i, r) { this.destination.next(e) } notifyComplete(t) { const e = this.buffer; this.remove(t), this.active--, e.length > 0 ? this._next(e.shift()) : 0 === this.active && this.hasCompleted && this.destination.complete() } } function K(t) { return t } function Y(t = Number.POSITIVE_INFINITY) { return G(K, t) } function X(...t) { let e = Number.POSITIVE_INFINITY, n = null, i = t[t.length - 1]; return O(i) ? (n = t.pop(), t.length > 1 && "number" == typeof t[t.length - 1] && (e = t.pop())) : "number" == typeof i && (e = t.pop()), null === n && 1 === t.length && t[0] instanceof w ? t[0] : Y(e)(W(t, n)) } function J() { return function (t) { return t.lift(new tt(t)) } } class tt { constructor(t) { this.connectable = t } call(t, e) { const { connectable: n } = this; n._refCount++; const i = new et(t, n), r = e.subscribe(i); return i.closed || (i.connection = n.connect()), r } } class et extends m { constructor(t, e) { super(t), this.connectable = e } _unsubscribe() { const { connectable: t } = this; if (!t) return void (this.connection = null); this.connectable = null; const e = t._refCount; if (e <= 0) return void (this.connection = null); if (t._refCount = e - 1, e > 1) return void (this.connection = null); const { connection: n } = this, i = t._connection; this.connection = null, !i || n && i !== n || i.unsubscribe() } } const nt = class extends w { constructor(t, e) { super(), this.source = t, this.subjectFactory = e, this._refCount = 0, this._isComplete = !1 } _subscribe(t) { return this.getSubject().subscribe(t) } getSubject() { const t = this._subject; return t && !t.isStopped || (this._subject = this.subjectFactory()), this._subject } connect() { let t = this._connection; return t || (this._isComplete = !1, t = this._connection = new d, t.add(this.source.subscribe(new rt(this.getSubject(), this))), t.closed ? (this._connection = null, t = d.EMPTY) : this._connection = t), t } refCount() { return J()(this) } }.prototype, it = { operator: { value: null }, _refCount: { value: 0, writable: !0 }, _subject: { value: null, writable: !0 }, _connection: { value: null, writable: !0 }, _subscribe: { value: nt._subscribe }, _isComplete: { value: nt._isComplete, writable: !0 }, getSubject: { value: nt.getSubject }, connect: { value: nt.connect }, refCount: { value: nt.refCount } }; class rt extends T { constructor(t, e) { super(t), this.connectable = e } _error(t) { this._unsubscribe(), super._error(t) } _complete() { this.connectable._isComplete = !0, this._unsubscribe(), super._complete() } _unsubscribe() { const t = this.connectable; if (t) { this.connectable = null; const e = t._connection; t._refCount = 0, t._subject = null, t._connection = null, e && e.unsubscribe() } } } function st() { return new k } function ot() { return t => { return J()((e = st, function (t) { let n; n = "function" == typeof e ? e : function () { return e }; const i = Object.create(t, it); return i.source = t, i.subjectFactory = n, i })(t)); var e } } function lt(t, e, n) { const i = function (t) { return function (...e) { if (t) { const n = t(...e); for (const t in n) this[t] = n[t] } } }(e); function r(...t) { if (this instanceof r) return i.apply(this, t), this; const e = new r(...t); return n.annotation = e, n; function n(t, n, i) { const r = t.hasOwnProperty("__parameters__") ? t.__parameters__ : Object.defineProperty(t, "__parameters__", { value: [] }).__parameters__; for (; r.length <= i;)r.push(null); return (r[i] = r[i] || []).push(e), t } } return n && (r.prototype = Object.create(n.prototype)), r.prototype.ngMetadataName = t, r.annotationCls = r, r } const at = lt("Inject", t => ({ token: t })), ct = lt("Optional"), ut = lt("Self"), ht = lt("SkipSelf"); var dt = function (t) { return t[t.Default = 0] = "Default", t[t.Host = 1] = "Host", t[t.Self = 2] = "Self", t[t.SkipSelf = 4] = "SkipSelf", t[t.Optional = 8] = "Optional", t }({}); function pt(t) { for (let e in t) if (t[e] === pt) return e; throw Error("Could not find renamed property on target object.") } function ft(t) { return { token: t.token, providedIn: t.providedIn || null, factory: t.factory, value: void 0 } } function mt(t) { const e = t[gt]; return e && e.token === t ? e : null } const gt = pt({ ngInjectableDef: pt }); function _t(t) { if ("string" == typeof t) return t; if (t instanceof Array) return "[" + t.map(_t).join(", ") + "]"; if (null == t) return "" + t; if (t.overriddenName) return "" + t.overriddenName; if (t.name) return "" + t.name; const e = t.toString(); if (null == e) return "" + e; const n = e.indexOf("\n"); return -1 === n ? e : e.substring(0, n) } const yt = pt({ __forward_ref__: pt }); function vt(t) { return t.__forward_ref__ = vt, t.toString = function () { return _t(this()) }, t } function bt(t) { const e = t; return "function" == typeof e && e.hasOwnProperty(yt) && e.__forward_ref__ === vt ? e() : t } const wt = "undefined" != typeof globalThis && globalThis, Ct = "undefined" != typeof window && window, St = "undefined" != typeof self && "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && self, Et = "undefined" != typeof global && global, xt = wt || Et || Ct || St; class Tt { constructor(t, e) { this._desc = t, this.ngMetadataName = "InjectionToken", this.ngInjectableDef = void 0, "number" == typeof e ? this.__NG_ELEMENT_ID__ = e : void 0 !== e && (this.ngInjectableDef = ft({ token: this, providedIn: e.providedIn || "root", factory: e.factory })) } toString() { return "InjectionToken " + this._desc } } const kt = new Tt("INJECTOR", -1), Pt = new Object, Ot = /\n/gm, It = pt({ provide: String, useValue: pt }); let At = void 0; function Rt(t) { const e = At; return At = t, e } function Nt(t, e = dt.Default) { return function (t, e = dt.Default) { if (void 0 === At) throw new Error("inject() must be called from an injection context"); return null === At ? function (t, e, n) { const i = mt(t); if (i && "root" == i.providedIn) return void 0 === i.value ? i.value = i.factory() : i.value; if (n & dt.Optional) return null; throw new Error(`Injector: NOT_FOUND [${_t(t)}]`) }(t, 0, e) : At.get(t, e & dt.Optional ? null : void 0, e) }(t, e) } const Mt = Nt; class Dt { get(t, e = Pt) { if (e === Pt) { const e = new Error(`NullInjectorError: No provider for ${_t(t)}!`); throw e.name = "NullInjectorError", e } return e } } function Ft(t, e, n, i = null) { t = t && "\n" === t.charAt(0) && "\u0275" == t.charAt(1) ? t.substr(2) : t; let r = _t(e); if (e instanceof Array) r = e.map(_t).join(" -> "); else if ("object" == typeof e) { let t = []; for (let n in e) if (e.hasOwnProperty(n)) { let i = e[n]; t.push(n + ":" + ("string" == typeof i ? JSON.stringify(i) : _t(i))) } r = `{${t.join(", ")}}` } return `${n}${i ? "(" + i + ")" : ""}[${r}]: ${t.replace(Ot, "\n  ")}` } const Lt = new Tt("The presence of this token marks an injector as being the root injector."), Vt = function (t, e, n) { return new $t(t, e, n) }; let zt = (() => { class t { static create(t, e) { return Array.isArray(t) ? Vt(t, e, "") : Vt(t.providers, t.parent, t.name || "") } } return t.THROW_IF_NOT_FOUND = Pt, t.NULL = new Dt, t.ngInjectableDef = ft({ token: t, providedIn: "any", factory: () => Nt(kt) }), t.__NG_ELEMENT_ID__ = -1, t })(); const jt = function (t) { return t }, Ut = [], Ht = jt, Bt = function () { return Array.prototype.slice.call(arguments) }; class $t { constructor(t, e = zt.NULL, n = null) { this.parent = e, this.source = n; const i = this._records = new Map; i.set(zt, { token: zt, fn: jt, deps: Ut, value: this, useNew: !1 }), i.set(kt, { token: kt, fn: jt, deps: Ut, value: this, useNew: !1 }), function t(e, n) { if (n) if ((n = bt(n)) instanceof Array) for (let i = 0; i < n.length; i++)t(e, n[i]); else { if ("function" == typeof n) throw qt("Function/Class not supported", n); if (!n || "object" != typeof n || !n.provide) throw qt("Unexpected provider", n); { let t = bt(n.provide); const i = function (t) { const e = function (t) { let e = Ut; const n = t.deps; if (n && n.length) { e = []; for (let t = 0; t < n.length; t++) { let i = 6, r = bt(n[t]); if (r instanceof Array) for (let t = 0, e = r; t < e.length; t++) { const n = e[t]; n instanceof ct || n == ct ? i |= 1 : n instanceof ht || n == ht ? i &= -3 : n instanceof ut || n == ut ? i &= -5 : r = n instanceof at ? n.token : bt(n) } e.push({ token: r, options: i }) } } else if (t.useExisting) e = [{ token: bt(t.useExisting), options: 6 }]; else if (!n && !(It in t)) throw qt("'deps' required", t); return e }(t); let n = jt, i = Ut, r = !1, s = bt(t.provide); if (It in t) i = t.useValue; else if (t.useFactory) n = t.useFactory; else if (t.useExisting); else if (t.useClass) r = !0, n = bt(t.useClass); else { if ("function" != typeof s) throw qt("StaticProvider does not have [useValue|useFactory|useExisting|useClass] or [provide] is not newable", t); r = !0, n = s } return { deps: e, fn: n, useNew: r, value: i } }(n); if (!0 === n.multi) { let i = e.get(t); if (i) { if (i.fn !== Bt) throw Wt(t) } else e.set(t, i = { token: n.provide, deps: [], useNew: !1, fn: Bt, value: Ut }); t = n, i.deps.push({ token: t, options: 6 }) } const r = e.get(t); if (r && r.fn == Bt) throw Wt(t); e.set(t, i) } } }(i, t) } get(t, e, n = dt.Default) { const i = this._records.get(t); try { return function t(e, n, i, r, s, o) { try { return function (e, n, i, r, s, o) { let l; if (!n || o & dt.SkipSelf) o & dt.Self || (l = r.get(e, s, dt.Default)); else { if (l = n.value, l == Ht) throw Error("\u0275Circular dependency"); if (l === Ut) { n.value = Ht; let e = void 0, s = n.useNew, o = n.fn, a = n.deps, c = Ut; if (a.length) { c = []; for (let e = 0; e < a.length; e++) { const n = a[e], s = n.options, o = 2 & s ? i.get(n.token) : void 0; c.push(t(n.token, o, i, o || 4 & s ? r : zt.NULL, 1 & s ? null : zt.THROW_IF_NOT_FOUND, dt.Default)) } } n.value = l = s ? new o(...c) : o.apply(e, c) } } return l }(e, n, i, r, s, o) } catch (l) { throw l instanceof Error || (l = new Error(l)), (l.ngTempTokenPath = l.ngTempTokenPath || []).unshift(e), n && n.value == Ht && (n.value = Ut), l } }(t, i, this._records, this.parent, e, n) } catch (r) { return function (t, e, n, i) { const r = t.ngTempTokenPath; throw e.__source && r.unshift(e.__source), t.message = Ft("\n" + t.message, r, "StaticInjectorError", i), t.ngTokenPath = r, t.ngTempTokenPath = null, t }(r, t, 0, this.source) } } toString() { const t = []; return this._records.forEach((e, n) => t.push(_t(n))), `StaticInjector[${t.join(", ")}]` } } function Wt(t) { return qt("Cannot mix multi providers and regular providers", t) } function qt(t, e) { return new Error(Ft(t, e, "StaticInjectorError")) } const Gt = new Tt("AnalyzeForEntryComponents"), Zt = function () { var t = { Emulated: 0, Native: 1, None: 2, ShadowDom: 3 }; return t[t.Emulated] = "Emulated", t[t.Native] = "Native", t[t.None] = "None", t[t.ShadowDom] = "ShadowDom", t }(), Qt = (() => ("undefined" != typeof requestAnimationFrame && requestAnimationFrame || setTimeout).bind(xt))(); let Kt = !1; function Yt() { return Kt = !0, !0 } class Xt { constructor(t) { if (this.defaultDoc = t, this.inertDocument = this.defaultDoc.implementation.createHTMLDocument("sanitization-inert"), this.inertBodyElement = this.inertDocument.body, null == this.inertBodyElement) { const t = this.inertDocument.createElement("html"); this.inertDocument.appendChild(t), this.inertBodyElement = this.inertDocument.createElement("body"), t.appendChild(this.inertBodyElement) } this.inertBodyElement.innerHTML = '<svg><g onload="this.parentNode.remove()"></g></svg>', !this.inertBodyElement.querySelector || this.inertBodyElement.querySelector("svg") ? (this.inertBodyElement.innerHTML = '<svg><p><style><img src="</style><img src=x onerror=alert(1)//">', this.getInertBodyElement = this.inertBodyElement.querySelector && this.inertBodyElement.querySelector("svg img") && function () { try { return !!window.DOMParser } catch (t) { return !1 } }() ? this.getInertBodyElement_DOMParser : this.getInertBodyElement_InertDocument) : this.getInertBodyElement = this.getInertBodyElement_XHR } getInertBodyElement_XHR(t) { t = "<body><remove></remove>" + t + "</body>"; try { t = encodeURI(t) } catch (i) { return null } const e = new XMLHttpRequest; e.responseType = "document", e.open("GET", "data:text/html;charset=utf-8," + t, !1), e.send(void 0); const n = e.response.body; return n.removeChild(n.firstChild), n } getInertBodyElement_DOMParser(t) { t = "<body><remove></remove>" + t + "</body>"; try { const e = (new window.DOMParser).parseFromString(t, "text/html").body; return e.removeChild(e.firstChild), e } catch (e) { return null } } getInertBodyElement_InertDocument(t) { const e = this.inertDocument.createElement("template"); return "content" in e ? (e.innerHTML = t, e) : (this.inertBodyElement.innerHTML = t, this.defaultDoc.documentMode && this.stripCustomNsAttrs(this.inertBodyElement), this.inertBodyElement) } stripCustomNsAttrs(t) { const e = t.attributes; for (let i = e.length - 1; 0 < i; i--) { const n = e.item(i).name; "xmlns:ns1" !== n && 0 !== n.indexOf("ns1:") || t.removeAttribute(n) } let n = t.firstChild; for (; n;)n.nodeType === Node.ELEMENT_NODE && this.stripCustomNsAttrs(n), n = n.nextSibling } } const Jt = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi, te = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i; function ee(t) { return (t = String(t)).match(Jt) || t.match(te) ? t : (Yt() && console.warn(`WARNING: sanitizing unsafe URL value ${t} (see http://g.co/ng/security#xss)`), "unsafe:" + t) } function ne(t) { const e = {}; for (const n of t.split(",")) e[n] = !0; return e } function ie(...t) { const e = {}; for (const n of t) for (const t in n) n.hasOwnProperty(t) && (e[t] = !0); return e } const re = ne("area,br,col,hr,img,wbr"), se = ne("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"), oe = ne("rp,rt"), le = ie(oe, se), ae = ie(re, ie(se, ne("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul")), ie(oe, ne("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video")), le), ce = ne("background,cite,href,itemtype,longdesc,poster,src,xlink:href"), ue = ne("srcset"), he = ie(ce, ue, ne("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width"), ne("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext")), de = ne("script,style,template"); class pe { constructor() { this.sanitizedSomething = !1, this.buf = [] } sanitizeChildren(t) { let e = t.firstChild, n = !0; for (; e;)if (e.nodeType === Node.ELEMENT_NODE ? n = this.startElement(e) : e.nodeType === Node.TEXT_NODE ? this.chars(e.nodeValue) : this.sanitizedSomething = !0, n && e.firstChild) e = e.firstChild; else for (; e;) { e.nodeType === Node.ELEMENT_NODE && this.endElement(e); let t = this.checkClobberedElement(e, e.nextSibling); if (t) { e = t; break } e = this.checkClobberedElement(e, e.parentNode) } return this.buf.join("") } startElement(t) { const e = t.nodeName.toLowerCase(); if (!ae.hasOwnProperty(e)) return this.sanitizedSomething = !0, !de.hasOwnProperty(e); this.buf.push("<"), this.buf.push(e); const n = t.attributes; for (let r = 0; r < n.length; r++) { const t = n.item(r), e = t.name, s = e.toLowerCase(); if (!he.hasOwnProperty(s)) { this.sanitizedSomething = !0; continue } let o = t.value; ce[s] && (o = ee(o)), ue[s] && (i = o, o = (i = String(i)).split(",").map(t => ee(t.trim())).join(", ")), this.buf.push(" ", e, '="', ge(o), '"') } var i; return this.buf.push(">"), !0 } endElement(t) { const e = t.nodeName.toLowerCase(); ae.hasOwnProperty(e) && !re.hasOwnProperty(e) && (this.buf.push("</"), this.buf.push(e), this.buf.push(">")) } chars(t) { this.buf.push(ge(t)) } checkClobberedElement(t, e) { if (e && (t.compareDocumentPosition(e) & Node.DOCUMENT_POSITION_CONTAINED_BY) === Node.DOCUMENT_POSITION_CONTAINED_BY) throw new Error("Failed to sanitize html because the element is clobbered: " + t.outerHTML); return e } } const fe = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, me = /([^\#-~ |!])/g; function ge(t) { return t.replace(/&/g, "&amp;").replace(fe, (function (t) { return "&#" + (1024 * (t.charCodeAt(0) - 55296) + (t.charCodeAt(1) - 56320) + 65536) + ";" })).replace(me, (function (t) { return "&#" + t.charCodeAt(0) + ";" })).replace(/</g, "&lt;").replace(/>/g, "&gt;") } let _e; function ye(t) { return "content" in t && function (t) { return t.nodeType === Node.ELEMENT_NODE && "TEMPLATE" === t.nodeName }(t) ? t.content : null } const ve = function () { var t = { NONE: 0, HTML: 1, STYLE: 2, SCRIPT: 3, URL: 4, RESOURCE_URL: 5 }; return t[t.NONE] = "NONE", t[t.HTML] = "HTML", t[t.STYLE] = "STYLE", t[t.SCRIPT] = "SCRIPT", t[t.URL] = "URL", t[t.RESOURCE_URL] = "RESOURCE_URL", t }(); class be { } const we = new RegExp("^([-,.\"'%_!# a-zA-Z0-9]+|(?:(?:matrix|translate|scale|rotate|skew|perspective)(?:X|Y|3d)?|(?:rgb|hsl)a?|(?:repeating-)?(?:linear|radial)-gradient|(?:calc|attr))\\([-0-9.%, #a-zA-Z]+\\))$", "g"), Ce = /^url\(([^)]+)\)$/; function Se(t) { return t.ngDebugContext } function Ee(t) { return t.ngOriginalError } function xe(t, ...e) { t.error(...e) } class Te { constructor() { this._console = console } handleError(t) { const e = this._findOriginalError(t), n = this._findContext(t), i = function (t) { return t.ngErrorLogger || xe }(t); i(this._console, "ERROR", t), e && i(this._console, "ORIGINAL ERROR", e), n && i(this._console, "ERROR CONTEXT", n) } _findContext(t) { return t ? Se(t) ? Se(t) : this._findContext(Ee(t)) : null } _findOriginalError(t) { let e = Ee(t); for (; e && Ee(e);)e = Ee(e); return e } } const ke = /([A-Z])/g; function Pe(t) { try { return null != t ? t.toString().slice(0, 30) : t } catch (e) { return "[ERROR] Exception while trying to serialize the value" } } let Oe = null; function Ie() { if (!Oe) { const t = xt.Symbol; if (t && t.iterator) Oe = t.iterator; else { const t = Object.getOwnPropertyNames(Map.prototype); for (let e = 0; e < t.length; ++e) { const n = t[e]; "entries" !== n && "size" !== n && Map.prototype[n] === Map.prototype.entries && (Oe = n) } } } return Oe } function Ae(t, e) { return t === e || "number" == typeof t && "number" == typeof e && isNaN(t) && isNaN(e) } function Re(t, e) { const n = Me(t), i = Me(e); if (n && i) return function (t, e, n) { const i = t[Ie()](), r = e[Ie()](); for (; ;) { const t = i.next(), e = r.next(); if (t.done && e.done) return !0; if (t.done || e.done) return !1; if (!n(t.value, e.value)) return !1 } }(t, e, Re); { const r = t && ("object" == typeof t || "function" == typeof t), s = e && ("object" == typeof e || "function" == typeof e); return !(n || !r || i || !s) || Ae(t, e) } } class Ne { constructor(t) { this.wrapped = t } static wrap(t) { return new Ne(t) } static unwrap(t) { return Ne.isWrapped(t) ? t.wrapped : t } static isWrapped(t) { return t instanceof Ne } } function Me(t) { return !!De(t) && (Array.isArray(t) || !(t instanceof Map) && Ie() in t) } function De(t) { return null !== t && ("function" == typeof t || "object" == typeof t) } function Fe(t) { return !!t && "function" == typeof t.then } function Le(t) { return !!t && "function" == typeof t.subscribe } class Ve { constructor(t, e, n) { this.previousValue = t, this.currentValue = e, this.firstChange = n } isFirstChange() { return this.firstChange } } class ze { } function je(t) { const e = Error(`No component factory found for ${_t(t)}. Did you add it to @NgModule.entryComponents?`); return e[Ue] = t, e } const Ue = "ngComponent"; class He { resolveComponentFactory(t) { throw je(t) } } let Be = (() => { class t { } return t.NULL = new He, t })(); class $e { constructor(t, e, n) { this._parent = e, this._ngModule = n, this._factories = new Map; for (let i = 0; i < t.length; i++) { const e = t[i]; this._factories.set(e.componentType, e) } } resolveComponentFactory(t) { let e = this._factories.get(t); if (!e && this._parent && (e = this._parent.resolveComponentFactory(t)), !e) throw je(t); return new We(e, this._ngModule) } } class We extends ze { constructor(t, e) { super(), this.factory = t, this.ngModule = e, this.selector = t.selector, this.componentType = t.componentType, this.ngContentSelectors = t.ngContentSelectors, this.inputs = t.inputs, this.outputs = t.outputs } create(t, e, n, i) { return this.factory.create(t, e, n, i || this.ngModule) } } class qe { } class Ge { } function Ze(...t) { } let Qe = (() => { class t { constructor(t) { this.nativeElement = t } } return t.__NG_ELEMENT_ID__ = () => Ke(t), t })(); const Ke = Ze; class Ye { } class Xe { } const Je = function () { var t = { Important: 1, DashCase: 2 }; return t[t.Important] = "Important", t[t.DashCase] = "DashCase", t }(); let tn = (() => { class t { } return t.__NG_ELEMENT_ID__ = () => en(), t })(); const en = Ze; class nn { constructor(t) { this.full = t, this.major = t.split(".")[0], this.minor = t.split(".")[1], this.patch = t.split(".").slice(2).join(".") } } const rn = new nn("8.1.3"); class sn { constructor() { } supports(t) { return Me(t) } create(t) { return new ln(t) } } const on = (t, e) => e; class ln { constructor(t) { this.length = 0, this._linkedRecords = null, this._unlinkedRecords = null, this._previousItHead = null, this._itHead = null, this._itTail = null, this._additionsHead = null, this._additionsTail = null, this._movesHead = null, this._movesTail = null, this._removalsHead = null, this._removalsTail = null, this._identityChangesHead = null, this._identityChangesTail = null, this._trackByFn = t || on } forEachItem(t) { let e; for (e = this._itHead; null !== e; e = e._next)t(e) } forEachOperation(t) { let e = this._itHead, n = this._removalsHead, i = 0, r = null; for (; e || n;) { const s = !n || e && e.currentIndex < hn(n, i, r) ? e : n, o = hn(s, i, r), l = s.currentIndex; if (s === n) i--, n = n._nextRemoved; else if (e = e._next, null == s.previousIndex) i++; else { r || (r = []); const t = o - i, e = l - i; if (t != e) { for (let n = 0; n < t; n++) { const i = n < r.length ? r[n] : r[n] = 0, s = i + n; e <= s && s < t && (r[n] = i + 1) } r[s.previousIndex] = e - t } } o !== l && t(s, o, l) } } forEachPreviousItem(t) { let e; for (e = this._previousItHead; null !== e; e = e._nextPrevious)t(e) } forEachAddedItem(t) { let e; for (e = this._additionsHead; null !== e; e = e._nextAdded)t(e) } forEachMovedItem(t) { let e; for (e = this._movesHead; null !== e; e = e._nextMoved)t(e) } forEachRemovedItem(t) { let e; for (e = this._removalsHead; null !== e; e = e._nextRemoved)t(e) } forEachIdentityChange(t) { let e; for (e = this._identityChangesHead; null !== e; e = e._nextIdentityChange)t(e) } diff(t) { if (null == t && (t = []), !Me(t)) throw new Error(`Error trying to diff '${_t(t)}'. Only arrays and iterables are allowed`); return this.check(t) ? this : null } onDestroy() { } check(t) { this._reset(); let e, n, i, r = this._itHead, s = !1; if (Array.isArray(t)) { this.length = t.length; for (let e = 0; e < this.length; e++)n = t[e], i = this._trackByFn(e, n), null !== r && Ae(r.trackById, i) ? (s && (r = this._verifyReinsertion(r, n, i, e)), Ae(r.item, n) || this._addIdentityChange(r, n)) : (r = this._mismatch(r, n, i, e), s = !0), r = r._next } else e = 0, function (t, e) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++)e(t[n]); else { const n = t[Ie()](); let i; for (; !(i = n.next()).done;)e(i.value) } }(t, t => { i = this._trackByFn(e, t), null !== r && Ae(r.trackById, i) ? (s && (r = this._verifyReinsertion(r, t, i, e)), Ae(r.item, t) || this._addIdentityChange(r, t)) : (r = this._mismatch(r, t, i, e), s = !0), r = r._next, e++ }), this.length = e; return this._truncate(r), this.collection = t, this.isDirty } get isDirty() { return null !== this._additionsHead || null !== this._movesHead || null !== this._removalsHead || null !== this._identityChangesHead } _reset() { if (this.isDirty) { let t, e; for (t = this._previousItHead = this._itHead; null !== t; t = t._next)t._nextPrevious = t._next; for (t = this._additionsHead; null !== t; t = t._nextAdded)t.previousIndex = t.currentIndex; for (this._additionsHead = this._additionsTail = null, t = this._movesHead; null !== t; t = e)t.previousIndex = t.currentIndex, e = t._nextMoved; this._movesHead = this._movesTail = null, this._removalsHead = this._removalsTail = null, this._identityChangesHead = this._identityChangesTail = null } } _mismatch(t, e, n, i) { let r; return null === t ? r = this._itTail : (r = t._prev, this._remove(t)), null !== (t = null === this._linkedRecords ? null : this._linkedRecords.get(n, i)) ? (Ae(t.item, e) || this._addIdentityChange(t, e), this._moveAfter(t, r, i)) : null !== (t = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(n, null)) ? (Ae(t.item, e) || this._addIdentityChange(t, e), this._reinsertAfter(t, r, i)) : t = this._addAfter(new an(e, n), r, i), t } _verifyReinsertion(t, e, n, i) { let r = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(n, null); return null !== r ? t = this._reinsertAfter(r, t._prev, i) : t.currentIndex != i && (t.currentIndex = i, this._addToMoves(t, i)), t } _truncate(t) { for (; null !== t;) { const e = t._next; this._addToRemovals(this._unlink(t)), t = e } null !== this._unlinkedRecords && this._unlinkedRecords.clear(), null !== this._additionsTail && (this._additionsTail._nextAdded = null), null !== this._movesTail && (this._movesTail._nextMoved = null), null !== this._itTail && (this._itTail._next = null), null !== this._removalsTail && (this._removalsTail._nextRemoved = null), null !== this._identityChangesTail && (this._identityChangesTail._nextIdentityChange = null) } _reinsertAfter(t, e, n) { null !== this._unlinkedRecords && this._unlinkedRecords.remove(t); const i = t._prevRemoved, r = t._nextRemoved; return null === i ? this._removalsHead = r : i._nextRemoved = r, null === r ? this._removalsTail = i : r._prevRemoved = i, this._insertAfter(t, e, n), this._addToMoves(t, n), t } _moveAfter(t, e, n) { return this._unlink(t), this._insertAfter(t, e, n), this._addToMoves(t, n), t } _addAfter(t, e, n) { return this._insertAfter(t, e, n), this._additionsTail = null === this._additionsTail ? this._additionsHead = t : this._additionsTail._nextAdded = t, t } _insertAfter(t, e, n) { const i = null === e ? this._itHead : e._next; return t._next = i, t._prev = e, null === i ? this._itTail = t : i._prev = t, null === e ? this._itHead = t : e._next = t, null === this._linkedRecords && (this._linkedRecords = new un), this._linkedRecords.put(t), t.currentIndex = n, t } _remove(t) { return this._addToRemovals(this._unlink(t)) } _unlink(t) { null !== this._linkedRecords && this._linkedRecords.remove(t); const e = t._prev, n = t._next; return null === e ? this._itHead = n : e._next = n, null === n ? this._itTail = e : n._prev = e, t } _addToMoves(t, e) { return t.previousIndex === e || (this._movesTail = null === this._movesTail ? this._movesHead = t : this._movesTail._nextMoved = t), t } _addToRemovals(t) { return null === this._unlinkedRecords && (this._unlinkedRecords = new un), this._unlinkedRecords.put(t), t.currentIndex = null, t._nextRemoved = null, null === this._removalsTail ? (this._removalsTail = this._removalsHead = t, t._prevRemoved = null) : (t._prevRemoved = this._removalsTail, this._removalsTail = this._removalsTail._nextRemoved = t), t } _addIdentityChange(t, e) { return t.item = e, this._identityChangesTail = null === this._identityChangesTail ? this._identityChangesHead = t : this._identityChangesTail._nextIdentityChange = t, t } } class an { constructor(t, e) { this.item = t, this.trackById = e, this.currentIndex = null, this.previousIndex = null, this._nextPrevious = null, this._prev = null, this._next = null, this._prevDup = null, this._nextDup = null, this._prevRemoved = null, this._nextRemoved = null, this._nextAdded = null, this._nextMoved = null, this._nextIdentityChange = null } } class cn { constructor() { this._head = null, this._tail = null } add(t) { null === this._head ? (this._head = this._tail = t, t._nextDup = null, t._prevDup = null) : (this._tail._nextDup = t, t._prevDup = this._tail, t._nextDup = null, this._tail = t) } get(t, e) { let n; for (n = this._head; null !== n; n = n._nextDup)if ((null === e || e <= n.currentIndex) && Ae(n.trackById, t)) return n; return null } remove(t) { const e = t._prevDup, n = t._nextDup; return null === e ? this._head = n : e._nextDup = n, null === n ? this._tail = e : n._prevDup = e, null === this._head } } class un { constructor() { this.map = new Map } put(t) { const e = t.trackById; let n = this.map.get(e); n || (n = new cn, this.map.set(e, n)), n.add(t) } get(t, e) { const n = this.map.get(t); return n ? n.get(t, e) : null } remove(t) { const e = t.trackById; return this.map.get(e).remove(t) && this.map.delete(e), t } get isEmpty() { return 0 === this.map.size } clear() { this.map.clear() } } function hn(t, e, n) { const i = t.previousIndex; if (null === i) return i; let r = 0; return n && i < n.length && (r = n[i]), i + e + r } class dn { constructor() { } supports(t) { return t instanceof Map || De(t) } create() { return new pn } } class pn { constructor() { this._records = new Map, this._mapHead = null, this._appendAfter = null, this._previousMapHead = null, this._changesHead = null, this._changesTail = null, this._additionsHead = null, this._additionsTail = null, this._removalsHead = null, this._removalsTail = null } get isDirty() { return null !== this._additionsHead || null !== this._changesHead || null !== this._removalsHead } forEachItem(t) { let e; for (e = this._mapHead; null !== e; e = e._next)t(e) } forEachPreviousItem(t) { let e; for (e = this._previousMapHead; null !== e; e = e._nextPrevious)t(e) } forEachChangedItem(t) { let e; for (e = this._changesHead; null !== e; e = e._nextChanged)t(e) } forEachAddedItem(t) { let e; for (e = this._additionsHead; null !== e; e = e._nextAdded)t(e) } forEachRemovedItem(t) { let e; for (e = this._removalsHead; null !== e; e = e._nextRemoved)t(e) } diff(t) { if (t) { if (!(t instanceof Map || De(t))) throw new Error(`Error trying to diff '${_t(t)}'. Only maps and objects are allowed`) } else t = new Map; return this.check(t) ? this : null } onDestroy() { } check(t) { this._reset(); let e = this._mapHead; if (this._appendAfter = null, this._forEach(t, (t, n) => { if (e && e.key === n) this._maybeAddToChanges(e, t), this._appendAfter = e, e = e._next; else { const i = this._getOrCreateRecordForKey(n, t); e = this._insertBeforeOrAppend(e, i) } }), e) { e._prev && (e._prev._next = null), this._removalsHead = e; for (let t = e; null !== t; t = t._nextRemoved)t === this._mapHead && (this._mapHead = null), this._records.delete(t.key), t._nextRemoved = t._next, t.previousValue = t.currentValue, t.currentValue = null, t._prev = null, t._next = null } return this._changesTail && (this._changesTail._nextChanged = null), this._additionsTail && (this._additionsTail._nextAdded = null), this.isDirty } _insertBeforeOrAppend(t, e) { if (t) { const n = t._prev; return e._next = t, e._prev = n, t._prev = e, n && (n._next = e), t === this._mapHead && (this._mapHead = e), this._appendAfter = t, t } return this._appendAfter ? (this._appendAfter._next = e, e._prev = this._appendAfter) : this._mapHead = e, this._appendAfter = e, null } _getOrCreateRecordForKey(t, e) { if (this._records.has(t)) { const n = this._records.get(t); this._maybeAddToChanges(n, e); const i = n._prev, r = n._next; return i && (i._next = r), r && (r._prev = i), n._next = null, n._prev = null, n } const n = new fn(t); return this._records.set(t, n), n.currentValue = e, this._addToAdditions(n), n } _reset() { if (this.isDirty) { let t; for (this._previousMapHead = this._mapHead, t = this._previousMapHead; null !== t; t = t._next)t._nextPrevious = t._next; for (t = this._changesHead; null !== t; t = t._nextChanged)t.previousValue = t.currentValue; for (t = this._additionsHead; null != t; t = t._nextAdded)t.previousValue = t.currentValue; this._changesHead = this._changesTail = null, this._additionsHead = this._additionsTail = null, this._removalsHead = null } } _maybeAddToChanges(t, e) { Ae(e, t.currentValue) || (t.previousValue = t.currentValue, t.currentValue = e, this._addToChanges(t)) } _addToAdditions(t) { null === this._additionsHead ? this._additionsHead = this._additionsTail = t : (this._additionsTail._nextAdded = t, this._additionsTail = t) } _addToChanges(t) { null === this._changesHead ? this._changesHead = this._changesTail = t : (this._changesTail._nextChanged = t, this._changesTail = t) } _forEach(t, e) { t instanceof Map ? t.forEach(e) : Object.keys(t).forEach(n => e(t[n], n)) } } class fn { constructor(t) { this.key = t, this.previousValue = null, this.currentValue = null, this._nextPrevious = null, this._next = null, this._prev = null, this._nextAdded = null, this._nextRemoved = null, this._nextChanged = null } } let mn = (() => { class t { constructor(t) { this.factories = t } static create(e, n) { if (null != n) { const t = n.factories.slice(); e = e.concat(t) } return new t(e) } static extend(e) { return { provide: t, useFactory: n => { if (!n) throw new Error("Cannot extend IterableDiffers without a parent injector"); return t.create(e, n) }, deps: [[t, new ht, new ct]] } } find(t) { const e = this.factories.find(e => e.supports(t)); if (null != e) return e; throw new Error(`Cannot find a differ supporting object '${t}' of type '${n = t, n.name || typeof n}'`); var n } } return t.ngInjectableDef = ft({ token: t, providedIn: "root", factory: () => new t([new sn]) }), t })(), gn = (() => { class t { constructor(t) { this.factories = t } static create(e, n) { if (n) { const t = n.factories.slice(); e = e.concat(t) } return new t(e) } static extend(e) { return { provide: t, useFactory: n => { if (!n) throw new Error("Cannot extend KeyValueDiffers without a parent injector"); return t.create(e, n) }, deps: [[t, new ht, new ct]] } } find(t) { const e = this.factories.find(e => e.supports(t)); if (e) return e; throw new Error(`Cannot find a differ supporting object '${t}'`) } } return t.ngInjectableDef = ft({ token: t, providedIn: "root", factory: () => new t([new dn]) }), t })(), _n = (() => { class t { } return t.__NG_ELEMENT_ID__ = () => yn(), t })(); const yn = (...t) => { }, vn = [new dn], bn = new mn([new sn]), wn = new gn(vn); let Cn = (() => { class t { } return t.__NG_ELEMENT_ID__ = () => Sn(t, Qe), t })(); const Sn = Ze; let En = (() => { class t { } return t.__NG_ELEMENT_ID__ = () => xn(t, Qe), t })(); const xn = Ze; function Tn(t, e, n, i) { let r = `ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value: '${e}'. Current value: '${n}'.`; return i && (r += " It seems like the view has been created after its parent and its children have been dirty checked. Has it been created in a change detection hook ?"), function (t, e) { const n = new Error(t); return kn(n, e), n }(r, t) } function kn(t, e) { t.ngDebugContext = e, t.ngErrorLogger = e.logError.bind(e) } function Pn(t) { return new Error("ViewDestroyedError: Attempt to use a destroyed view: " + t) } function On(t, e, n) { const i = t.state, r = 1792 & i; return r === e ? (t.state = -1793 & i | n, t.initIndex = -1, !0) : r === n } function In(t, e, n) { return (1792 & t.state) === e && t.initIndex <= n && (t.initIndex = n + 1, !0) } function An(t, e) { return t.nodes[e] } function Rn(t, e) { return t.nodes[e] } function Nn(t, e) { return t.nodes[e] } function Mn(t, e) { return t.nodes[e] } function Dn(t, e) { return t.nodes[e] } const Fn = { setCurrentNode: void 0, createRootView: void 0, createEmbeddedView: void 0, createComponentView: void 0, createNgModuleRef: void 0, overrideProvider: void 0, overrideComponentView: void 0, clearOverrides: void 0, checkAndUpdateView: void 0, checkNoChangesView: void 0, destroyView: void 0, resolveDep: void 0, createDebugContext: void 0, handleEvent: void 0, updateDirectives: void 0, updateRenderer: void 0, dirtyParentQueries: void 0 }, Ln = () => { }, Vn = new Map; function zn(t) { let e = Vn.get(t); return e || (e = _t(t) + "_" + Vn.size, Vn.set(t, e)), e } function jn(t) { return { id: "$$undefined", styles: t.styles, encapsulation: t.encapsulation, data: t.data } } let Un = 0; function Hn(t, e, n, i) { return !(!(2 & t.state) && Ae(t.oldValues[e.bindingIndex + n], i)) } function Bn(t, e, n, i) { return !!Hn(t, e, n, i) && (t.oldValues[e.bindingIndex + n] = i, !0) } function $n(t, e, n, i) { const r = t.oldValues[e.bindingIndex + n]; if (1 & t.state || !Re(r, i)) { const s = e.bindings[n].name; throw Tn(Fn.createDebugContext(t, e.nodeIndex), `${s}: ${r}`, `${s}: ${i}`, 0 != (1 & t.state)) } } function Wn(t) { let e = t; for (; e;)2 & e.def.flags && (e.state |= 8), e = e.viewContainerParent || e.parent } function qn(t, e) { let n = t; for (; n && n !== e;)n.state |= 64, n = n.viewContainerParent || n.parent } function Gn(t, e, n, i) { try { return Wn(33554432 & t.def.nodes[e].flags ? Rn(t, e).componentView : t), Fn.handleEvent(t, e, n, i) } catch (r) { t.root.errorHandler.handleError(r) } } function Zn(t) { return t.parent ? Rn(t.parent, t.parentNodeDef.nodeIndex) : null } function Qn(t) { return t.parent ? t.parentNodeDef.parent : null } function Kn(t, e) { switch (201347067 & e.flags) { case 1: return Rn(t, e.nodeIndex).renderElement; case 2: return An(t, e.nodeIndex).renderText } } function Yn(t) { return !!t.parent && !!(32768 & t.parentNodeDef.flags) } function Xn(t) { return !(!t.parent || 32768 & t.parentNodeDef.flags) } function Jn(t) { return 1 << t % 32 } function ti(t) { const e = {}; let n = 0; const i = {}; return t && t.forEach(([t, r]) => { "number" == typeof t ? (e[t] = r, n |= Jn(t)) : i[t] = r }), { matchedQueries: e, references: i, matchedQueryIds: n } } function ei(t, e) { return t.map(t => { let n, i; return Array.isArray(t) ? [i, n] = t : (i = 0, n = t), n && ("function" == typeof n || "object" == typeof n) && e && Object.defineProperty(n, "__source", { value: e, configurable: !0 }), { flags: i, token: n, tokenKey: zn(n) } }) } function ni(t, e, n) { let i = n.renderParent; return i ? 0 == (1 & i.flags) || 0 == (33554432 & i.flags) || i.element.componentRendererType && i.element.componentRendererType.encapsulation === Zt.Native ? Rn(t, n.renderParent.nodeIndex).renderElement : void 0 : e } const ii = new WeakMap; function ri(t) { let e = ii.get(t); return e || (e = t(() => Ln), e.factory = t, ii.set(t, e)), e } function si(t, e, n, i, r) { 3 === e && (n = t.renderer.parentNode(Kn(t, t.def.lastRenderRootNode))), oi(t, e, 0, t.def.nodes.length - 1, n, i, r) } function oi(t, e, n, i, r, s, o) { for (let l = n; l <= i; l++) { const n = t.def.nodes[l]; 11 & n.flags && ai(t, n, e, r, s, o), l += n.childCount } } function li(t, e, n, i, r, s) { let o = t; for (; o && !Yn(o);)o = o.parent; const l = o.parent, a = Qn(o), c = a.nodeIndex + a.childCount; for (let u = a.nodeIndex + 1; u <= c; u++) { const t = l.def.nodes[u]; t.ngContentIndex === e && ai(l, t, n, i, r, s), u += t.childCount } if (!l.parent) { const o = t.root.projectableNodes[e]; if (o) for (let e = 0; e < o.length; e++)ci(t, o[e], n, i, r, s) } } function ai(t, e, n, i, r, s) { if (8 & e.flags) li(t, e.ngContent.index, n, i, r, s); else { const o = Kn(t, e); if (3 === n && 33554432 & e.flags && 48 & e.bindingFlags ? (16 & e.bindingFlags && ci(t, o, n, i, r, s), 32 & e.bindingFlags && ci(Rn(t, e.nodeIndex).componentView, o, n, i, r, s)) : ci(t, o, n, i, r, s), 16777216 & e.flags) { const o = Rn(t, e.nodeIndex).viewContainer._embeddedViews; for (let t = 0; t < o.length; t++)si(o[t], n, i, r, s) } 1 & e.flags && !e.element.name && oi(t, n, e.nodeIndex + 1, e.nodeIndex + e.childCount, i, r, s) } } function ci(t, e, n, i, r, s) { const o = t.renderer; switch (n) { case 1: o.appendChild(i, e); break; case 2: o.insertBefore(i, e, r); break; case 3: o.removeChild(i, e); break; case 0: s.push(e) } } const ui = /^:([^:]+):(.+)$/; function hi(t) { if (":" === t[0]) { const e = t.match(ui); return [e[1], e[2]] } return ["", t] } function di(t) { let e = 0; for (let n = 0; n < t.length; n++)e |= t[n].flags; return e } const pi = new Object, fi = zn(zt), mi = zn(kt), gi = zn(qe); function _i(t, e, n, i) { return n = bt(n), { index: -1, deps: ei(i, _t(e)), flags: t, token: e, value: n } } function yi(t, e, n = zt.THROW_IF_NOT_FOUND) { const i = Rt(t); try { if (8 & e.flags) return e.token; if (2 & e.flags && (n = null), 1 & e.flags) return t._parent.get(e.token, n); const o = e.tokenKey; switch (o) { case fi: case mi: case gi: return t }const l = t._def.providersByKey[o]; let a; if (l) { let e = t._providers[l.index]; return void 0 === e && (e = t._providers[l.index] = vi(t, l)), e === pi ? void 0 : e } if ((a = mt(e.token)) && (r = t, null != (s = a).providedIn && (function (t, e) { return t._def.modules.indexOf(e) > -1 }(r, s.providedIn) || "root" === s.providedIn && r._def.isRoot))) { const n = t._providers.length; return t._def.providers[n] = t._def.providersByKey[e.tokenKey] = { flags: 5120, value: a.factory, deps: [], index: n, token: e.token }, t._providers[n] = pi, t._providers[n] = vi(t, t._def.providersByKey[e.tokenKey]) } return 4 & e.flags ? n : t._parent.get(e.token, n) } finally { Rt(i) } var r, s } function vi(t, e) { let n; switch (201347067 & e.flags) { case 512: n = function (t, e, n) { const i = n.length; switch (i) { case 0: return new e; case 1: return new e(yi(t, n[0])); case 2: return new e(yi(t, n[0]), yi(t, n[1])); case 3: return new e(yi(t, n[0]), yi(t, n[1]), yi(t, n[2])); default: const r = new Array(i); for (let e = 0; e < i; e++)r[e] = yi(t, n[e]); return new e(...r) } }(t, e.value, e.deps); break; case 1024: n = function (t, e, n) { const i = n.length; switch (i) { case 0: return e(); case 1: return e(yi(t, n[0])); case 2: return e(yi(t, n[0]), yi(t, n[1])); case 3: return e(yi(t, n[0]), yi(t, n[1]), yi(t, n[2])); default: const r = Array(i); for (let e = 0; e < i; e++)r[e] = yi(t, n[e]); return e(...r) } }(t, e.value, e.deps); break; case 2048: n = yi(t, e.deps[0]); break; case 256: n = e.value }return n === pi || null === n || "object" != typeof n || 131072 & e.flags || "function" != typeof n.ngOnDestroy || (e.flags |= 131072), void 0 === n ? pi : n } function bi(t, e) { const n = t.viewContainer._embeddedViews; if ((null == e || e >= n.length) && (e = n.length - 1), e < 0) return null; const i = n[e]; return i.viewContainerParent = null, Ei(n, e), Fn.dirtyParentQueries(i), Ci(i), i } function wi(t, e, n) { const i = e ? Kn(e, e.def.lastRenderRootNode) : t.renderElement, r = n.renderer.parentNode(i), s = n.renderer.nextSibling(i); si(n, 2, r, s, void 0) } function Ci(t) { si(t, 3, null, null, void 0) } function Si(t, e, n) { e >= t.length ? t.push(n) : t.splice(e, 0, n) } function Ei(t, e) { e >= t.length - 1 ? t.pop() : t.splice(e, 1) } const xi = new Object; function Ti(t, e, n, i, r, s) { return new ki(t, e, n, i, r, s) } class ki extends ze { constructor(t, e, n, i, r, s) { super(), this.selector = t, this.componentType = e, this._inputs = i, this._outputs = r, this.ngContentSelectors = s, this.viewDefFactory = n } get inputs() { const t = [], e = this._inputs; for (let n in e) t.push({ propName: n, templateName: e[n] }); return t } get outputs() { const t = []; for (let e in this._outputs) t.push({ propName: e, templateName: this._outputs[e] }); return t } create(t, e, n, i) { if (!i) throw new Error("ngModule should be provided"); const r = ri(this.viewDefFactory), s = r.nodes[0].element.componentProvider.nodeIndex, o = Fn.createRootView(t, e || [], n, r, i, xi), l = Nn(o, s).instance; return n && o.renderer.setAttribute(Rn(o, 0).renderElement, "ng-version", rn.full), new Pi(o, new Ri(o), l) } } class Pi extends class { }{ constructor(t, e, n) { super(), this._view = t, this._viewRef = e, this._component = n, this._elDef = this._view.def.nodes[0], this.hostView = e, this.changeDetectorRef = e, this.instance = n } get location() { return new Qe(Rn(this._view, this._elDef.nodeIndex).renderElement) } get injector() { return new Fi(this._view, this._elDef) } get componentType() { return this._component.constructor } destroy() { this._viewRef.destroy() } onDestroy(t) { this._viewRef.onDestroy(t) } } function Oi(t, e, n) { return new Ii(t, e, n) } class Ii { constructor(t, e, n) { this._view = t, this._elDef = e, this._data = n, this._embeddedViews = [] } get element() { return new Qe(this._data.renderElement) } get injector() { return new Fi(this._view, this._elDef) } get parentInjector() { let t = this._view, e = this._elDef.parent; for (; !e && t;)e = Qn(t), t = t.parent; return t ? new Fi(t, e) : new Fi(this._view, null) } clear() { for (let t = this._embeddedViews.length - 1; t >= 0; t--) { const e = bi(this._data, t); Fn.destroyView(e) } } get(t) { const e = this._embeddedViews[t]; if (e) { const t = new Ri(e); return t.attachToViewContainerRef(this), t } return null } get length() { return this._embeddedViews.length } createEmbeddedView(t, e, n) { const i = t.createEmbeddedView(e || {}); return this.insert(i, n), i } createComponent(t, e, n, i, r) { const s = n || this.parentInjector; r || t instanceof We || (r = s.get(qe)); const o = t.create(s, i, void 0, r); return this.insert(o.hostView, e), o } insert(t, e) { if (t.destroyed) throw new Error("Cannot insert a destroyed View in a ViewContainer!"); const n = t; return function (t, e, n, i) { let r = e.viewContainer._embeddedViews; null == n && (n = r.length), i.viewContainerParent = t, Si(r, n, i), function (t, e) { const n = Zn(e); if (!n || n === t || 16 & e.state) return; e.state |= 16; let i = n.template._projectedViews; i || (i = n.template._projectedViews = []), i.push(e), function (t, e) { if (4 & e.flags) return; t.nodeFlags |= 4, e.flags |= 4; let n = e.parent; for (; n;)n.childFlags |= 4, n = n.parent }(e.parent.def, e.parentNodeDef) }(e, i), Fn.dirtyParentQueries(i), wi(e, n > 0 ? r[n - 1] : null, i) }(this._view, this._data, e, n._view), n.attachToViewContainerRef(this), t } move(t, e) { if (t.destroyed) throw new Error("Cannot move a destroyed View in a ViewContainer!"); const n = this._embeddedViews.indexOf(t._view); return function (t, e, n) { const i = t.viewContainer._embeddedViews, r = i[e]; Ei(i, e), null == n && (n = i.length), Si(i, n, r), Fn.dirtyParentQueries(r), Ci(r), wi(t, n > 0 ? i[n - 1] : null, r) }(this._data, n, e), t } indexOf(t) { return this._embeddedViews.indexOf(t._view) } remove(t) { const e = bi(this._data, t); e && Fn.destroyView(e) } detach(t) { const e = bi(this._data, t); return e ? new Ri(e) : null } } function Ai(t) { return new Ri(t) } class Ri { constructor(t) { this._view = t, this._viewContainerRef = null, this._appRef = null } get rootNodes() { return function (t) { const e = []; return si(t, 0, void 0, void 0, e), e }(this._view) } get context() { return this._view.context } get destroyed() { return 0 != (128 & this._view.state) } markForCheck() { Wn(this._view) } detach() { this._view.state &= -5 } detectChanges() { const t = this._view.root.rendererFactory; t.begin && t.begin(); try { Fn.checkAndUpdateView(this._view) } finally { t.end && t.end() } } checkNoChanges() { Fn.checkNoChangesView(this._view) } reattach() { this._view.state |= 4 } onDestroy(t) { this._view.disposables || (this._view.disposables = []), this._view.disposables.push(t) } destroy() { this._appRef ? this._appRef.detachView(this) : this._viewContainerRef && this._viewContainerRef.detach(this._viewContainerRef.indexOf(this)), Fn.destroyView(this._view) } detachFromAppRef() { this._appRef = null, Ci(this._view), Fn.dirtyParentQueries(this._view) } attachToAppRef(t) { if (this._viewContainerRef) throw new Error("This view is already attached to a ViewContainer!"); this._appRef = t } attachToViewContainerRef(t) { if (this._appRef) throw new Error("This view is already attached directly to the ApplicationRef!"); this._viewContainerRef = t } } function Ni(t, e) { return new Mi(t, e) } class Mi extends Cn { constructor(t, e) { super(), this._parentView = t, this._def = e } createEmbeddedView(t) { return new Ri(Fn.createEmbeddedView(this._parentView, this._def, this._def.element.template, t)) } get elementRef() { return new Qe(Rn(this._parentView, this._def.nodeIndex).renderElement) } } function Di(t, e) { return new Fi(t, e) } class Fi { constructor(t, e) { this.view = t, this.elDef = e } get(t, e = zt.THROW_IF_NOT_FOUND) { return Fn.resolveDep(this.view, this.elDef, !!this.elDef && 0 != (33554432 & this.elDef.flags), { flags: 0, token: t, tokenKey: zn(t) }, e) } } function Li(t, e) { const n = t.def.nodes[e]; if (1 & n.flags) { const e = Rn(t, n.nodeIndex); return n.element.template ? e.template : e.renderElement } if (2 & n.flags) return An(t, n.nodeIndex).renderText; if (20240 & n.flags) return Nn(t, n.nodeIndex).instance; throw new Error("Illegal state: read nodeValue for node index " + e) } function Vi(t) { return new zi(t.renderer) } class zi { constructor(t) { this.delegate = t } selectRootElement(t) { return this.delegate.selectRootElement(t) } createElement(t, e) { const [n, i] = hi(e), r = this.delegate.createElement(i, n); return t && this.delegate.appendChild(t, r), r } createViewRoot(t) { return t } createTemplateAnchor(t) { const e = this.delegate.createComment(""); return t && this.delegate.appendChild(t, e), e } createText(t, e) { const n = this.delegate.createText(e); return t && this.delegate.appendChild(t, n), n } projectNodes(t, e) { for (let n = 0; n < e.length; n++)this.delegate.appendChild(t, e[n]) } attachViewAfter(t, e) { const n = this.delegate.parentNode(t), i = this.delegate.nextSibling(t); for (let r = 0; r < e.length; r++)this.delegate.insertBefore(n, e[r], i) } detachView(t) { for (let e = 0; e < t.length; e++) { const n = t[e], i = this.delegate.parentNode(n); this.delegate.removeChild(i, n) } } destroyView(t, e) { for (let n = 0; n < e.length; n++)this.delegate.destroyNode(e[n]) } listen(t, e, n) { return this.delegate.listen(t, e, n) } listenGlobal(t, e, n) { return this.delegate.listen(t, e, n) } setElementProperty(t, e, n) { this.delegate.setProperty(t, e, n) } setElementAttribute(t, e, n) { const [i, r] = hi(e); null != n ? this.delegate.setAttribute(t, r, n, i) : this.delegate.removeAttribute(t, r, i) } setBindingDebugInfo(t, e, n) { } setElementClass(t, e, n) { n ? this.delegate.addClass(t, e) : this.delegate.removeClass(t, e) } setElementStyle(t, e, n) { null != n ? this.delegate.setStyle(t, e, n) : this.delegate.removeStyle(t, e) } invokeElementMethod(t, e, n) { t[e].apply(t, n) } setText(t, e) { this.delegate.setValue(t, e) } animate() { throw new Error("Renderer.animate is no longer supported!") } } function ji(t, e, n, i) { return new Ui(t, e, n, i) } class Ui { constructor(t, e, n, i) { this._moduleType = t, this._parent = e, this._bootstrapComponents = n, this._def = i, this._destroyListeners = [], this._destroyed = !1, this.injector = this, function (t) { const e = t._def, n = t._providers = new Array(e.providers.length); for (let i = 0; i < e.providers.length; i++) { const r = e.providers[i]; 4096 & r.flags || void 0 === n[i] && (n[i] = vi(t, r)) } }(this) } get(t, e = zt.THROW_IF_NOT_FOUND, n = dt.Default) { let i = 0; return n & dt.SkipSelf ? i |= 1 : n & dt.Self && (i |= 4), yi(this, { token: t, tokenKey: zn(t), flags: i }, e) } get instance() { return this.get(this._moduleType) } get componentFactoryResolver() { return this.get(Be) } destroy() { if (this._destroyed) throw new Error(`The ng module ${_t(this.instance.constructor)} has already been destroyed.`); this._destroyed = !0, function (t, e) { const n = t._def, i = new Set; for (let r = 0; r < n.providers.length; r++)if (131072 & n.providers[r].flags) { const e = t._providers[r]; if (e && e !== pi) { const t = e.ngOnDestroy; "function" != typeof t || i.has(e) || (t.apply(e), i.add(e)) } } }(this), this._destroyListeners.forEach(t => t()) } onDestroy(t) { this._destroyListeners.push(t) } } const Hi = zn(Ye), Bi = zn(tn), $i = zn(Qe), Wi = zn(En), qi = zn(Cn), Gi = zn(_n), Zi = zn(zt), Qi = zn(kt); function Ki(t, e, n, i, r, s, o, l) { const a = []; if (o) for (let u in o) { const [t, e] = o[u]; a[t] = { flags: 8, name: u, nonMinifiedName: e, ns: null, securityContext: null, suffix: null } } const c = []; if (l) for (let u in l) c.push({ type: 1, propName: u, target: null, eventName: l[u] }); return Xi(t, e |= 16384, n, i, r, r, s, a, c) } function Yi(t, e, n, i, r) { return Xi(-1, t, e, 0, n, i, r) } function Xi(t, e, n, i, r, s, o, l, a) { const { matchedQueries: c, references: u, matchedQueryIds: h } = ti(n); a || (a = []), l || (l = []), s = bt(s); const d = ei(o, _t(r)); return { nodeIndex: -1, parent: null, renderParent: null, bindingIndex: -1, outputIndex: -1, checkIndex: t, flags: e, childFlags: 0, directChildFlags: 0, childMatchedQueries: 0, matchedQueries: c, matchedQueryIds: h, references: u, ngContentIndex: -1, childCount: i, bindings: l, bindingFlags: di(l), outputs: a, element: null, provider: { token: r, value: s, deps: d }, text: null, query: null, ngContent: null } } function Ji(t, e) { return ir(t, e) } function tr(t, e) { let n = t; for (; n.parent && !Yn(n);)n = n.parent; return rr(n.parent, Qn(n), !0, e.provider.value, e.provider.deps) } function er(t, e) { const n = rr(t, e.parent, (32768 & e.flags) > 0, e.provider.value, e.provider.deps); if (e.outputs.length) for (let i = 0; i < e.outputs.length; i++) { const r = e.outputs[i], s = n[r.propName]; if (!Le(s)) throw new Error(`@Output ${r.propName} not initialized in '${n.constructor.name}'.`); { const n = s.subscribe(nr(t, e.parent.nodeIndex, r.eventName)); t.disposables[e.outputIndex + i] = n.unsubscribe.bind(n) } } return n } function nr(t, e, n) { return i => Gn(t, e, n, i) } function ir(t, e) { const n = (8192 & e.flags) > 0, i = e.provider; switch (201347067 & e.flags) { case 512: return rr(t, e.parent, n, i.value, i.deps); case 1024: return function (t, e, n, i, r) { const s = r.length; switch (s) { case 0: return i(); case 1: return i(or(t, e, n, r[0])); case 2: return i(or(t, e, n, r[0]), or(t, e, n, r[1])); case 3: return i(or(t, e, n, r[0]), or(t, e, n, r[1]), or(t, e, n, r[2])); default: const o = Array(s); for (let i = 0; i < s; i++)o[i] = or(t, e, n, r[i]); return i(...o) } }(t, e.parent, n, i.value, i.deps); case 2048: return or(t, e.parent, n, i.deps[0]); case 256: return i.value } } function rr(t, e, n, i, r) { const s = r.length; switch (s) { case 0: return new i; case 1: return new i(or(t, e, n, r[0])); case 2: return new i(or(t, e, n, r[0]), or(t, e, n, r[1])); case 3: return new i(or(t, e, n, r[0]), or(t, e, n, r[1]), or(t, e, n, r[2])); default: const o = new Array(s); for (let i = 0; i < s; i++)o[i] = or(t, e, n, r[i]); return new i(...o) } } const sr = {}; function or(t, e, n, i, r = zt.THROW_IF_NOT_FOUND) { if (8 & i.flags) return i.token; const s = t; 2 & i.flags && (r = null); const o = i.tokenKey; o === Gi && (n = !(!e || !e.element.componentView)), e && 1 & i.flags && (n = !1, e = e.parent); let l = t; for (; l;) { if (e) switch (o) { case Hi: return Vi(lr(l, e, n)); case Bi: return lr(l, e, n).renderer; case $i: return new Qe(Rn(l, e.nodeIndex).renderElement); case Wi: return Rn(l, e.nodeIndex).viewContainer; case qi: if (e.element.template) return Rn(l, e.nodeIndex).template; break; case Gi: return Ai(lr(l, e, n)); case Zi: case Qi: return Di(l, e); default: const t = (n ? e.element.allProviders : e.element.publicProviders)[o]; if (t) { let e = Nn(l, t.nodeIndex); return e || (e = { instance: ir(l, t) }, l.nodes[t.nodeIndex] = e), e.instance } }n = Yn(l), e = Qn(l), l = l.parent, 4 & i.flags && (l = null) } const a = s.root.injector.get(i.token, sr); return a !== sr || r === sr ? a : s.root.ngModule.injector.get(i.token, r) } function lr(t, e, n) { let i; if (n) i = Rn(t, e.nodeIndex).componentView; else for (i = t; i.parent && !Yn(i);)i = i.parent; return i } function ar(t, e, n, i, r, s) { if (32768 & n.flags) { const e = Rn(t, n.parent.nodeIndex).componentView; 2 & e.def.flags && (e.state |= 8) } if (e.instance[n.bindings[i].name] = r, 524288 & n.flags) { s = s || {}; const e = Ne.unwrap(t.oldValues[n.bindingIndex + i]); s[n.bindings[i].nonMinifiedName] = new Ve(e, r, 0 != (2 & t.state)) } return t.oldValues[n.bindingIndex + i] = r, s } function cr(t, e) { if (!(t.def.nodeFlags & e)) return; const n = t.def.nodes; let i = 0; for (let r = 0; r < n.length; r++) { const s = n[r]; let o = s.parent; for (!o && s.flags & e && hr(t, r, s.flags & e, i++), 0 == (s.childFlags & e) && (r += s.childCount); o && 1 & o.flags && r === o.nodeIndex + o.childCount;)o.directChildFlags & e && (i = ur(t, o, e, i)), o = o.parent } } function ur(t, e, n, i) { for (let r = e.nodeIndex + 1; r <= e.nodeIndex + e.childCount; r++) { const e = t.def.nodes[r]; e.flags & n && hr(t, r, e.flags & n, i++), r += e.childCount } return i } function hr(t, e, n, i) { const r = Nn(t, e); if (!r) return; const s = r.instance; s && (Fn.setCurrentNode(t, e), 1048576 & n && In(t, 512, i) && s.ngAfterContentInit(), 2097152 & n && s.ngAfterContentChecked(), 4194304 & n && In(t, 768, i) && s.ngAfterViewInit(), 8388608 & n && s.ngAfterViewChecked(), 131072 & n && s.ngOnDestroy()) } const dr = new Tt("SCHEDULER_TOKEN", { providedIn: "root", factory: () => Qt }), pr = {}, fr = function () { var t = { LocaleId: 0, DayPeriodsFormat: 1, DayPeriodsStandalone: 2, DaysFormat: 3, DaysStandalone: 4, MonthsFormat: 5, MonthsStandalone: 6, Eras: 7, FirstDayOfWeek: 8, WeekendRange: 9, DateFormat: 10, TimeFormat: 11, DateTimeFormat: 12, NumberSymbols: 13, NumberFormats: 14, CurrencySymbol: 15, CurrencyName: 16, Currencies: 17, PluralCase: 18, ExtraData: 19 }; return t[t.LocaleId] = "LocaleId", t[t.DayPeriodsFormat] = "DayPeriodsFormat", t[t.DayPeriodsStandalone] = "DayPeriodsStandalone", t[t.DaysFormat] = "DaysFormat", t[t.DaysStandalone] = "DaysStandalone", t[t.MonthsFormat] = "MonthsFormat", t[t.MonthsStandalone] = "MonthsStandalone", t[t.Eras] = "Eras", t[t.FirstDayOfWeek] = "FirstDayOfWeek", t[t.WeekendRange] = "WeekendRange", t[t.DateFormat] = "DateFormat", t[t.TimeFormat] = "TimeFormat", t[t.DateTimeFormat] = "DateTimeFormat", t[t.NumberSymbols] = "NumberSymbols", t[t.NumberFormats] = "NumberFormats", t[t.CurrencySymbol] = "CurrencySymbol", t[t.CurrencyName] = "CurrencyName", t[t.Currencies] = "Currencies", t[t.PluralCase] = "PluralCase", t[t.ExtraData] = "ExtraData", t }(), mr = void 0; var gr = ["en", [["a", "p"], ["AM", "PM"], mr], [["AM", "PM"], mr, mr], [["S", "M", "T", "W", "T", "F", "S"], ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]], mr, [["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]], mr, [["B", "A"], ["BC", "AD"], ["Before Christ", "Anno Domini"]], 0, [6, 0], ["M/d/yy", "MMM d, y", "MMMM d, y", "EEEE, MMMM d, y"], ["h:mm a", "h:mm:ss a", "h:mm:ss a z", "h:mm:ss a zzzz"], ["{1}, {0}", mr, "{1} 'at' {0}", mr], [".", ",", ";", "%", "+", "-", "E", "\xd7", "\u2030", "\u221e", "NaN", ":"], ["#,##0.###", "#,##0%", "\xa4#,##0.00", "#E0"], "$", "US Dollar", {}, function (t) { let e = Math.floor(Math.abs(t)), n = t.toString().replace(/^[^.]*\.?/, "").length; return 1 === e && 0 === n ? 1 : 5 }]; function _r(t) { const e = t.toLowerCase().replace(/_/g, "-"); let n = pr[e]; if (n) return n; const i = e.split("-")[0]; if (n = pr[i], n) return n; if ("en" === i) return gr; throw new Error(`Missing locale data for the locale "${t}".`) } let yr = "en-US"; class vr extends k { constructor(t = !1) { super(), this.__isAsync = t } emit(t) { super.next(t) } subscribe(t, e, n) { let i, r = t => null, s = () => null; t && "object" == typeof t ? (i = this.__isAsync ? e => { setTimeout(() => t.next(e)) } : e => { t.next(e) }, t.error && (r = this.__isAsync ? e => { setTimeout(() => t.error(e)) } : e => { t.error(e) }), t.complete && (s = this.__isAsync ? () => { setTimeout(() => t.complete()) } : () => { t.complete() })) : (i = this.__isAsync ? e => { setTimeout(() => t(e)) } : e => { t(e) }, e && (r = this.__isAsync ? t => { setTimeout(() => e(t)) } : t => { e(t) }), n && (s = this.__isAsync ? () => { setTimeout(() => n()) } : () => { n() })); const o = super.subscribe(i, r, s); return t instanceof d && t.add(o), o } } function br() { return this._results[Ie()]() } class wr { constructor() { this.dirty = !0, this._results = [], this.changes = new vr, this.length = 0; const t = Ie(), e = wr.prototype; e[t] || (e[t] = br) } map(t) { return this._results.map(t) } filter(t) { return this._results.filter(t) } find(t) { return this._results.find(t) } reduce(t, e) { return this._results.reduce(t, e) } forEach(t) { this._results.forEach(t) } some(t) { return this._results.some(t) } toArray() { return this._results.slice() } toString() { return this._results.toString() } reset(t) { this._results = function t(e, n) { void 0 === n && (n = e); for (let i = 0; i < e.length; i++) { let r = e[i]; Array.isArray(r) ? (n === e && (n = e.slice(0, i)), t(r, n)) : n !== e && n.push(r) } return n }(t), this.dirty = !1, this.length = this._results.length, this.last = this._results[this.length - 1], this.first = this._results[0] } notifyOnChanges() { this.changes.emit(this) } setDirty() { this.dirty = !0 } destroy() { this.changes.complete(), this.changes.unsubscribe() } } const Cr = new Tt("Application Initializer"); let Sr = (() => class { constructor(t) { this.appInits = t, this.initialized = !1, this.done = !1, this.donePromise = new Promise((t, e) => { this.resolve = t, this.reject = e }) } runInitializers() { if (this.initialized) return; const t = [], e = () => { this.done = !0, this.resolve() }; if (this.appInits) for (let n = 0; n < this.appInits.length; n++) { const e = this.appInits[n](); Fe(e) && t.push(e) } Promise.all(t).then(() => { e() }).catch(t => { this.reject(t) }), 0 === t.length && e(), this.initialized = !0 } })(); const Er = new Tt("AppId"); function xr() { return `${Tr()}${Tr()}${Tr()}` } function Tr() { return String.fromCharCode(97 + Math.floor(25 * Math.random())) } const kr = new Tt("Platform Initializer"), Pr = new Tt("Platform ID"), Or = new Tt("appBootstrapListener"); let Ir = (() => class { log(t) { console.log(t) } warn(t) { console.warn(t) } })(); const Ar = new Tt("LocaleId"); function Rr() { throw new Error("Runtime compiler is not loaded") } const Nr = Rr, Mr = Rr, Dr = Rr, Fr = Rr; let Lr, Vr, zr = (() => class { constructor() { this.compileModuleSync = Nr, this.compileModuleAsync = Mr, this.compileModuleAndAllComponentsSync = Dr, this.compileModuleAndAllComponentsAsync = Fr } clearCache() { } clearCacheFor(t) { } getModuleId(t) { } })(); class jr { } function Ur() { const t = xt.wtf; return !(!t || (Lr = t.trace, !Lr) || (Vr = Lr.events, 0)) } const Hr = Ur(); function Br(t, e) { return null } const $r = Hr ? function (t, e = null) { return Vr.createScope(t, e) } : (t, e) => Br, Wr = Hr ? function (t, e) { return Lr.leaveScope(t, e), e } : (t, e) => e, qr = (() => Promise.resolve(0))(); function Gr(t) { "undefined" == typeof Zone ? qr.then(() => { t && t.apply(null, null) }) : Zone.current.scheduleMicroTask("scheduleMicrotask", t) } class Zr { constructor({ enableLongStackTrace: t = !1 }) { if (this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, this.onUnstable = new vr(!1), this.onMicrotaskEmpty = new vr(!1), this.onStable = new vr(!1), this.onError = new vr(!1), "undefined" == typeof Zone) throw new Error("In this configuration Angular requires Zone.js"); var e; Zone.assertZonePatched(), this._nesting = 0, this._outer = this._inner = Zone.current, Zone.wtfZoneSpec && (this._inner = this._inner.fork(Zone.wtfZoneSpec)), Zone.TaskTrackingZoneSpec && (this._inner = this._inner.fork(new Zone.TaskTrackingZoneSpec)), t && Zone.longStackTraceZoneSpec && (this._inner = this._inner.fork(Zone.longStackTraceZoneSpec)), (e = this)._inner = e._inner.fork({ name: "angular", properties: { isAngularZone: !0 }, onInvokeTask: (t, n, i, r, s, o) => { try { return Xr(e), t.invokeTask(i, r, s, o) } finally { Jr(e) } }, onInvoke: (t, n, i, r, s, o, l) => { try { return Xr(e), t.invoke(i, r, s, o, l) } finally { Jr(e) } }, onHasTask: (t, n, i, r) => { t.hasTask(i, r), n === i && ("microTask" == r.change ? (e.hasPendingMicrotasks = r.microTask, Yr(e)) : "macroTask" == r.change && (e.hasPendingMacrotasks = r.macroTask)) }, onHandleError: (t, n, i, r) => (t.handleError(i, r), e.runOutsideAngular(() => e.onError.emit(r)), !1) }) } static isInAngularZone() { return !0 === Zone.current.get("isAngularZone") } static assertInAngularZone() { if (!Zr.isInAngularZone()) throw new Error("Expected to be in Angular Zone, but it is not!") } static assertNotInAngularZone() { if (Zr.isInAngularZone()) throw new Error("Expected to not be in Angular Zone, but it is!") } run(t, e, n) { return this._inner.run(t, e, n) } runTask(t, e, n, i) { const r = this._inner, s = r.scheduleEventTask("NgZoneEvent: " + i, t, Kr, Qr, Qr); try { return r.runTask(s, e, n) } finally { r.cancelTask(s) } } runGuarded(t, e, n) { return this._inner.runGuarded(t, e, n) } runOutsideAngular(t) { return this._outer.run(t) } } function Qr() { } const Kr = {}; function Yr(t) { if (0 == t._nesting && !t.hasPendingMicrotasks && !t.isStable) try { t._nesting++, t.onMicrotaskEmpty.emit(null) } finally { if (t._nesting--, !t.hasPendingMicrotasks) try { t.runOutsideAngular(() => t.onStable.emit(null)) } finally { t.isStable = !0 } } } function Xr(t) { t._nesting++, t.isStable && (t.isStable = !1, t.onUnstable.emit(null)) } function Jr(t) { t._nesting--, Yr(t) } class ts { constructor() { this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, this.onUnstable = new vr, this.onMicrotaskEmpty = new vr, this.onStable = new vr, this.onError = new vr } run(t) { return t() } runGuarded(t) { return t() } runOutsideAngular(t) { return t() } runTask(t) { return t() } } let es = (() => class { constructor(t) { this._ngZone = t, this._pendingCount = 0, this._isZoneStable = !0, this._didWork = !1, this._callbacks = [], this.taskTrackingZone = null, this._watchAngularEvents(), t.run(() => { this.taskTrackingZone = "undefined" == typeof Zone ? null : Zone.current.get("TaskTrackingZone") }) } _watchAngularEvents() { this._ngZone.onUnstable.subscribe({ next: () => { this._didWork = !0, this._isZoneStable = !1 } }), this._ngZone.runOutsideAngular(() => { this._ngZone.onStable.subscribe({ next: () => { Zr.assertNotInAngularZone(), Gr(() => { this._isZoneStable = !0, this._runCallbacksIfReady() }) } }) }) } increasePendingRequestCount() { return this._pendingCount += 1, this._didWork = !0, this._pendingCount } decreasePendingRequestCount() { if (this._pendingCount -= 1, this._pendingCount < 0) throw new Error("pending async requests below zero"); return this._runCallbacksIfReady(), this._pendingCount } isStable() { return this._isZoneStable && 0 === this._pendingCount && !this._ngZone.hasPendingMacrotasks } _runCallbacksIfReady() { if (this.isStable()) Gr(() => { for (; 0 !== this._callbacks.length;) { let t = this._callbacks.pop(); clearTimeout(t.timeoutId), t.doneCb(this._didWork) } this._didWork = !1 }); else { let t = this.getPendingTasks(); this._callbacks = this._callbacks.filter(e => !e.updateCb || !e.updateCb(t) || (clearTimeout(e.timeoutId), !1)), this._didWork = !0 } } getPendingTasks() { return this.taskTrackingZone ? this.taskTrackingZone.macroTasks.map(t => ({ source: t.source, creationLocation: t.creationLocation, data: t.data })) : [] } addCallback(t, e, n) { let i = -1; e && e > 0 && (i = setTimeout(() => { this._callbacks = this._callbacks.filter(t => t.timeoutId !== i), t(this._didWork, this.getPendingTasks()) }, e)), this._callbacks.push({ doneCb: t, timeoutId: i, updateCb: n }) } whenStable(t, e, n) { if (n && !this.taskTrackingZone) throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/dist/task-tracking.js" loaded?'); this.addCallback(t, e, n), this._runCallbacksIfReady() } getPendingRequestCount() { return this._pendingCount } findProviders(t, e, n) { return [] } })(), ns = (() => { class t { constructor() { this._applications = new Map, ss.addToWindow(this) } registerApplication(t, e) { this._applications.set(t, e) } unregisterApplication(t) { this._applications.delete(t) } unregisterAllApplications() { this._applications.clear() } getTestability(t) { return this._applications.get(t) || null } getAllTestabilities() { return Array.from(this._applications.values()) } getAllRootElements() { return Array.from(this._applications.keys()) } findTestabilityInTree(t, e = !0) { return ss.findTestabilityInTree(this, t, e) } } return t.ctorParameters = () => [], t })(); class is { addToWindow(t) { } findTestabilityInTree(t, e, n) { return null } } let rs, ss = new is; const os = new Tt("AllowMultipleToken"); class ls { constructor(t, e) { this.name = t, this.token = e } } function as(t, e, n = []) { const i = "Platform: " + e, r = new Tt(i); return (e = []) => { let s = cs(); if (!s || s.injector.get(os, !1)) if (t) t(n.concat(e).concat({ provide: r, useValue: !0 })); else { const t = n.concat(e).concat({ provide: r, useValue: !0 }); !function (t) { if (rs && !rs.destroyed && !rs.injector.get(os, !1)) throw new Error("There can be only one platform. Destroy the previous one to create a new one."); rs = t.get(us); const e = t.get(kr, null); e && e.forEach(t => t()) }(zt.create({ providers: t, name: i })) } return function (t) { const e = cs(); if (!e) throw new Error("No platform exists!"); if (!e.injector.get(t, null)) throw new Error("A platform with a different configuration has been created. Please destroy it first."); return e }(r) } } function cs() { return rs && !rs.destroyed ? rs : null } let us = (() => class { constructor(t) { this._injector = t, this._modules = [], this._destroyListeners = [], this._destroyed = !1 } bootstrapModuleFactory(t, e) { const n = function (t) { let e; return e = "noop" === t ? new ts : ("zone.js" === t ? void 0 : t) || new Zr({ enableLongStackTrace: Yt() }), e }(e ? e.ngZone : void 0), i = [{ provide: Zr, useValue: n }]; return n.run(() => { const e = zt.create({ providers: i, parent: this.injector, name: t.moduleType.name }), r = t.create(e), s = r.injector.get(Te, null); if (!s) throw new Error("No ErrorHandler. Is platform module (BrowserModule) included?"); return o = r.injector.get(Ar, "en-US"), yr = o.toLowerCase().replace(/_/g, "-"), r.onDestroy(() => ps(this._modules, r)), n.runOutsideAngular(() => n.onError.subscribe({ next: t => { s.handleError(t) } })), function (t, e, n) { try { const i = n(); return Fe(i) ? i.catch(n => { throw e.runOutsideAngular(() => t.handleError(n)), n }) : i } catch (i) { throw e.runOutsideAngular(() => t.handleError(i)), i } }(s, n, () => { const t = r.injector.get(Sr); return t.runInitializers(), t.donePromise.then(() => (this._moduleDoBootstrap(r), r)) }); var o }) } bootstrapModule(t, e = []) { const n = hs({}, e); return function (t, e, n) { return t.get(jr).createCompiler([e]).compileModuleAsync(n) }(this.injector, n, t).then(t => this.bootstrapModuleFactory(t, n)) } _moduleDoBootstrap(t) { const e = t.injector.get(ds); if (t._bootstrapComponents.length > 0) t._bootstrapComponents.forEach(t => e.bootstrap(t)); else { if (!t.instance.ngDoBootstrap) throw new Error(`The module ${_t(t.instance.constructor)} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. Please define one of these.`); t.instance.ngDoBootstrap(e) } this._modules.push(t) } onDestroy(t) { this._destroyListeners.push(t) } get injector() { return this._injector } destroy() { if (this._destroyed) throw new Error("The platform has already been destroyed!"); this._modules.slice().forEach(t => t.destroy()), this._destroyListeners.forEach(t => t()), this._destroyed = !0 } get destroyed() { return this._destroyed } })(); function hs(t, e) { return Array.isArray(e) ? e.reduce(hs, t) : Object.assign({}, t, e) } let ds = (() => { class t { constructor(t, e, n, i, r, s) { this._zone = t, this._console = e, this._injector = n, this._exceptionHandler = i, this._componentFactoryResolver = r, this._initStatus = s, this._bootstrapListeners = [], this._views = [], this._runningTick = !1, this._enforceNoNewChanges = !1, this._stable = !0, this.componentTypes = [], this.components = [], this._enforceNoNewChanges = Yt(), this._zone.onMicrotaskEmpty.subscribe({ next: () => { this._zone.run(() => { this.tick() }) } }); const o = new w(t => { this._stable = this._zone.isStable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks, this._zone.runOutsideAngular(() => { t.next(this._stable), t.complete() }) }), l = new w(t => { let e; this._zone.runOutsideAngular(() => { e = this._zone.onStable.subscribe(() => { Zr.assertNotInAngularZone(), Gr(() => { this._stable || this._zone.hasPendingMacrotasks || this._zone.hasPendingMicrotasks || (this._stable = !0, t.next(!0)) }) }) }); const n = this._zone.onUnstable.subscribe(() => { Zr.assertInAngularZone(), this._stable && (this._stable = !1, this._zone.runOutsideAngular(() => { t.next(!1) })) }); return () => { e.unsubscribe(), n.unsubscribe() } }); this.isStable = X(o, l.pipe(ot())) } bootstrap(t, e) { if (!this._initStatus.done) throw new Error("Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module."); let n; n = t instanceof ze ? t : this._componentFactoryResolver.resolveComponentFactory(t), this.componentTypes.push(n.componentType); const i = n instanceof We ? null : this._injector.get(qe), r = n.create(zt.NULL, [], e || n.selector, i); r.onDestroy(() => { this._unloadComponent(r) }); const s = r.injector.get(es, null); return s && r.injector.get(ns).registerApplication(r.location.nativeElement, s), this._loadComponent(r), Yt() && this._console.log("Angular is running in the development mode. Call enableProdMode() to enable the production mode."), r } tick() { if (this._runningTick) throw new Error("ApplicationRef.tick is called recursively"); const e = t._tickScope(); try { this._runningTick = !0; for (let t of this._views) t.detectChanges(); if (this._enforceNoNewChanges) for (let t of this._views) t.checkNoChanges() } catch (n) { this._zone.runOutsideAngular(() => this._exceptionHandler.handleError(n)) } finally { this._runningTick = !1, Wr(e) } } attachView(t) { const e = t; this._views.push(e), e.attachToAppRef(this) } detachView(t) { const e = t; ps(this._views, e), e.detachFromAppRef() } _loadComponent(t) { this.attachView(t.hostView), this.tick(), this.components.push(t), this._injector.get(Or, []).concat(this._bootstrapListeners).forEach(e => e(t)) } _unloadComponent(t) { this.detachView(t.hostView), ps(this.components, t) } ngOnDestroy() { this._views.slice().forEach(t => t.destroy()) } get viewCount() { return this._views.length } } return t._tickScope = $r("ApplicationRef#tick()"), t })(); function ps(t, e) { const n = t.indexOf(e); n > -1 && t.splice(n, 1) } class fs { } class ms { } const gs = { factoryPathPrefix: "", factoryPathSuffix: ".ngfactory" }; let _s = (() => class { constructor(t, e) { this._compiler = t, this._config = e || gs } load(t) { return this._compiler instanceof zr ? this.loadFactory(t) : this.loadAndCompile(t) } loadAndCompile(t) { let [e, i] = t.split("#"); return void 0 === i && (i = "default"), n("zn8P")(e).then(t => t[i]).then(t => ys(t, e, i)).then(t => this._compiler.compileModuleAsync(t)) } loadFactory(t) { let [e, i] = t.split("#"), r = "NgFactory"; return void 0 === i && (i = "default", r = ""), n("zn8P")(this._config.factoryPathPrefix + e + this._config.factoryPathSuffix).then(t => t[i + r]).then(t => ys(t, e, i)) } })(); function ys(t, e, n) { if (!t) throw new Error(`Cannot find '${n}' in '${e}'`); return t } class vs { constructor(t, e) { this.name = t, this.callback = e } } class bs { constructor(t, e, n) { this.listeners = [], this.parent = null, this._debugContext = n, this.nativeNode = t, e && e instanceof ws && e.addChild(this) } get injector() { return this._debugContext.injector } get componentInstance() { return this._debugContext.component } get context() { return this._debugContext.context } get references() { return this._debugContext.references } get providerTokens() { return this._debugContext.providerTokens } } class ws extends bs { constructor(t, e, n) { super(t, e, n), this.properties = {}, this.attributes = {}, this.classes = {}, this.styles = {}, this.childNodes = [], this.nativeElement = t } addChild(t) { t && (this.childNodes.push(t), t.parent = this) } removeChild(t) { const e = this.childNodes.indexOf(t); -1 !== e && (t.parent = null, this.childNodes.splice(e, 1)) } insertChildrenAfter(t, e) { const n = this.childNodes.indexOf(t); -1 !== n && (this.childNodes.splice(n + 1, 0, ...e), e.forEach(e => { e.parent && e.parent.removeChild(e), t.parent = this })) } insertBefore(t, e) { const n = this.childNodes.indexOf(t); -1 === n ? this.addChild(e) : (e.parent && e.parent.removeChild(e), e.parent = this, this.childNodes.splice(n, 0, e)) } query(t) { return this.queryAll(t)[0] || null } queryAll(t) { const e = []; return function t(e, n, i) { e.childNodes.forEach(e => { e instanceof ws && (n(e) && i.push(e), t(e, n, i)) }) }(this, t, e), e } queryAllNodes(t) { const e = []; return function t(e, n, i) { e instanceof ws && e.childNodes.forEach(e => { n(e) && i.push(e), e instanceof ws && t(e, n, i) }) }(this, t, e), e } get children() { return this.childNodes.filter(t => t instanceof ws) } triggerEventHandler(t, e) { this.listeners.forEach(n => { n.name == t && n.callback(e) }) } } const Cs = new Map, Ss = function (t) { return Cs.get(t) || null }; function Es(t) { Cs.set(t.nativeNode, t) } const xs = as(null, "core", [{ provide: Pr, useValue: "unknown" }, { provide: us, deps: [zt] }, { provide: ns, deps: [] }, { provide: Ir, deps: [] }]); function Ts() { return bn } function ks() { return wn } function Ps(t) { return t || "en-US" } function Os(t) { let e = []; return t.onStable.subscribe(() => { for (; e.length;)e.pop()() }), function (t) { e.push(t) } } let Is = (() => class { constructor(t) { } })(); function As(t, e, n, i, r, s) { t |= 1; const { matchedQueries: o, references: l, matchedQueryIds: a } = ti(e); return { nodeIndex: -1, parent: null, renderParent: null, bindingIndex: -1, outputIndex: -1, flags: t, checkIndex: -1, childFlags: 0, directChildFlags: 0, childMatchedQueries: 0, matchedQueries: o, matchedQueryIds: a, references: l, ngContentIndex: n, childCount: i, bindings: [], bindingFlags: 0, outputs: [], element: { ns: null, name: null, attrs: null, template: s ? ri(s) : null, componentProvider: null, componentView: null, componentRendererType: null, publicProviders: null, allProviders: null, handleEvent: r || Ln }, provider: null, text: null, query: null, ngContent: null } } function Rs(t, e, n, i, r, s, o = [], l, a, c, u, h) { c || (c = Ln); const { matchedQueries: d, references: p, matchedQueryIds: f } = ti(n); let m = null, g = null; s && ([m, g] = hi(s)), l = l || []; const _ = new Array(l.length); for (let b = 0; b < l.length; b++) { const [t, e, n] = l[b], [i, r] = hi(e); let s = void 0, o = void 0; switch (15 & t) { case 4: o = n; break; case 1: case 8: s = n }_[b] = { flags: t, ns: i, name: r, nonMinifiedName: r, securityContext: s, suffix: o } } a = a || []; const y = new Array(a.length); for (let b = 0; b < a.length; b++) { const [t, e] = a[b]; y[b] = { type: 0, target: t, eventName: e, propName: null } } const v = (o = o || []).map(([t, e]) => { const [n, i] = hi(t); return [n, i, e] }); return h = function (t) { if (t && "$$undefined" === t.id) { const e = null != t.encapsulation && t.encapsulation !== Zt.None || t.styles.length || Object.keys(t.data).length; t.id = e ? "c" + Un++ : "$$empty" } return t && "$$empty" === t.id && (t = null), t || null }(h), u && (e |= 33554432), { nodeIndex: -1, parent: null, renderParent: null, bindingIndex: -1, outputIndex: -1, checkIndex: t, flags: e |= 1, childFlags: 0, directChildFlags: 0, childMatchedQueries: 0, matchedQueries: d, matchedQueryIds: f, references: p, ngContentIndex: i, childCount: r, bindings: _, bindingFlags: di(_), outputs: y, element: { ns: m, name: g, attrs: v, template: null, componentProvider: null, componentView: u || null, componentRendererType: h, publicProviders: null, allProviders: null, handleEvent: c || Ln }, provider: null, text: null, query: null, ngContent: null } } function Ns(t, e, n) { const i = n.element, r = t.root.selectorOrNode, s = t.renderer; let o; if (t.parent || !r) { o = i.name ? s.createElement(i.name, i.ns) : s.createComment(""); const r = ni(t, e, n); r && s.appendChild(r, o) } else o = s.selectRootElement(r, !!i.componentRendererType && i.componentRendererType.encapsulation === Zt.ShadowDom); if (i.attrs) for (let l = 0; l < i.attrs.length; l++) { const [t, e, n] = i.attrs[l]; s.setAttribute(o, e, n, t) } return o } function Ms(t, e, n, i) { for (let o = 0; o < n.outputs.length; o++) { const l = n.outputs[o], a = Ds(t, n.nodeIndex, (s = l.eventName, (r = l.target) ? `${r}:${s}` : s)); let c = l.target, u = t; "component" === l.target && (c = null, u = e); const h = u.renderer.listen(c || i, l.eventName, a); t.disposables[n.outputIndex + o] = h } var r, s } function Ds(t, e, n) { return i => Gn(t, e, n, i) } function Fs(t, e, n, i) { if (!Bn(t, e, n, i)) return !1; const r = e.bindings[n], s = Rn(t, e.nodeIndex), o = s.renderElement, l = r.name; switch (15 & r.flags) { case 1: !function (t, e, n, i, r, s) { const o = e.securityContext; let l = o ? t.root.sanitizer.sanitize(o, s) : s; l = null != l ? l.toString() : null; const a = t.renderer; null != s ? a.setAttribute(n, r, l, i) : a.removeAttribute(n, r, i) }(t, r, o, r.ns, l, i); break; case 2: !function (t, e, n, i) { const r = t.renderer; i ? r.addClass(e, n) : r.removeClass(e, n) }(t, o, l, i); break; case 4: !function (t, e, n, i, r) { let s = t.root.sanitizer.sanitize(ve.STYLE, r); if (null != s) { s = s.toString(); const t = e.suffix; null != t && (s += t) } else s = null; const o = t.renderer; null != s ? o.setStyle(n, i, s) : o.removeStyle(n, i) }(t, r, o, l, i); break; case 8: !function (t, e, n, i, r) { const s = e.securityContext; let o = s ? t.root.sanitizer.sanitize(s, r) : r; t.renderer.setProperty(n, i, o) }(33554432 & e.flags && 32 & r.flags ? s.componentView : t, r, o, l, i) }return !0 } function Ls(t, e, n) { let i = []; for (let r in n) i.push({ propName: r, bindingType: n[r] }); return { nodeIndex: -1, parent: null, renderParent: null, bindingIndex: -1, outputIndex: -1, checkIndex: -1, flags: t, childFlags: 0, directChildFlags: 0, childMatchedQueries: 0, ngContentIndex: -1, matchedQueries: {}, matchedQueryIds: 0, references: {}, childCount: 0, bindings: [], bindingFlags: 0, outputs: [], element: null, provider: null, text: null, query: { id: e, filterId: Jn(e), bindings: i }, ngContent: null } } function Vs(t) { const e = t.def.nodeMatchedQueries; for (; t.parent && Xn(t);) { let n = t.parentNodeDef; t = t.parent; const i = n.nodeIndex + n.childCount; for (let r = 0; r <= i; r++) { const i = t.def.nodes[r]; 67108864 & i.flags && 536870912 & i.flags && (i.query.filterId & e) === i.query.filterId && Dn(t, r).setDirty(), !(1 & i.flags && r + i.childCount < n.nodeIndex) && 67108864 & i.childFlags && 536870912 & i.childFlags || (r += i.childCount) } } if (134217728 & t.def.nodeFlags) for (let n = 0; n < t.def.nodes.length; n++) { const e = t.def.nodes[n]; 134217728 & e.flags && 536870912 & e.flags && Dn(t, n).setDirty(), n += e.childCount } } function zs(t, e) { const n = Dn(t, e.nodeIndex); if (!n.dirty) return; let i, r = void 0; if (67108864 & e.flags) { const n = e.parent.parent; r = js(t, n.nodeIndex, n.nodeIndex + n.childCount, e.query, []), i = Nn(t, e.parent.nodeIndex).instance } else 134217728 & e.flags && (r = js(t, 0, t.def.nodes.length - 1, e.query, []), i = t.component); n.reset(r); const s = e.query.bindings; let o = !1; for (let l = 0; l < s.length; l++) { const t = s[l]; let e; switch (t.bindingType) { case 0: e = n.first; break; case 1: e = n, o = !0 }i[t.propName] = e } o && n.notifyOnChanges() } function js(t, e, n, i, r) { for (let s = e; s <= n; s++) { const e = t.def.nodes[s], n = e.matchedQueries[i.id]; if (null != n && r.push(Us(t, e, n)), 1 & e.flags && e.element.template && (e.element.template.nodeMatchedQueries & i.filterId) === i.filterId) { const n = Rn(t, s); if ((e.childMatchedQueries & i.filterId) === i.filterId && (js(t, s + 1, s + e.childCount, i, r), s += e.childCount), 16777216 & e.flags) { const t = n.viewContainer._embeddedViews; for (let e = 0; e < t.length; e++) { const s = t[e], o = Zn(s); o && o === n && js(s, 0, s.def.nodes.length - 1, i, r) } } const o = n.template._projectedViews; if (o) for (let t = 0; t < o.length; t++) { const e = o[t]; js(e, 0, e.def.nodes.length - 1, i, r) } } (e.childMatchedQueries & i.filterId) !== i.filterId && (s += e.childCount) } return r } function Us(t, e, n) { if (null != n) switch (n) { case 1: return Rn(t, e.nodeIndex).renderElement; case 0: return new Qe(Rn(t, e.nodeIndex).renderElement); case 2: return Rn(t, e.nodeIndex).template; case 3: return Rn(t, e.nodeIndex).viewContainer; case 4: return Nn(t, e.nodeIndex).instance } } function Hs(t, e) { return { nodeIndex: -1, parent: null, renderParent: null, bindingIndex: -1, outputIndex: -1, checkIndex: -1, flags: 8, childFlags: 0, directChildFlags: 0, childMatchedQueries: 0, matchedQueries: {}, matchedQueryIds: 0, references: {}, ngContentIndex: t, childCount: 0, bindings: [], bindingFlags: 0, outputs: [], element: null, provider: null, text: null, query: null, ngContent: { index: e } } } function Bs(t, e, n) { const i = ni(t, e, n); i && li(t, n.ngContent.index, 1, i, null, void 0) } function $s(t, e, n) { const i = new Array(n.length); for (let r = 0; r < n.length; r++) { const t = n[r]; i[r] = { flags: 8, name: t, ns: null, nonMinifiedName: t, securityContext: null, suffix: null } } return { nodeIndex: -1, parent: null, renderParent: null, bindingIndex: -1, outputIndex: -1, checkIndex: e, flags: t, childFlags: 0, directChildFlags: 0, childMatchedQueries: 0, matchedQueries: {}, matchedQueryIds: 0, references: {}, ngContentIndex: -1, childCount: 0, bindings: i, bindingFlags: di(i), outputs: [], element: null, provider: null, text: null, query: null, ngContent: null } } function Ws(t, e, n) { const i = new Array(n.length - 1); for (let r = 1; r < n.length; r++)i[r - 1] = { flags: 8, name: null, ns: null, nonMinifiedName: null, securityContext: null, suffix: n[r] }; return { nodeIndex: -1, parent: null, renderParent: null, bindingIndex: -1, outputIndex: -1, checkIndex: t, flags: 2, childFlags: 0, directChildFlags: 0, childMatchedQueries: 0, matchedQueries: {}, matchedQueryIds: 0, references: {}, ngContentIndex: e, childCount: 0, bindings: i, bindingFlags: 8, outputs: [], element: null, provider: null, text: { prefix: n[0] }, query: null, ngContent: null } } function qs(t, e, n) { let i; const r = t.renderer; i = r.createText(n.text.prefix); const s = ni(t, e, n); return s && r.appendChild(s, i), { renderText: i } } function Gs(t, e) { return (null != t ? t.toString() : "") + e.suffix } function Zs(t, e, n, i) { let r = 0, s = 0, o = 0, l = 0, a = 0, c = null, u = null, h = !1, d = !1, p = null; for (let f = 0; f < e.length; f++) { const t = e[f]; if (t.nodeIndex = f, t.parent = c, t.bindingIndex = r, t.outputIndex = s, t.renderParent = u, o |= t.flags, a |= t.matchedQueryIds, t.element) { const e = t.element; e.publicProviders = c ? c.element.publicProviders : Object.create(null), e.allProviders = e.publicProviders, h = !1, d = !1, t.element.template && (a |= t.element.template.nodeMatchedQueries) } if (Ks(c, t, e.length), r += t.bindings.length, s += t.outputs.length, !u && 3 & t.flags && (p = t), 20224 & t.flags) { h || (h = !0, c.element.publicProviders = Object.create(c.element.publicProviders), c.element.allProviders = c.element.publicProviders); const e = 0 != (32768 & t.flags); 0 == (8192 & t.flags) || e ? c.element.publicProviders[zn(t.provider.token)] = t : (d || (d = !0, c.element.allProviders = Object.create(c.element.publicProviders)), c.element.allProviders[zn(t.provider.token)] = t), e && (c.element.componentProvider = t) } if (c ? (c.childFlags |= t.flags, c.directChildFlags |= t.flags, c.childMatchedQueries |= t.matchedQueryIds, t.element && t.element.template && (c.childMatchedQueries |= t.element.template.nodeMatchedQueries)) : l |= t.flags, t.childCount > 0) c = t, Qs(t) || (u = t); else for (; c && f === c.nodeIndex + c.childCount;) { const t = c.parent; t && (t.childFlags |= c.childFlags, t.childMatchedQueries |= c.childMatchedQueries), c = t, u = c && Qs(c) ? c.renderParent : c } } return { factory: null, nodeFlags: o, rootNodeFlags: l, nodeMatchedQueries: a, flags: t, nodes: e, updateDirectives: n || Ln, updateRenderer: i || Ln, handleEvent: (t, n, i, r) => e[n].element.handleEvent(t, i, r), bindingCount: r, outputCount: s, lastRenderRootNode: p } } function Qs(t) { return 0 != (1 & t.flags) && null === t.element.name } function Ks(t, e, n) { const i = e.element && e.element.template; if (i) { if (!i.lastRenderRootNode) throw new Error("Illegal State: Embedded templates without nodes are not allowed!"); if (i.lastRenderRootNode && 16777216 & i.lastRenderRootNode.flags) throw new Error(`Illegal State: Last root node of a template can't have embedded views, at index ${e.nodeIndex}!`) } if (20224 & e.flags && 0 == (1 & (t ? t.flags : 0))) throw new Error(`Illegal State: StaticProvider/Directive nodes need to be children of elements or anchors, at index ${e.nodeIndex}!`); if (e.query) { if (67108864 & e.flags && (!t || 0 == (16384 & t.flags))) throw new Error(`Illegal State: Content Query nodes need to be children of directives, at index ${e.nodeIndex}!`); if (134217728 & e.flags && t) throw new Error(`Illegal State: View Query nodes have to be top level nodes, at index ${e.nodeIndex}!`) } if (e.childCount) { const i = t ? t.nodeIndex + t.childCount : n - 1; if (e.nodeIndex <= i && e.nodeIndex + e.childCount > i) throw new Error(`Illegal State: childCount of node leads outside of parent, at index ${e.nodeIndex}!`) } } function Ys(t, e, n, i) { const r = to(t.root, t.renderer, t, e, n); return eo(r, t.component, i), no(r), r } function Xs(t, e, n) { const i = to(t, t.renderer, null, null, e); return eo(i, n, n), no(i), i } function Js(t, e, n, i) { const r = e.element.componentRendererType; let s; return s = r ? t.root.rendererFactory.createRenderer(i, r) : t.root.renderer, to(t.root, s, t, e.element.componentProvider, n) } function to(t, e, n, i, r) { const s = new Array(r.nodes.length), o = r.outputCount ? new Array(r.outputCount) : null; return { def: r, parent: n, viewContainerParent: null, parentNodeDef: i, context: null, component: null, nodes: s, state: 13, root: t, renderer: e, oldValues: new Array(r.bindingCount), disposables: o, initIndex: -1 } } function eo(t, e, n) { t.component = e, t.context = n } function no(t) { let e; Yn(t) && (e = Rn(t.parent, t.parentNodeDef.parent.nodeIndex).renderElement); const n = t.def, i = t.nodes; for (let r = 0; r < n.nodes.length; r++) { const s = n.nodes[r]; let o; switch (Fn.setCurrentNode(t, r), 201347067 & s.flags) { case 1: const n = Ns(t, e, s); let l = void 0; if (33554432 & s.flags) { const e = ri(s.element.componentView); l = Fn.createComponentView(t, s, e, n) } Ms(t, l, s, n), o = { renderElement: n, componentView: l, viewContainer: null, template: s.element.template ? Ni(t, s) : void 0 }, 16777216 & s.flags && (o.viewContainer = Oi(t, s, o)); break; case 2: o = qs(t, e, s); break; case 512: case 1024: case 2048: case 256: o = i[r], o || 4096 & s.flags || (o = { instance: Ji(t, s) }); break; case 16: o = { instance: tr(t, s) }; break; case 16384: o = i[r], o || (o = { instance: er(t, s) }), 32768 & s.flags && eo(Rn(t, s.parent.nodeIndex).componentView, o.instance, o.instance); break; case 32: case 64: case 128: o = { value: void 0 }; break; case 67108864: case 134217728: o = new wr; break; case 8: Bs(t, e, s), o = void 0 }i[r] = o } ho(t, uo.CreateViewNodes), go(t, 201326592, 268435456, 0) } function io(t) { oo(t), Fn.updateDirectives(t, 1), po(t, uo.CheckNoChanges), Fn.updateRenderer(t, 1), ho(t, uo.CheckNoChanges), t.state &= -97 } function ro(t) { 1 & t.state ? (t.state &= -2, t.state |= 2) : t.state &= -3, On(t, 0, 256), oo(t), Fn.updateDirectives(t, 0), po(t, uo.CheckAndUpdate), go(t, 67108864, 536870912, 0); let e = On(t, 256, 512); cr(t, 2097152 | (e ? 1048576 : 0)), Fn.updateRenderer(t, 0), ho(t, uo.CheckAndUpdate), go(t, 134217728, 536870912, 0), e = On(t, 512, 768), cr(t, 8388608 | (e ? 4194304 : 0)), 2 & t.def.flags && (t.state &= -9), t.state &= -97, On(t, 768, 1024) } function so(t, e, n, i, r, s, o, l, a, c, u, h, d) { return 0 === n ? function (t, e, n, i, r, s, o, l, a, c, u, h) { switch (201347067 & e.flags) { case 1: return function (t, e, n, i, r, s, o, l, a, c, u, h) { const d = e.bindings.length; let p = !1; return d > 0 && Fs(t, e, 0, n) && (p = !0), d > 1 && Fs(t, e, 1, i) && (p = !0), d > 2 && Fs(t, e, 2, r) && (p = !0), d > 3 && Fs(t, e, 3, s) && (p = !0), d > 4 && Fs(t, e, 4, o) && (p = !0), d > 5 && Fs(t, e, 5, l) && (p = !0), d > 6 && Fs(t, e, 6, a) && (p = !0), d > 7 && Fs(t, e, 7, c) && (p = !0), d > 8 && Fs(t, e, 8, u) && (p = !0), d > 9 && Fs(t, e, 9, h) && (p = !0), p }(t, e, n, i, r, s, o, l, a, c, u, h); case 2: return function (t, e, n, i, r, s, o, l, a, c, u, h) { let d = !1; const p = e.bindings, f = p.length; if (f > 0 && Bn(t, e, 0, n) && (d = !0), f > 1 && Bn(t, e, 1, i) && (d = !0), f > 2 && Bn(t, e, 2, r) && (d = !0), f > 3 && Bn(t, e, 3, s) && (d = !0), f > 4 && Bn(t, e, 4, o) && (d = !0), f > 5 && Bn(t, e, 5, l) && (d = !0), f > 6 && Bn(t, e, 6, a) && (d = !0), f > 7 && Bn(t, e, 7, c) && (d = !0), f > 8 && Bn(t, e, 8, u) && (d = !0), f > 9 && Bn(t, e, 9, h) && (d = !0), d) { let d = e.text.prefix; f > 0 && (d += Gs(n, p[0])), f > 1 && (d += Gs(i, p[1])), f > 2 && (d += Gs(r, p[2])), f > 3 && (d += Gs(s, p[3])), f > 4 && (d += Gs(o, p[4])), f > 5 && (d += Gs(l, p[5])), f > 6 && (d += Gs(a, p[6])), f > 7 && (d += Gs(c, p[7])), f > 8 && (d += Gs(u, p[8])), f > 9 && (d += Gs(h, p[9])); const m = An(t, e.nodeIndex).renderText; t.renderer.setValue(m, d) } return d }(t, e, n, i, r, s, o, l, a, c, u, h); case 16384: return function (t, e, n, i, r, s, o, l, a, c, u, h) { const d = Nn(t, e.nodeIndex), p = d.instance; let f = !1, m = void 0; const g = e.bindings.length; return g > 0 && Hn(t, e, 0, n) && (f = !0, m = ar(t, d, e, 0, n, m)), g > 1 && Hn(t, e, 1, i) && (f = !0, m = ar(t, d, e, 1, i, m)), g > 2 && Hn(t, e, 2, r) && (f = !0, m = ar(t, d, e, 2, r, m)), g > 3 && Hn(t, e, 3, s) && (f = !0, m = ar(t, d, e, 3, s, m)), g > 4 && Hn(t, e, 4, o) && (f = !0, m = ar(t, d, e, 4, o, m)), g > 5 && Hn(t, e, 5, l) && (f = !0, m = ar(t, d, e, 5, l, m)), g > 6 && Hn(t, e, 6, a) && (f = !0, m = ar(t, d, e, 6, a, m)), g > 7 && Hn(t, e, 7, c) && (f = !0, m = ar(t, d, e, 7, c, m)), g > 8 && Hn(t, e, 8, u) && (f = !0, m = ar(t, d, e, 8, u, m)), g > 9 && Hn(t, e, 9, h) && (f = !0, m = ar(t, d, e, 9, h, m)), m && p.ngOnChanges(m), 65536 & e.flags && In(t, 256, e.nodeIndex) && p.ngOnInit(), 262144 & e.flags && p.ngDoCheck(), f }(t, e, n, i, r, s, o, l, a, c, u, h); case 32: case 64: case 128: return function (t, e, n, i, r, s, o, l, a, c, u, h) { const d = e.bindings; let p = !1; const f = d.length; if (f > 0 && Bn(t, e, 0, n) && (p = !0), f > 1 && Bn(t, e, 1, i) && (p = !0), f > 2 && Bn(t, e, 2, r) && (p = !0), f > 3 && Bn(t, e, 3, s) && (p = !0), f > 4 && Bn(t, e, 4, o) && (p = !0), f > 5 && Bn(t, e, 5, l) && (p = !0), f > 6 && Bn(t, e, 6, a) && (p = !0), f > 7 && Bn(t, e, 7, c) && (p = !0), f > 8 && Bn(t, e, 8, u) && (p = !0), f > 9 && Bn(t, e, 9, h) && (p = !0), p) { const p = Mn(t, e.nodeIndex); let m; switch (201347067 & e.flags) { case 32: m = new Array(d.length), f > 0 && (m[0] = n), f > 1 && (m[1] = i), f > 2 && (m[2] = r), f > 3 && (m[3] = s), f > 4 && (m[4] = o), f > 5 && (m[5] = l), f > 6 && (m[6] = a), f > 7 && (m[7] = c), f > 8 && (m[8] = u), f > 9 && (m[9] = h); break; case 64: m = {}, f > 0 && (m[d[0].name] = n), f > 1 && (m[d[1].name] = i), f > 2 && (m[d[2].name] = r), f > 3 && (m[d[3].name] = s), f > 4 && (m[d[4].name] = o), f > 5 && (m[d[5].name] = l), f > 6 && (m[d[6].name] = a), f > 7 && (m[d[7].name] = c), f > 8 && (m[d[8].name] = u), f > 9 && (m[d[9].name] = h); break; case 128: const t = n; switch (f) { case 1: m = t.transform(n); break; case 2: m = t.transform(i); break; case 3: m = t.transform(i, r); break; case 4: m = t.transform(i, r, s); break; case 5: m = t.transform(i, r, s, o); break; case 6: m = t.transform(i, r, s, o, l); break; case 7: m = t.transform(i, r, s, o, l, a); break; case 8: m = t.transform(i, r, s, o, l, a, c); break; case 9: m = t.transform(i, r, s, o, l, a, c, u); break; case 10: m = t.transform(i, r, s, o, l, a, c, u, h) } }p.value = m } return p }(t, e, n, i, r, s, o, l, a, c, u, h); default: throw "unreachable" } }(t, e, i, r, s, o, l, a, c, u, h, d) : function (t, e, n) { switch (201347067 & e.flags) { case 1: return function (t, e, n) { let i = !1; for (let r = 0; r < n.length; r++)Fs(t, e, r, n[r]) && (i = !0); return i }(t, e, n); case 2: return function (t, e, n) { const i = e.bindings; let r = !1; for (let s = 0; s < n.length; s++)Bn(t, e, s, n[s]) && (r = !0); if (r) { let r = ""; for (let t = 0; t < n.length; t++)r += Gs(n[t], i[t]); r = e.text.prefix + r; const s = An(t, e.nodeIndex).renderText; t.renderer.setValue(s, r) } return r }(t, e, n); case 16384: return function (t, e, n) { const i = Nn(t, e.nodeIndex), r = i.instance; let s = !1, o = void 0; for (let l = 0; l < n.length; l++)Hn(t, e, l, n[l]) && (s = !0, o = ar(t, i, e, l, n[l], o)); return o && r.ngOnChanges(o), 65536 & e.flags && In(t, 256, e.nodeIndex) && r.ngOnInit(), 262144 & e.flags && r.ngDoCheck(), s }(t, e, n); case 32: case 64: case 128: return function (t, e, n) { const i = e.bindings; let r = !1; for (let s = 0; s < n.length; s++)Bn(t, e, s, n[s]) && (r = !0); if (r) { const r = Mn(t, e.nodeIndex); let s; switch (201347067 & e.flags) { case 32: s = n; break; case 64: s = {}; for (let r = 0; r < n.length; r++)s[i[r].name] = n[r]; break; case 128: const t = n[0], e = n.slice(1); s = t.transform(...e) }r.value = s } return r }(t, e, n); default: throw "unreachable" } }(t, e, i) } function oo(t) { const e = t.def; if (4 & e.nodeFlags) for (let n = 0; n < e.nodes.length; n++) { const i = e.nodes[n]; if (4 & i.flags) { const e = Rn(t, n).template._projectedViews; if (e) for (let n = 0; n < e.length; n++) { const i = e[n]; i.state |= 32, qn(i, t) } } else 0 == (4 & i.childFlags) && (n += i.childCount) } } function lo(t, e, n, i, r, s, o, l, a, c, u, h, d) { return 0 === n ? function (t, e, n, i, r, s, o, l, a, c, u, h) { const d = e.bindings.length; d > 0 && $n(t, e, 0, n), d > 1 && $n(t, e, 1, i), d > 2 && $n(t, e, 2, r), d > 3 && $n(t, e, 3, s), d > 4 && $n(t, e, 4, o), d > 5 && $n(t, e, 5, l), d > 6 && $n(t, e, 6, a), d > 7 && $n(t, e, 7, c), d > 8 && $n(t, e, 8, u), d > 9 && $n(t, e, 9, h) }(t, e, i, r, s, o, l, a, c, u, h, d) : function (t, e, n) { for (let i = 0; i < n.length; i++)$n(t, e, i, n[i]) }(t, e, i), !1 } function ao(t, e) { if (Dn(t, e.nodeIndex).dirty) throw Tn(Fn.createDebugContext(t, e.nodeIndex), `Query ${e.query.id} not dirty`, `Query ${e.query.id} dirty`, 0 != (1 & t.state)) } function co(t) { if (!(128 & t.state)) { if (po(t, uo.Destroy), ho(t, uo.Destroy), cr(t, 131072), t.disposables) for (let e = 0; e < t.disposables.length; e++)t.disposables[e](); !function (t) { if (!(16 & t.state)) return; const e = Zn(t); if (e) { const n = e.template._projectedViews; n && (Ei(n, n.indexOf(t)), Fn.dirtyParentQueries(t)) } }(t), t.renderer.destroyNode && function (t) { const e = t.def.nodes.length; for (let n = 0; n < e; n++) { const e = t.def.nodes[n]; 1 & e.flags ? t.renderer.destroyNode(Rn(t, n).renderElement) : 2 & e.flags ? t.renderer.destroyNode(An(t, n).renderText) : (67108864 & e.flags || 134217728 & e.flags) && Dn(t, n).destroy() } }(t), Yn(t) && t.renderer.destroy(), t.state |= 128 } } const uo = function () { var t = { CreateViewNodes: 0, CheckNoChanges: 1, CheckNoChangesProjectedViews: 2, CheckAndUpdate: 3, CheckAndUpdateProjectedViews: 4, Destroy: 5 }; return t[t.CreateViewNodes] = "CreateViewNodes", t[t.CheckNoChanges] = "CheckNoChanges", t[t.CheckNoChangesProjectedViews] = "CheckNoChangesProjectedViews", t[t.CheckAndUpdate] = "CheckAndUpdate", t[t.CheckAndUpdateProjectedViews] = "CheckAndUpdateProjectedViews", t[t.Destroy] = "Destroy", t }(); function ho(t, e) { const n = t.def; if (33554432 & n.nodeFlags) for (let i = 0; i < n.nodes.length; i++) { const r = n.nodes[i]; 33554432 & r.flags ? fo(Rn(t, i).componentView, e) : 0 == (33554432 & r.childFlags) && (i += r.childCount) } } function po(t, e) { const n = t.def; if (16777216 & n.nodeFlags) for (let i = 0; i < n.nodes.length; i++) { const r = n.nodes[i]; if (16777216 & r.flags) { const n = Rn(t, i).viewContainer._embeddedViews; for (let t = 0; t < n.length; t++)fo(n[t], e) } else 0 == (16777216 & r.childFlags) && (i += r.childCount) } } function fo(t, e) { const n = t.state; switch (e) { case uo.CheckNoChanges: 0 == (128 & n) && (12 == (12 & n) ? io(t) : 64 & n && mo(t, uo.CheckNoChangesProjectedViews)); break; case uo.CheckNoChangesProjectedViews: 0 == (128 & n) && (32 & n ? io(t) : 64 & n && mo(t, e)); break; case uo.CheckAndUpdate: 0 == (128 & n) && (12 == (12 & n) ? ro(t) : 64 & n && mo(t, uo.CheckAndUpdateProjectedViews)); break; case uo.CheckAndUpdateProjectedViews: 0 == (128 & n) && (32 & n ? ro(t) : 64 & n && mo(t, e)); break; case uo.Destroy: co(t); break; case uo.CreateViewNodes: no(t) } } function mo(t, e) { po(t, e), ho(t, e) } function go(t, e, n, i) { if (!(t.def.nodeFlags & e && t.def.nodeFlags & n)) return; const r = t.def.nodes.length; for (let s = 0; s < r; s++) { const r = t.def.nodes[s]; if (r.flags & e && r.flags & n) switch (Fn.setCurrentNode(t, r.nodeIndex), i) { case 0: zs(t, r); break; case 1: ao(t, r) }r.childFlags & e && r.childFlags & n || (s += r.childCount) } } let _o = !1; function yo(t, e, n, i, r, s) { const o = r.injector.get(Xe); return Xs(bo(t, r, o, e, n), i, s) } function vo(t, e, n, i, r, s) { const o = r.injector.get(Xe), l = bo(t, r, new Xo(o), e, n), a = Io(i); return Ko(Fo.create, Xs, null, [l, a, s]) } function bo(t, e, n, i, r) { const s = e.injector.get(be), o = e.injector.get(Te), l = n.createRenderer(null, null); return { ngModule: e, injector: t, projectableNodes: i, selectorOrNode: r, sanitizer: s, rendererFactory: n, renderer: l, errorHandler: o } } function wo(t, e, n, i) { const r = Io(n); return Ko(Fo.create, Ys, null, [t, e, r, i]) } function Co(t, e, n, i) { return n = To.get(e.element.componentProvider.provider.token) || Io(n), Ko(Fo.create, Js, null, [t, e, n, i]) } function So(t, e, n, i) { return ji(t, e, n, function (t) { const { hasOverrides: e, hasDeprecatedOverrides: n } = function (t) { let e = !1, n = !1; return 0 === Eo.size || (t.providers.forEach(t => { const i = Eo.get(t.token); 3840 & t.flags && i && (e = !0, n = n || i.deprecatedBehavior) }), t.modules.forEach(t => { xo.forEach((i, r) => { mt(r).providedIn === t && (e = !0, n = n || i.deprecatedBehavior) }) })), { hasOverrides: e, hasDeprecatedOverrides: n } }(t); return e ? (function (t) { for (let e = 0; e < t.providers.length; e++) { const i = t.providers[e]; n && (i.flags |= 4096); const r = Eo.get(i.token); r && (i.flags = -3841 & i.flags | r.flags, i.deps = ei(r.deps), i.value = r.value) } if (xo.size > 0) { let e = new Set(t.modules); xo.forEach((i, r) => { if (e.has(mt(r).providedIn)) { let e = { token: r, flags: i.flags | (n ? 4096 : 0), deps: ei(i.deps), value: i.value, index: t.providers.length }; t.providers.push(e), t.providersByKey[zn(r)] = e } }) } }(t = t.factory(() => Ln)), t) : t }(i)) } const Eo = new Map, xo = new Map, To = new Map; function ko(t) { let e; Eo.set(t.token, t), "function" == typeof t.token && (e = mt(t.token)) && "function" == typeof e.providedIn && xo.set(t.token, t) } function Po(t, e) { const n = ri(e.viewDefFactory), i = ri(n.nodes[0].element.componentView); To.set(t, i) } function Oo() { Eo.clear(), xo.clear(), To.clear() } function Io(t) { if (0 === Eo.size) return t; const e = function (t) { const e = []; let n = null; for (let i = 0; i < t.nodes.length; i++) { const r = t.nodes[i]; 1 & r.flags && (n = r), n && 3840 & r.flags && Eo.has(r.provider.token) && (e.push(n.nodeIndex), n = null) } return e }(t); if (0 === e.length) return t; t = t.factory(() => Ln); for (let i = 0; i < e.length; i++)n(t, e[i]); return t; function n(t, e) { for (let n = e + 1; n < t.nodes.length; n++) { const e = t.nodes[n]; if (1 & e.flags) return; if (3840 & e.flags) { const t = e.provider, n = Eo.get(t.token); n && (e.flags = -3841 & e.flags | n.flags, t.deps = ei(n.deps), t.value = n.value) } } } } function Ao(t, e, n, i, r, s, o, l, a, c, u, h, d) { const p = t.def.nodes[e]; return so(t, p, n, i, r, s, o, l, a, c, u, h, d), 224 & p.flags ? Mn(t, e).value : void 0 } function Ro(t, e, n, i, r, s, o, l, a, c, u, h, d) { const p = t.def.nodes[e]; return lo(t, p, n, i, r, s, o, l, a, c, u, h, d), 224 & p.flags ? Mn(t, e).value : void 0 } function No(t) { return Ko(Fo.detectChanges, ro, null, [t]) } function Mo(t) { return Ko(Fo.checkNoChanges, io, null, [t]) } function Do(t) { return Ko(Fo.destroy, co, null, [t]) } const Fo = function () { var t = { create: 0, detectChanges: 1, checkNoChanges: 2, destroy: 3, handleEvent: 4 }; return t[t.create] = "create", t[t.detectChanges] = "detectChanges", t[t.checkNoChanges] = "checkNoChanges", t[t.destroy] = "destroy", t[t.handleEvent] = "handleEvent", t }(); let Lo, Vo, zo; function jo(t, e) { Vo = t, zo = e } function Uo(t, e, n, i) { return jo(t, e), Ko(Fo.handleEvent, t.def.handleEvent, null, [t, e, n, i]) } function Ho(t, e) { if (128 & t.state) throw Pn(Fo[Lo]); return jo(t, qo(t, 0)), t.def.updateDirectives((function (t, n, i, ...r) { const s = t.def.nodes[n]; return 0 === e ? $o(t, s, i, r) : Wo(t, s, i, r), 16384 & s.flags && jo(t, qo(t, n)), 224 & s.flags ? Mn(t, s.nodeIndex).value : void 0 }), t) } function Bo(t, e) { if (128 & t.state) throw Pn(Fo[Lo]); return jo(t, Go(t, 0)), t.def.updateRenderer((function (t, n, i, ...r) { const s = t.def.nodes[n]; return 0 === e ? $o(t, s, i, r) : Wo(t, s, i, r), 3 & s.flags && jo(t, Go(t, n)), 224 & s.flags ? Mn(t, s.nodeIndex).value : void 0 }), t) } function $o(t, e, n, i) { if (so(t, e, n, ...i)) { const s = 1 === n ? i[0] : i; if (16384 & e.flags) { const n = {}; for (let t = 0; t < e.bindings.length; t++) { const i = e.bindings[t], o = s[t]; 8 & i.flags && (n[(r = i.nonMinifiedName, "ng-reflect-" + r.replace(/[$@]/g, "_").replace(ke, (...t) => "-" + t[1].toLowerCase()))] = Pe(o)) } const i = e.parent, o = Rn(t, i.nodeIndex).renderElement; if (i.element.name) for (let e in n) { const i = n[e]; null != i ? t.renderer.setAttribute(o, e, i) : t.renderer.removeAttribute(o, e) } else t.renderer.setValue(o, "bindings=" + JSON.stringify(n, null, 2)) } } var r } function Wo(t, e, n, i) { lo(t, e, n, ...i) } function qo(t, e) { for (let n = e; n < t.def.nodes.length; n++) { const e = t.def.nodes[n]; if (16384 & e.flags && e.bindings && e.bindings.length) return n } return null } function Go(t, e) { for (let n = e; n < t.def.nodes.length; n++) { const e = t.def.nodes[n]; if (3 & e.flags && e.bindings && e.bindings.length) return n } return null } class Zo { constructor(t, e) { this.view = t, this.nodeIndex = e, null == e && (this.nodeIndex = e = 0), this.nodeDef = t.def.nodes[e]; let n = this.nodeDef, i = t; for (; n && 0 == (1 & n.flags);)n = n.parent; if (!n) for (; !n && i;)n = Qn(i), i = i.parent; this.elDef = n, this.elView = i } get elOrCompView() { return Rn(this.elView, this.elDef.nodeIndex).componentView || this.view } get injector() { return Di(this.elView, this.elDef) } get component() { return this.elOrCompView.component } get context() { return this.elOrCompView.context } get providerTokens() { const t = []; if (this.elDef) for (let e = this.elDef.nodeIndex + 1; e <= this.elDef.nodeIndex + this.elDef.childCount; e++) { const n = this.elView.def.nodes[e]; 20224 & n.flags && t.push(n.provider.token), e += n.childCount } return t } get references() { const t = {}; if (this.elDef) { Qo(this.elView, this.elDef, t); for (let e = this.elDef.nodeIndex + 1; e <= this.elDef.nodeIndex + this.elDef.childCount; e++) { const n = this.elView.def.nodes[e]; 20224 & n.flags && Qo(this.elView, n, t), e += n.childCount } } return t } get componentRenderElement() { const t = function (t) { for (; t && !Yn(t);)t = t.parent; return t.parent ? Rn(t.parent, Qn(t).nodeIndex) : null }(this.elOrCompView); return t ? t.renderElement : void 0 } get renderNode() { return 2 & this.nodeDef.flags ? Kn(this.view, this.nodeDef) : Kn(this.elView, this.elDef) } logError(t, ...e) { let n, i; 2 & this.nodeDef.flags ? (n = this.view.def, i = this.nodeDef.nodeIndex) : (n = this.elView.def, i = this.elDef.nodeIndex); const r = function (t, e) { let n = -1; for (let i = 0; i <= e; i++)3 & t.nodes[i].flags && n++; return n }(n, i); let s = -1; n.factory(() => (s++, s === r ? t.error.bind(t, ...e) : Ln)), s < r && (t.error("Illegal state: the ViewDefinitionFactory did not call the logger!"), t.error(...e)) } } function Qo(t, e, n) { for (let i in e.references) n[i] = Us(t, e, e.references[i]) } function Ko(t, e, n, i) { const r = Lo, s = Vo, o = zo; try { Lo = t; const l = e.apply(n, i); return Vo = s, zo = o, Lo = r, l } catch (l) { if (Se(l) || !Vo) throw l; throw function (t, e) { return t instanceof Error || (t = new Error(t.toString())), kn(t, e), t }(l, Yo()) } } function Yo() { return Vo ? new Zo(Vo, zo) : null } class Xo { constructor(t) { this.delegate = t } createRenderer(t, e) { return new Jo(this.delegate.createRenderer(t, e)) } begin() { this.delegate.begin && this.delegate.begin() } end() { this.delegate.end && this.delegate.end() } whenRenderingDone() { return this.delegate.whenRenderingDone ? this.delegate.whenRenderingDone() : Promise.resolve(null) } } class Jo { constructor(t) { this.delegate = t, this.debugContextFactory = Yo, this.data = this.delegate.data } createDebugContext(t) { return this.debugContextFactory(t) } destroyNode(t) { !function (t) { Cs.delete(t.nativeNode) }(Ss(t)), this.delegate.destroyNode && this.delegate.destroyNode(t) } destroy() { this.delegate.destroy() } createElement(t, e) { const n = this.delegate.createElement(t, e), i = this.createDebugContext(n); if (i) { const e = new ws(n, null, i); e.name = t, Es(e) } return n } createComment(t) { const e = this.delegate.createComment(t), n = this.createDebugContext(e); return n && Es(new bs(e, null, n)), e } createText(t) { const e = this.delegate.createText(t), n = this.createDebugContext(e); return n && Es(new bs(e, null, n)), e } appendChild(t, e) { const n = Ss(t), i = Ss(e); n && i && n instanceof ws && n.addChild(i), this.delegate.appendChild(t, e) } insertBefore(t, e, n) { const i = Ss(t), r = Ss(e), s = Ss(n); i && r && i instanceof ws && i.insertBefore(s, r), this.delegate.insertBefore(t, e, n) } removeChild(t, e) { const n = Ss(t), i = Ss(e); n && i && n instanceof ws && n.removeChild(i), this.delegate.removeChild(t, e) } selectRootElement(t, e) { const n = this.delegate.selectRootElement(t, e), i = Yo(); return i && Es(new ws(n, null, i)), n } setAttribute(t, e, n, i) { const r = Ss(t); r && r instanceof ws && (r.attributes[i ? i + ":" + e : e] = n), this.delegate.setAttribute(t, e, n, i) } removeAttribute(t, e, n) { const i = Ss(t); i && i instanceof ws && (i.attributes[n ? n + ":" + e : e] = null), this.delegate.removeAttribute(t, e, n) } addClass(t, e) { const n = Ss(t); n && n instanceof ws && (n.classes[e] = !0), this.delegate.addClass(t, e) } removeClass(t, e) { const n = Ss(t); n && n instanceof ws && (n.classes[e] = !1), this.delegate.removeClass(t, e) } setStyle(t, e, n, i) { const r = Ss(t); r && r instanceof ws && (r.styles[e] = n), this.delegate.setStyle(t, e, n, i) } removeStyle(t, e, n) { const i = Ss(t); i && i instanceof ws && (i.styles[e] = null), this.delegate.removeStyle(t, e, n) } setProperty(t, e, n) { const i = Ss(t); i && i instanceof ws && (i.properties[e] = n), this.delegate.setProperty(t, e, n) } listen(t, e, n) { if ("string" != typeof t) { const i = Ss(t); i && i.listeners.push(new vs(e, n)) } return this.delegate.listen(t, e, n) } parentNode(t) { return this.delegate.parentNode(t) } nextSibling(t) { return this.delegate.nextSibling(t) } setValue(t, e) { return this.delegate.setValue(t, e) } } function tl(t, e, n) { return new el(t, e, n) } class el extends Ge { constructor(t, e, n) { super(), this.moduleType = t, this._bootstrapComponents = e, this._ngModuleDefFactory = n } create(t) { !function () { if (_o) return; _o = !0; const t = Yt() ? { setCurrentNode: jo, createRootView: vo, createEmbeddedView: wo, createComponentView: Co, createNgModuleRef: So, overrideProvider: ko, overrideComponentView: Po, clearOverrides: Oo, checkAndUpdateView: No, checkNoChangesView: Mo, destroyView: Do, createDebugContext: (t, e) => new Zo(t, e), handleEvent: Uo, updateDirectives: Ho, updateRenderer: Bo } : { setCurrentNode: () => { }, createRootView: yo, createEmbeddedView: Ys, createComponentView: Js, createNgModuleRef: ji, overrideProvider: Ln, overrideComponentView: Ln, clearOverrides: Ln, checkAndUpdateView: ro, checkNoChangesView: io, destroyView: co, createDebugContext: (t, e) => new Zo(t, e), handleEvent: (t, e, n, i) => t.def.handleEvent(t, e, n, i), updateDirectives: (t, e) => t.def.updateDirectives(0 === e ? Ao : Ro, t), updateRenderer: (t, e) => t.def.updateRenderer(0 === e ? Ao : Ro, t) }; Fn.setCurrentNode = t.setCurrentNode, Fn.createRootView = t.createRootView, Fn.createEmbeddedView = t.createEmbeddedView, Fn.createComponentView = t.createComponentView, Fn.createNgModuleRef = t.createNgModuleRef, Fn.overrideProvider = t.overrideProvider, Fn.overrideComponentView = t.overrideComponentView, Fn.clearOverrides = t.clearOverrides, Fn.checkAndUpdateView = t.checkAndUpdateView, Fn.checkNoChangesView = t.checkNoChangesView, Fn.destroyView = t.destroyView, Fn.resolveDep = or, Fn.createDebugContext = t.createDebugContext, Fn.handleEvent = t.handleEvent, Fn.updateDirectives = t.updateDirectives, Fn.updateRenderer = t.updateRenderer, Fn.dirtyParentQueries = Vs }(); const e = function (t) { const e = Array.from(t.providers), n = Array.from(t.modules), i = {}; for (const r in t.providersByKey) i[r] = t.providersByKey[r]; return { factory: t.factory, isRoot: t.isRoot, providers: e, modules: n, providersByKey: i } }(ri(this._ngModuleDefFactory)); return Fn.createNgModuleRef(this.moduleType, t || zt.NULL, this._bootstrapComponents, e) } } class nl { } class il { constructor() { this.title = "omen-front-end" } } class rl { } const sl = new Tt("Location Initialized"); class ol { } const ll = new Tt("appBaseHref"); let al = (() => { class t { constructor(e, n) { this._subject = new vr, this._urlChangeListeners = [], this._platformStrategy = e; const i = this._platformStrategy.getBaseHref(); this._platformLocation = n, this._baseHref = t.stripTrailingSlash(cl(i)), this._platformStrategy.onPopState(t => { this._subject.emit({ url: this.path(!0), pop: !0, state: t.state, type: t.type }) }) } path(t = !1) { return this.normalize(this._platformStrategy.path(t)) } getState() { return this._platformLocation.getState() } isCurrentPathEqualTo(e, n = "") { return this.path() == this.normalize(e + t.normalizeQueryParams(n)) } normalize(e) { return t.stripTrailingSlash(function (t, e) { return t && e.startsWith(t) ? e.substring(t.length) : e }(this._baseHref, cl(e))) } prepareExternalUrl(t) { return t && "/" !== t[0] && (t = "/" + t), this._platformStrategy.prepareExternalUrl(t) } go(e, n = "", i = null) { this._platformStrategy.pushState(i, "", e, n), this._notifyUrlChangeListeners(this.prepareExternalUrl(e + t.normalizeQueryParams(n)), i) } replaceState(e, n = "", i = null) { this._platformStrategy.replaceState(i, "", e, n), this._notifyUrlChangeListeners(this.prepareExternalUrl(e + t.normalizeQueryParams(n)), i) } forward() { this._platformStrategy.forward() } back() { this._platformStrategy.back() } onUrlChange(t) { this._urlChangeListeners.push(t), this.subscribe(t => { this._notifyUrlChangeListeners(t.url, t.state) }) } _notifyUrlChangeListeners(t = "", e) { this._urlChangeListeners.forEach(n => n(t, e)) } subscribe(t, e, n) { return this._subject.subscribe({ next: t, error: e, complete: n }) } static normalizeQueryParams(t) { return t && "?" !== t[0] ? "?" + t : t } static joinWithSlash(t, e) { if (0 == t.length) return e; if (0 == e.length) return t; let n = 0; return t.endsWith("/") && n++, e.startsWith("/") && n++, 2 == n ? t + e.substring(1) : 1 == n ? t + e : t + "/" + e } static stripTrailingSlash(t) { const e = t.match(/#|\?|$/), n = e && e.index || t.length; return t.slice(0, n - ("/" === t[n - 1] ? 1 : 0)) + t.slice(n) } } return t })(); function cl(t) { return t.replace(/\/index.html$/, "") } let ul = (() => class extends ol { constructor(t, e) { super(), this._platformLocation = t, this._baseHref = "", null != e && (this._baseHref = e) } onPopState(t) { this._platformLocation.onPopState(t), this._platformLocation.onHashChange(t) } getBaseHref() { return this._baseHref } path(t = !1) { let e = this._platformLocation.hash; return null == e && (e = "#"), e.length > 0 ? e.substring(1) : e } prepareExternalUrl(t) { const e = al.joinWithSlash(this._baseHref, t); return e.length > 0 ? "#" + e : e } pushState(t, e, n, i) { let r = this.prepareExternalUrl(n + al.normalizeQueryParams(i)); 0 == r.length && (r = this._platformLocation.pathname), this._platformLocation.pushState(t, e, r) } replaceState(t, e, n, i) { let r = this.prepareExternalUrl(n + al.normalizeQueryParams(i)); 0 == r.length && (r = this._platformLocation.pathname), this._platformLocation.replaceState(t, e, r) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } })(), hl = (() => class extends ol { constructor(t, e) { if (super(), this._platformLocation = t, null == e && (e = this._platformLocation.getBaseHrefFromDOM()), null == e) throw new Error("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document."); this._baseHref = e } onPopState(t) { this._platformLocation.onPopState(t), this._platformLocation.onHashChange(t) } getBaseHref() { return this._baseHref } prepareExternalUrl(t) { return al.joinWithSlash(this._baseHref, t) } path(t = !1) { const e = this._platformLocation.pathname + al.normalizeQueryParams(this._platformLocation.search), n = this._platformLocation.hash; return n && t ? `${e}${n}` : e } pushState(t, e, n, i) { const r = this.prepareExternalUrl(n + al.normalizeQueryParams(i)); this._platformLocation.pushState(t, e, r) } replaceState(t, e, n, i) { const r = this.prepareExternalUrl(n + al.normalizeQueryParams(i)); this._platformLocation.replaceState(t, e, r) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } })(); const dl = function () { var t = { Zero: 0, One: 1, Two: 2, Few: 3, Many: 4, Other: 5 }; return t[t.Zero] = "Zero", t[t.One] = "One", t[t.Two] = "Two", t[t.Few] = "Few", t[t.Many] = "Many", t[t.Other] = "Other", t }(), pl = function () { var t = { Format: 0, Standalone: 1 }; return t[t.Format] = "Format", t[t.Standalone] = "Standalone", t }(), fl = function () { var t = { Narrow: 0, Abbreviated: 1, Wide: 2, Short: 3 }; return t[t.Narrow] = "Narrow", t[t.Abbreviated] = "Abbreviated", t[t.Wide] = "Wide", t[t.Short] = "Short", t }(), ml = function () { var t = { Short: 0, Medium: 1, Long: 2, Full: 3 }; return t[t.Short] = "Short", t[t.Medium] = "Medium", t[t.Long] = "Long", t[t.Full] = "Full", t }(), gl = function () { var t = { Decimal: 0, Group: 1, List: 2, PercentSign: 3, PlusSign: 4, MinusSign: 5, Exponential: 6, SuperscriptingExponent: 7, PerMille: 8, Infinity: 9, NaN: 10, TimeSeparator: 11, CurrencyDecimal: 12, CurrencyGroup: 13 }; return t[t.Decimal] = "Decimal", t[t.Group] = "Group", t[t.List] = "List", t[t.PercentSign] = "PercentSign", t[t.PlusSign] = "PlusSign", t[t.MinusSign] = "MinusSign", t[t.Exponential] = "Exponential", t[t.SuperscriptingExponent] = "SuperscriptingExponent", t[t.PerMille] = "PerMille", t[t.Infinity] = "Infinity", t[t.NaN] = "NaN", t[t.TimeSeparator] = "TimeSeparator", t[t.CurrencyDecimal] = "CurrencyDecimal", t[t.CurrencyGroup] = "CurrencyGroup", t }(); function _l(t, e) { return Cl(_r(t)[fr.DateFormat], e) } function yl(t, e) { return Cl(_r(t)[fr.TimeFormat], e) } function vl(t, e) { return Cl(_r(t)[fr.DateTimeFormat], e) } function bl(t, e) { const n = _r(t), i = n[fr.NumberSymbols][e]; if (void 0 === i) { if (e === gl.CurrencyDecimal) return n[fr.NumberSymbols][gl.Decimal]; if (e === gl.CurrencyGroup) return n[fr.NumberSymbols][gl.Group] } return i } function wl(t) { if (!t[fr.ExtraData]) throw new Error(`Missing extra locale data for the locale "${t[fr.LocaleId]}". Use "registerLocaleData" to load new data. See the "I18n guide" on angular.io to know more.`) } function Cl(t, e) { for (let n = e; n > -1; n--)if (void 0 !== t[n]) return t[n]; throw new Error("Locale data API: locale data undefined") } function Sl(t) { const [e, n] = t.split(":"); return { hours: +e, minutes: +n } } const El = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/, xl = {}, Tl = /((?:[^GyMLwWdEabBhHmsSzZO']+)|(?:'(?:[^']|'')*')|(?:G{1,5}|y{1,4}|M{1,5}|L{1,5}|w{1,2}|W{1}|d{1,2}|E{1,6}|a{1,5}|b{1,5}|B{1,5}|h{1,2}|H{1,2}|m{1,2}|s{1,2}|S{1,3}|z{1,4}|Z{1,5}|O{1,4}))([\s\S]*)/, kl = function () { var t = { Short: 0, ShortGMT: 1, Long: 2, Extended: 3 }; return t[t.Short] = "Short", t[t.ShortGMT] = "ShortGMT", t[t.Long] = "Long", t[t.Extended] = "Extended", t }(), Pl = function () { var t = { FullYear: 0, Month: 1, Date: 2, Hours: 3, Minutes: 4, Seconds: 5, FractionalSeconds: 6, Day: 7 }; return t[t.FullYear] = "FullYear", t[t.Month] = "Month", t[t.Date] = "Date", t[t.Hours] = "Hours", t[t.Minutes] = "Minutes", t[t.Seconds] = "Seconds", t[t.FractionalSeconds] = "FractionalSeconds", t[t.Day] = "Day", t }(), Ol = function () { var t = { DayPeriods: 0, Days: 1, Months: 2, Eras: 3 }; return t[t.DayPeriods] = "DayPeriods", t[t.Days] = "Days", t[t.Months] = "Months", t[t.Eras] = "Eras", t }(); function Il(t, e) { return e && (t = t.replace(/\{([^}]+)}/g, (function (t, n) { return null != e && n in e ? e[n] : t }))), t } function Al(t, e, n = "-", i, r) { let s = ""; (t < 0 || r && t <= 0) && (r ? t = 1 - t : (t = -t, s = n)); let o = String(t); for (; o.length < e;)o = "0" + o; return i && (o = o.substr(o.length - e)), s + o } function Rl(t, e, n = 0, i = !1, r = !1) { return function (s, o) { let l = function (t, e) { switch (t) { case Pl.FullYear: return e.getFullYear(); case Pl.Month: return e.getMonth(); case Pl.Date: return e.getDate(); case Pl.Hours: return e.getHours(); case Pl.Minutes: return e.getMinutes(); case Pl.Seconds: return e.getSeconds(); case Pl.FractionalSeconds: return e.getMilliseconds(); case Pl.Day: return e.getDay(); default: throw new Error(`Unknown DateType value "${t}".`) } }(t, s); if ((n > 0 || l > -n) && (l += n), t === Pl.Hours) 0 === l && -12 === n && (l = 12); else if (t === Pl.FractionalSeconds) return a = e, Al(l, 3).substr(0, a); var a; const c = bl(o, gl.MinusSign); return Al(l, e, c, i, r) } } function Nl(t, e, n = pl.Format, i = !1) { return function (r, s) { return function (t, e, n, i, r, s) { switch (n) { case Ol.Months: return function (t, e, n) { const i = _r(t), r = Cl([i[fr.MonthsFormat], i[fr.MonthsStandalone]], e); return Cl(r, n) }(e, r, i)[t.getMonth()]; case Ol.Days: return function (t, e, n) { const i = _r(t), r = Cl([i[fr.DaysFormat], i[fr.DaysStandalone]], e); return Cl(r, n) }(e, r, i)[t.getDay()]; case Ol.DayPeriods: const o = t.getHours(), l = t.getMinutes(); if (s) { const t = function (t) { const e = _r(t); return wl(e), (e[fr.ExtraData][2] || []).map(t => "string" == typeof t ? Sl(t) : [Sl(t[0]), Sl(t[1])]) }(e), n = function (t, e, n) { const i = _r(t); wl(i); const r = Cl([i[fr.ExtraData][0], i[fr.ExtraData][1]], e) || []; return Cl(r, n) || [] }(e, r, i); let s; if (t.forEach((t, e) => { if (Array.isArray(t)) { const { hours: i, minutes: r } = t[0], { hours: a, minutes: c } = t[1]; o >= i && l >= r && (o < a || o === a && l < c) && (s = n[e]) } else { const { hours: i, minutes: r } = t; i === o && r === l && (s = n[e]) } }), s) return s } return function (t, e, n) { const i = _r(t), r = Cl([i[fr.DayPeriodsFormat], i[fr.DayPeriodsStandalone]], e); return Cl(r, n) }(e, r, i)[o < 12 ? 0 : 1]; case Ol.Eras: return function (t, e) { return Cl(_r(t)[fr.Eras], e) }(e, i)[t.getFullYear() <= 0 ? 0 : 1]; default: throw new Error("unexpected translation type " + n) } }(r, s, t, e, n, i) } } function Ml(t) { return function (e, n, i) { const r = -1 * i, s = bl(n, gl.MinusSign), o = r > 0 ? Math.floor(r / 60) : Math.ceil(r / 60); switch (t) { case kl.Short: return (r >= 0 ? "+" : "") + Al(o, 2, s) + Al(Math.abs(r % 60), 2, s); case kl.ShortGMT: return "GMT" + (r >= 0 ? "+" : "") + Al(o, 1, s); case kl.Long: return "GMT" + (r >= 0 ? "+" : "") + Al(o, 2, s) + ":" + Al(Math.abs(r % 60), 2, s); case kl.Extended: return 0 === i ? "Z" : (r >= 0 ? "+" : "") + Al(o, 2, s) + ":" + Al(Math.abs(r % 60), 2, s); default: throw new Error(`Unknown zone width "${t}"`) } } } function Dl(t, e = !1) { return function (n, i) { let r; if (e) { const t = new Date(n.getFullYear(), n.getMonth(), 1).getDay() - 1, e = n.getDate(); r = 1 + Math.floor((e + t) / 7) } else { const t = function (t) { const e = new Date(t, 0, 1).getDay(); return new Date(t, 0, 1 + (e <= 4 ? 4 : 11) - e) }(n.getFullYear()), e = (s = n, new Date(s.getFullYear(), s.getMonth(), s.getDate() + (4 - s.getDay()))).getTime() - t.getTime(); r = 1 + Math.round(e / 6048e5) } var s; return Al(r, t, bl(i, gl.MinusSign)) } } const Fl = {}; function Ll(t, e) { t = t.replace(/:/g, ""); const n = Date.parse("Jan 01, 1970 00:00:00 " + t) / 6e4; return isNaN(n) ? e : n } function Vl(t) { return t instanceof Date && !isNaN(t.valueOf()) } const zl = new Tt("UseV4Plurals"); class jl { } let Ul = (() => class extends jl { constructor(t, e) { super(), this.locale = t, this.deprecatedPluralFn = e } getPluralCategory(t, e) { switch (this.deprecatedPluralFn ? this.deprecatedPluralFn(e || this.locale, t) : function (t) { return _r(t)[fr.PluralCase] }(e || this.locale)(t)) { case dl.Zero: return "zero"; case dl.One: return "one"; case dl.Two: return "two"; case dl.Few: return "few"; case dl.Many: return "many"; default: return "other" } } })(); function Hl(t, e) { e = encodeURIComponent(e); for (const n of t.split(";")) { const t = n.indexOf("="), [i, r] = -1 == t ? [n, ""] : [n.slice(0, t), n.slice(t + 1)]; if (i.trim() === e) return decodeURIComponent(r) } return null } class Bl { constructor(t, e, n, i) { this.$implicit = t, this.ngForOf = e, this.index = n, this.count = i } get first() { return 0 === this.index } get last() { return this.index === this.count - 1 } get even() { return this.index % 2 == 0 } get odd() { return !this.even } } let $l = (() => class { constructor(t, e, n) { this._viewContainer = t, this._template = e, this._differs = n, this._ngForOfDirty = !0, this._differ = null } set ngForOf(t) { this._ngForOf = t, this._ngForOfDirty = !0 } set ngForTrackBy(t) { Yt() && null != t && "function" != typeof t && console && console.warn && console.warn(`trackBy must be a function, but received ${JSON.stringify(t)}. See https://angular.io/docs/ts/latest/api/common/index/NgFor-directive.html#!#change-propagation for more information.`), this._trackByFn = t } get ngForTrackBy() { return this._trackByFn } set ngForTemplate(t) { t && (this._template = t) } ngDoCheck() { if (this._ngForOfDirty) { this._ngForOfDirty = !1; const n = this._ngForOf; if (!this._differ && n) try { this._differ = this._differs.find(n).create(this.ngForTrackBy) } catch (e) { throw new Error(`Cannot find a differ supporting object '${n}' of type '${t = n, t.name || typeof t}'. NgFor only supports binding to Iterables such as Arrays.`) } } var t; if (this._differ) { const t = this._differ.diff(this._ngForOf); t && this._applyChanges(t) } } _applyChanges(t) { const e = []; t.forEachOperation((t, n, i) => { if (null == t.previousIndex) { const n = this._viewContainer.createEmbeddedView(this._template, new Bl(null, this._ngForOf, -1, -1), i), r = new Wl(t, n); e.push(r) } else if (null == i) this._viewContainer.remove(n); else { const r = this._viewContainer.get(n); this._viewContainer.move(r, i); const s = new Wl(t, r); e.push(s) } }); for (let n = 0; n < e.length; n++)this._perViewChange(e[n].view, e[n].record); for (let n = 0, i = this._viewContainer.length; n < i; n++) { const t = this._viewContainer.get(n); t.context.index = n, t.context.count = i, t.context.ngForOf = this._ngForOf } t.forEachIdentityChange(t => { this._viewContainer.get(t.currentIndex).context.$implicit = t.item }) } _perViewChange(t, e) { t.context.$implicit = e.item } static ngTemplateContextGuard(t, e) { return !0 } })(); class Wl { constructor(t, e) { this.record = t, this.view = e } } let ql = (() => class { constructor(t, e) { this._viewContainer = t, this._context = new Gl, this._thenTemplateRef = null, this._elseTemplateRef = null, this._thenViewRef = null, this._elseViewRef = null, this._thenTemplateRef = e } set ngIf(t) { this._context.$implicit = this._context.ngIf = t, this._updateView() } set ngIfThen(t) { Zl("ngIfThen", t), this._thenTemplateRef = t, this._thenViewRef = null, this._updateView() } set ngIfElse(t) { Zl("ngIfElse", t), this._elseTemplateRef = t, this._elseViewRef = null, this._updateView() } _updateView() { this._context.$implicit ? this._thenViewRef || (this._viewContainer.clear(), this._elseViewRef = null, this._thenTemplateRef && (this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context))) : this._elseViewRef || (this._viewContainer.clear(), this._thenViewRef = null, this._elseTemplateRef && (this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context))) } })(); class Gl { constructor() { this.$implicit = null, this.ngIf = null } } function Zl(t, e) { if (e && !e.createEmbeddedView) throw new Error(`${t} must be a TemplateRef, but received '${_t(e)}'.`) } class Ql { constructor(t, e) { this._viewContainerRef = t, this._templateRef = e, this._created = !1 } create() { this._created = !0, this._viewContainerRef.createEmbeddedView(this._templateRef) } destroy() { this._created = !1, this._viewContainerRef.clear() } enforceState(t) { t && !this._created ? this.create() : !t && this._created && this.destroy() } } let Kl = (() => class { constructor() { this._defaultUsed = !1, this._caseCount = 0, this._lastCaseCheckIndex = 0, this._lastCasesMatched = !1 } set ngSwitch(t) { this._ngSwitch = t, 0 === this._caseCount && this._updateDefaultCases(!0) } _addCase() { return this._caseCount++ } _addDefault(t) { this._defaultViews || (this._defaultViews = []), this._defaultViews.push(t) } _matchCase(t) { const e = t == this._ngSwitch; return this._lastCasesMatched = this._lastCasesMatched || e, this._lastCaseCheckIndex++, this._lastCaseCheckIndex === this._caseCount && (this._updateDefaultCases(!this._lastCasesMatched), this._lastCaseCheckIndex = 0, this._lastCasesMatched = !1), e } _updateDefaultCases(t) { if (this._defaultViews && t !== this._defaultUsed) { this._defaultUsed = t; for (let e = 0; e < this._defaultViews.length; e++)this._defaultViews[e].enforceState(t) } } })(), Yl = (() => class { constructor(t, e, n) { this.ngSwitch = n, n._addCase(), this._view = new Ql(t, e) } ngDoCheck() { this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase)) } })(), Xl = (() => { class t { constructor(t) { this.locale = t } transform(e, n = "mediumDate", i, r) { if (null == e || "" === e || e != e) return null; try { return function (t, e, n, i) { let r = function (t) { if (Vl(t)) return t; if ("number" == typeof t && !isNaN(t)) return new Date(t); if ("string" == typeof t) { t = t.trim(); const e = parseFloat(t); if (!isNaN(t - e)) return new Date(e); if (/^(\d{4}-\d{1,2}-\d{1,2})$/.test(t)) { const [e, n, i] = t.split("-").map(t => +t); return new Date(e, n - 1, i) } let n; if (n = t.match(El)) return function (t) { const e = new Date(0); let n = 0, i = 0; const r = t[8] ? e.setUTCFullYear : e.setFullYear, s = t[8] ? e.setUTCHours : e.setHours; t[9] && (n = Number(t[9] + t[10]), i = Number(t[9] + t[11])), r.call(e, Number(t[1]), Number(t[2]) - 1, Number(t[3])); const o = Number(t[4] || 0) - n, l = Number(t[5] || 0) - i, a = Number(t[6] || 0), c = Math.round(1e3 * parseFloat("0." + (t[7] || 0))); return s.call(e, o, l, a, c), e }(n) } const e = new Date(t); if (!Vl(e)) throw new Error(`Unable to convert "${t}" into a date`); return e }(t); e = function t(e, n) { const i = function (t) { return _r(t)[fr.LocaleId] }(e); if (xl[i] = xl[i] || {}, xl[i][n]) return xl[i][n]; let r = ""; switch (n) { case "shortDate": r = _l(e, ml.Short); break; case "mediumDate": r = _l(e, ml.Medium); break; case "longDate": r = _l(e, ml.Long); break; case "fullDate": r = _l(e, ml.Full); break; case "shortTime": r = yl(e, ml.Short); break; case "mediumTime": r = yl(e, ml.Medium); break; case "longTime": r = yl(e, ml.Long); break; case "fullTime": r = yl(e, ml.Full); break; case "short": const n = t(e, "shortTime"), i = t(e, "shortDate"); r = Il(vl(e, ml.Short), [n, i]); break; case "medium": const s = t(e, "mediumTime"), o = t(e, "mediumDate"); r = Il(vl(e, ml.Medium), [s, o]); break; case "long": const l = t(e, "longTime"), a = t(e, "longDate"); r = Il(vl(e, ml.Long), [l, a]); break; case "full": const c = t(e, "fullTime"), u = t(e, "fullDate"); r = Il(vl(e, ml.Full), [c, u]) }return r && (xl[i][n] = r), r }(n, e) || e; let s, o = []; for (; e;) { if (s = Tl.exec(e), !s) { o.push(e); break } { o = o.concat(s.slice(1)); const t = o.pop(); if (!t) break; e = t } } let l = r.getTimezoneOffset(); i && (l = Ll(i, l), r = function (t, e, n) { const i = t.getTimezoneOffset(); return function (t, e) { return (t = new Date(t.getTime())).setMinutes(t.getMinutes() + e), t }(t, -1 * (Ll(e, i) - i)) }(r, i)); let a = ""; return o.forEach(t => { const e = function (t) { if (Fl[t]) return Fl[t]; let e; switch (t) { case "G": case "GG": case "GGG": e = Nl(Ol.Eras, fl.Abbreviated); break; case "GGGG": e = Nl(Ol.Eras, fl.Wide); break; case "GGGGG": e = Nl(Ol.Eras, fl.Narrow); break; case "y": e = Rl(Pl.FullYear, 1, 0, !1, !0); break; case "yy": e = Rl(Pl.FullYear, 2, 0, !0, !0); break; case "yyy": e = Rl(Pl.FullYear, 3, 0, !1, !0); break; case "yyyy": e = Rl(Pl.FullYear, 4, 0, !1, !0); break; case "M": case "L": e = Rl(Pl.Month, 1, 1); break; case "MM": case "LL": e = Rl(Pl.Month, 2, 1); break; case "MMM": e = Nl(Ol.Months, fl.Abbreviated); break; case "MMMM": e = Nl(Ol.Months, fl.Wide); break; case "MMMMM": e = Nl(Ol.Months, fl.Narrow); break; case "LLL": e = Nl(Ol.Months, fl.Abbreviated, pl.Standalone); break; case "LLLL": e = Nl(Ol.Months, fl.Wide, pl.Standalone); break; case "LLLLL": e = Nl(Ol.Months, fl.Narrow, pl.Standalone); break; case "w": e = Dl(1); break; case "ww": e = Dl(2); break; case "W": e = Dl(1, !0); break; case "d": e = Rl(Pl.Date, 1); break; case "dd": e = Rl(Pl.Date, 2); break; case "E": case "EE": case "EEE": e = Nl(Ol.Days, fl.Abbreviated); break; case "EEEE": e = Nl(Ol.Days, fl.Wide); break; case "EEEEE": e = Nl(Ol.Days, fl.Narrow); break; case "EEEEEE": e = Nl(Ol.Days, fl.Short); break; case "a": case "aa": case "aaa": e = Nl(Ol.DayPeriods, fl.Abbreviated); break; case "aaaa": e = Nl(Ol.DayPeriods, fl.Wide); break; case "aaaaa": e = Nl(Ol.DayPeriods, fl.Narrow); break; case "b": case "bb": case "bbb": e = Nl(Ol.DayPeriods, fl.Abbreviated, pl.Standalone, !0); break; case "bbbb": e = Nl(Ol.DayPeriods, fl.Wide, pl.Standalone, !0); break; case "bbbbb": e = Nl(Ol.DayPeriods, fl.Narrow, pl.Standalone, !0); break; case "B": case "BB": case "BBB": e = Nl(Ol.DayPeriods, fl.Abbreviated, pl.Format, !0); break; case "BBBB": e = Nl(Ol.DayPeriods, fl.Wide, pl.Format, !0); break; case "BBBBB": e = Nl(Ol.DayPeriods, fl.Narrow, pl.Format, !0); break; case "h": e = Rl(Pl.Hours, 1, -12); break; case "hh": e = Rl(Pl.Hours, 2, -12); break; case "H": e = Rl(Pl.Hours, 1); break; case "HH": e = Rl(Pl.Hours, 2); break; case "m": e = Rl(Pl.Minutes, 1); break; case "mm": e = Rl(Pl.Minutes, 2); break; case "s": e = Rl(Pl.Seconds, 1); break; case "ss": e = Rl(Pl.Seconds, 2); break; case "S": e = Rl(Pl.FractionalSeconds, 1); break; case "SS": e = Rl(Pl.FractionalSeconds, 2); break; case "SSS": e = Rl(Pl.FractionalSeconds, 3); break; case "Z": case "ZZ": case "ZZZ": e = Ml(kl.Short); break; case "ZZZZZ": e = Ml(kl.Extended); break; case "O": case "OO": case "OOO": case "z": case "zz": case "zzz": e = Ml(kl.ShortGMT); break; case "OOOO": case "ZZZZ": case "zzzz": e = Ml(kl.Long); break; default: return null }return Fl[t] = e, e }(t); a += e ? e(r, n, l) : "''" === t ? "'" : t.replace(/(^'|'$)/g, "").replace(/''/g, "'") }), a }(e, n, r || this.locale, i) } catch (s) { throw function (t, e) { return Error(`InvalidPipeArgument: '${e}' for pipe '${_t(t)}'`) }(t, s.message) } } } return t })(), Jl = (() => class { })(); const ta = new Tt("DocumentToken"); let ea = (() => { class t { } return t.ngInjectableDef = ft({ token: t, providedIn: "root", factory: () => new na(Nt(ta), window, Nt(Te)) }), t })(); class na { constructor(t, e, n) { this.document = t, this.window = e, this.errorHandler = n, this.offset = () => [0, 0] } setOffset(t) { this.offset = Array.isArray(t) ? () => t : t } getScrollPosition() { return this.supportScrollRestoration() ? [this.window.scrollX, this.window.scrollY] : [0, 0] } scrollToPosition(t) { this.supportScrollRestoration() && this.window.scrollTo(t[0], t[1]) } scrollToAnchor(t) { if (this.supportScrollRestoration()) { t = this.window.CSS && this.window.CSS.escape ? this.window.CSS.escape(t) : t.replace(/(\"|\'\ |:|\.|\[|\]|,|=)/g, "\\$1"); try { const e = this.document.querySelector("#" + t); if (e) return void this.scrollToElement(e); const n = this.document.querySelector(`[name='${t}']`); if (n) return void this.scrollToElement(n) } catch (e) { this.errorHandler.handleError(e) } } } setHistoryScrollRestoration(t) { if (this.supportScrollRestoration()) { const e = this.window.history; e && e.scrollRestoration && (e.scrollRestoration = t) } } scrollToElement(t) { const e = t.getBoundingClientRect(), n = e.left + this.window.pageXOffset, i = e.top + this.window.pageYOffset, r = this.offset(); this.window.scrollTo(n - r[0], i - r[1]) } supportScrollRestoration() { try { return !!this.window && !!this.window.scrollTo } catch (t) { return !1 } } } const ia = new w(t => t.complete()); function ra(t) { return t ? function (t) { return new w(e => t.schedule(() => e.complete())) }(t) : ia } function sa(t) { const e = new w(e => { e.next(t), e.complete() }); return e._isScalar = !0, e.value = t, e } function oa(...t) { let e = t[t.length - 1]; switch (O(e) ? t.pop() : e = void 0, t.length) { case 0: return ra(e); case 1: return e ? W(t, e) : sa(t[0]); default: return W(t, e) } } class la extends k { constructor(t) { super(), this._value = t } get value() { return this.getValue() } _subscribe(t) { const e = super._subscribe(t); return e && !e.closed && t.next(this._value), e } getValue() { if (this.hasError) throw this.thrownError; if (this.closed) throw new E; return this._value } next(t) { super.next(this._value = t) } } function aa() { return Error.call(this), this.message = "no elements in sequence", this.name = "EmptyError", this } aa.prototype = Object.create(Error.prototype); const ca = aa, ua = {}; class ha { constructor(t) { this.resultSelector = t } call(t, e) { return e.subscribe(new da(t, this.resultSelector)) } } class da extends U { constructor(t, e) { super(t), this.resultSelector = e, this.active = 0, this.values = [], this.observables = [] } _next(t) { this.values.push(ua), this.observables.push(t) } _complete() { const t = this.observables, e = t.length; if (0 === e) this.destination.complete(); else { this.active = e, this.toRespond = e; for (let n = 0; n < e; n++) { const e = t[n]; this.add(j(this, e, e, n)) } } } notifyComplete(t) { 0 == (this.active -= 1) && this.destination.complete() } notifyNext(t, e, n, i, r) { const s = this.values, o = this.toRespond ? s[n] === ua ? --this.toRespond : this.toRespond : 0; s[n] = e, 0 === o && (this.resultSelector ? this._tryResultSelector(s) : this.destination.next(s.slice())) } _tryResultSelector(t) { let e; try { e = this.resultSelector.apply(this, t) } catch (n) { return void this.destination.error(n) } this.destination.next(e) } } function pa(t) { return new w(e => { let n; try { n = t() } catch (i) { return void e.error(i) } return (n ? q(n) : ra()).subscribe(e) }) } function fa() { return Y(1) } function ma(t, e) { return function (n) { return n.lift(new ga(t, e)) } } class ga { constructor(t, e) { this.predicate = t, this.thisArg = e } call(t, e) { return e.subscribe(new _a(t, this.predicate, this.thisArg)) } } class _a extends m { constructor(t, e, n) { super(t), this.predicate = e, this.thisArg = n, this.count = 0 } _next(t) { let e; try { e = this.predicate.call(this.thisArg, t, this.count++) } catch (n) { return void this.destination.error(n) } e && this.destination.next(t) } } function ya() { return Error.call(this), this.message = "argument out of range", this.name = "ArgumentOutOfRangeError", this } ya.prototype = Object.create(Error.prototype); const va = ya; function ba(t) { return function (e) { return 0 === t ? ra() : e.lift(new wa(t)) } } class wa { constructor(t) { if (this.total = t, this.total < 0) throw new va } call(t, e) { return e.subscribe(new Ca(t, this.total)) } } class Ca extends m { constructor(t, e) { super(t), this.total = e, this.ring = new Array, this.count = 0 } _next(t) { const e = this.ring, n = this.total, i = this.count++; e.length < n ? e.push(t) : e[i % n] = t } _complete() { const t = this.destination; let e = this.count; if (e > 0) { const n = this.count >= this.total ? this.total : this.count, i = this.ring; for (let r = 0; r < n; r++) { const r = e++ % n; t.next(i[r]) } } t.complete() } } function Sa(t, e, n) { return function (i) { return i.lift(new Ea(t, e, n)) } } class Ea { constructor(t, e, n) { this.nextOrObserver = t, this.error = e, this.complete = n } call(t, e) { return e.subscribe(new xa(t, this.nextOrObserver, this.error, this.complete)) } } class xa extends m { constructor(t, e, n, r) { super(t), this._tapNext = y, this._tapError = y, this._tapComplete = y, this._tapError = n || y, this._tapComplete = r || y, i(e) ? (this._context = this, this._tapNext = e) : e && (this._context = e, this._tapNext = e.next || y, this._tapError = e.error || y, this._tapComplete = e.complete || y) } _next(t) { try { this._tapNext.call(this._context, t) } catch (e) { return void this.destination.error(e) } this.destination.next(t) } _error(t) { try { this._tapError.call(this._context, t) } catch (t) { return void this.destination.error(t) } this.destination.error(t) } _complete() { try { this._tapComplete.call(this._context) } catch (t) { return void this.destination.error(t) } return this.destination.complete() } } const Ta = (t = ka) => Sa({ hasValue: !1, next() { this.hasValue = !0 }, complete() { if (!this.hasValue) throw t() } }); function ka() { return new ca } function Pa(t = null) { return e => e.lift(new Oa(t)) } class Oa { constructor(t) { this.defaultValue = t } call(t, e) { return e.subscribe(new Ia(t, this.defaultValue)) } } class Ia extends m { constructor(t, e) { super(t), this.defaultValue = e, this.isEmpty = !0 } _next(t) { this.isEmpty = !1, this.destination.next(t) } _complete() { this.isEmpty && this.destination.next(this.defaultValue), this.destination.complete() } } function Aa(t, e) { const n = arguments.length >= 2; return i => i.pipe(t ? ma((e, n) => t(e, n, i)) : K, ba(1), n ? Pa(e) : Ta(() => new ca)) } function Ra(t) { return function (e) { const n = new Na(t), i = e.lift(n); return n.caught = i } } class Na { constructor(t) { this.selector = t } call(t, e) { return e.subscribe(new Ma(t, this.selector, this.caught)) } } class Ma extends U { constructor(t, e, n) { super(t), this.selector = e, this.caught = n } error(t) { if (!this.isStopped) { let n; try { n = this.selector(t, this.caught) } catch (e) { return void super.error(e) } this._unsubscribeAndRecycle(); const i = new I(this, void 0, void 0); this.add(i), j(this, n, void 0, void 0, i) } } } function Da(t) { return e => 0 === t ? ra() : e.lift(new Fa(t)) } class Fa { constructor(t) { if (this.total = t, this.total < 0) throw new va } call(t, e) { return e.subscribe(new La(t, this.total)) } } class La extends m { constructor(t, e) { super(t), this.total = e, this.count = 0 } _next(t) { const e = this.total, n = ++this.count; n <= e && (this.destination.next(t), n === e && (this.destination.complete(), this.unsubscribe())) } } function Va(t, e) { const n = arguments.length >= 2; return i => i.pipe(t ? ma((e, n) => t(e, n, i)) : K, Da(1), n ? Pa(e) : Ta(() => new ca)) } class za { constructor(t, e, n) { this.predicate = t, this.thisArg = e, this.source = n } call(t, e) { return e.subscribe(new ja(t, this.predicate, this.thisArg, this.source)) } } class ja extends m { constructor(t, e, n, i) { super(t), this.predicate = e, this.thisArg = n, this.source = i, this.index = 0, this.thisArg = n || this } notifyComplete(t) { this.destination.next(t), this.destination.complete() } _next(t) { let e = !1; try { e = this.predicate.call(this.thisArg, t, this.index++, this.source) } catch (n) { return void this.destination.error(n) } e || this.notifyComplete(!1) } _complete() { this.notifyComplete(!0) } } function Ua(t, e) { return "function" == typeof e ? n => n.pipe(Ua((n, i) => q(t(n, i)).pipe(H((t, r) => e(n, t, i, r))))) : e => e.lift(new Ha(t)) } class Ha { constructor(t) { this.project = t } call(t, e) { return e.subscribe(new Ba(t, this.project)) } } class Ba extends U { constructor(t, e) { super(t), this.project = e, this.index = 0 } _next(t) { let e; const n = this.index++; try { e = this.project(t, n) } catch (i) { return void this.destination.error(i) } this._innerSub(e, t, n) } _innerSub(t, e, n) { const i = this.innerSubscription; i && i.unsubscribe(); const r = new I(this, void 0, void 0); this.destination.add(r), this.innerSubscription = j(this, t, e, n, r) } _complete() { const { innerSubscription: t } = this; t && !t.closed || super._complete(), this.unsubscribe() } _unsubscribe() { this.innerSubscription = null } notifyComplete(t) { this.destination.remove(t), this.innerSubscription = null, this.isStopped && super._complete() } notifyNext(t, e, n, i, r) { this.destination.next(e) } } function $a(...t) { return e => { let n = t[t.length - 1]; O(n) ? t.pop() : n = null; const i = t.length; return function (...t) { return fa()(oa(...t)) }(1 !== i || n ? i > 0 ? W(t, n) : ra(n) : sa(t[0]), e) } } function Wa(t, e) { let n = !1; return arguments.length >= 2 && (n = !0), function (i) { return i.lift(new qa(t, e, n)) } } class qa { constructor(t, e, n = !1) { this.accumulator = t, this.seed = e, this.hasSeed = n } call(t, e) { return e.subscribe(new Ga(t, this.accumulator, this.seed, this.hasSeed)) } } class Ga extends m { constructor(t, e, n, i) { super(t), this.accumulator = e, this._seed = n, this.hasSeed = i, this.index = 0 } get seed() { return this._seed } set seed(t) { this.hasSeed = !0, this._seed = t } _next(t) { if (this.hasSeed) return this._tryNext(t); this.seed = t, this.destination.next(t) } _tryNext(t) { const e = this.index++; let n; try { n = this.accumulator(this.seed, t, e) } catch (i) { this.destination.error(i) } this.seed = n, this.destination.next(n) } } function Za(t, e) { return G(t, e, 1) } function Qa(t) { return e => e.lift(new Ka(t)) } class Ka { constructor(t) { this.callback = t } call(t, e) { return e.subscribe(new Ya(t, this.callback)) } } class Ya extends m { constructor(t, e) { super(t), this.add(new d(e)) } } let Xa = null; function Ja() { return Xa } const tc = { class: "className", innerHtml: "innerHTML", readonly: "readOnly", tabindex: "tabIndex" }, ec = { "\b": "Backspace", "\t": "Tab", "\x7f": "Delete", "\x1b": "Escape", Del: "Delete", Esc: "Escape", Left: "ArrowLeft", Right: "ArrowRight", Up: "ArrowUp", Down: "ArrowDown", Menu: "ContextMenu", Scroll: "ScrollLock", Win: "OS" }, nc = { A: "1", B: "2", C: "3", D: "4", E: "5", F: "6", G: "7", H: "8", I: "9", J: "*", K: "+", M: "-", N: ".", O: "/", "`": "0", "\x90": "NumLock" }, ic = (() => { if (xt.Node) return xt.Node.prototype.contains || function (t) { return !!(16 & this.compareDocumentPosition(t)) } })(); class rc extends class extends class { constructor() { this.resourceLoaderType = null } get attrToPropMap() { return this._attrToPropMap } set attrToPropMap(t) { this._attrToPropMap = t } }{ constructor() { super(), this._animationPrefix = null, this._transitionEnd = null; try { const t = this.createElement("div", document); if (null != this.getStyle(t, "animationName")) this._animationPrefix = ""; else { const e = ["Webkit", "Moz", "O", "ms"]; for (let n = 0; n < e.length; n++)if (null != this.getStyle(t, e[n] + "AnimationName")) { this._animationPrefix = "-" + e[n].toLowerCase() + "-"; break } } const e = { WebkitTransition: "webkitTransitionEnd", MozTransition: "transitionend", OTransition: "oTransitionEnd otransitionend", transition: "transitionend" }; Object.keys(e).forEach(n => { null != this.getStyle(t, n) && (this._transitionEnd = e[n]) }) } catch (t) { this._animationPrefix = null, this._transitionEnd = null } } getDistributedNodes(t) { return t.getDistributedNodes() } resolveAndSetHref(t, e, n) { t.href = null == n ? e : e + "/../" + n } supportsDOMEvents() { return !0 } supportsNativeShadowDOM() { return "function" == typeof document.body.createShadowRoot } getAnimationPrefix() { return this._animationPrefix ? this._animationPrefix : "" } getTransitionEnd() { return this._transitionEnd ? this._transitionEnd : "" } supportsAnimation() { return null != this._animationPrefix && null != this._transitionEnd } }{ parse(t) { throw new Error("parse not implemented") } static makeCurrent() { var t; t = new rc, Xa || (Xa = t) } hasProperty(t, e) { return e in t } setProperty(t, e, n) { t[e] = n } getProperty(t, e) { return t[e] } invoke(t, e, n) { t[e](...n) } logError(t) { window.console && (console.error ? console.error(t) : console.log(t)) } log(t) { window.console && window.console.log && window.console.log(t) } logGroup(t) { window.console && window.console.group && window.console.group(t) } logGroupEnd() { window.console && window.console.groupEnd && window.console.groupEnd() } get attrToPropMap() { return tc } contains(t, e) { return ic.call(t, e) } querySelector(t, e) { return t.querySelector(e) } querySelectorAll(t, e) { return t.querySelectorAll(e) } on(t, e, n) { t.addEventListener(e, n, !1) } onAndCancel(t, e, n) { return t.addEventListener(e, n, !1), () => { t.removeEventListener(e, n, !1) } } dispatchEvent(t, e) { t.dispatchEvent(e) } createMouseEvent(t) { const e = this.getDefaultDocument().createEvent("MouseEvent"); return e.initEvent(t, !0, !0), e } createEvent(t) { const e = this.getDefaultDocument().createEvent("Event"); return e.initEvent(t, !0, !0), e } preventDefault(t) { t.preventDefault(), t.returnValue = !1 } isPrevented(t) { return t.defaultPrevented || null != t.returnValue && !t.returnValue } getInnerHTML(t) { return t.innerHTML } getTemplateContent(t) { return "content" in t && this.isTemplateElement(t) ? t.content : null } getOuterHTML(t) { return t.outerHTML } nodeName(t) { return t.nodeName } nodeValue(t) { return t.nodeValue } type(t) { return t.type } content(t) { return this.hasProperty(t, "content") ? t.content : t } firstChild(t) { return t.firstChild } nextSibling(t) { return t.nextSibling } parentElement(t) { return t.parentNode } childNodes(t) { return t.childNodes } childNodesAsList(t) { const e = t.childNodes, n = new Array(e.length); for (let i = 0; i < e.length; i++)n[i] = e[i]; return n } clearNodes(t) { for (; t.firstChild;)t.removeChild(t.firstChild) } appendChild(t, e) { t.appendChild(e) } removeChild(t, e) { t.removeChild(e) } replaceChild(t, e, n) { t.replaceChild(e, n) } remove(t) { return t.parentNode && t.parentNode.removeChild(t), t } insertBefore(t, e, n) { t.insertBefore(n, e) } insertAllBefore(t, e, n) { n.forEach(n => t.insertBefore(n, e)) } insertAfter(t, e, n) { t.insertBefore(n, e.nextSibling) } setInnerHTML(t, e) { t.innerHTML = e } getText(t) { return t.textContent } setText(t, e) { t.textContent = e } getValue(t) { return t.value } setValue(t, e) { t.value = e } getChecked(t) { return t.checked } setChecked(t, e) { t.checked = e } createComment(t) { return this.getDefaultDocument().createComment(t) } createTemplate(t) { const e = this.getDefaultDocument().createElement("template"); return e.innerHTML = t, e } createElement(t, e) { return (e = e || this.getDefaultDocument()).createElement(t) } createElementNS(t, e, n) { return (n = n || this.getDefaultDocument()).createElementNS(t, e) } createTextNode(t, e) { return (e = e || this.getDefaultDocument()).createTextNode(t) } createScriptTag(t, e, n) { const i = (n = n || this.getDefaultDocument()).createElement("SCRIPT"); return i.setAttribute(t, e), i } createStyleElement(t, e) { const n = (e = e || this.getDefaultDocument()).createElement("style"); return this.appendChild(n, this.createTextNode(t, e)), n } createShadowRoot(t) { return t.createShadowRoot() } getShadowRoot(t) { return t.shadowRoot } getHost(t) { return t.host } clone(t) { return t.cloneNode(!0) } getElementsByClassName(t, e) { return t.getElementsByClassName(e) } getElementsByTagName(t, e) { return t.getElementsByTagName(e) } classList(t) { return Array.prototype.slice.call(t.classList, 0) } addClass(t, e) { t.classList.add(e) } removeClass(t, e) { t.classList.remove(e) } hasClass(t, e) { return t.classList.contains(e) } setStyle(t, e, n) { t.style[e] = n } removeStyle(t, e) { t.style[e] = "" } getStyle(t, e) { return t.style[e] } hasStyle(t, e, n) { const i = this.getStyle(t, e) || ""; return n ? i == n : i.length > 0 } tagName(t) { return t.tagName } attributeMap(t) { const e = new Map, n = t.attributes; for (let i = 0; i < n.length; i++) { const t = n.item(i); e.set(t.name, t.value) } return e } hasAttribute(t, e) { return t.hasAttribute(e) } hasAttributeNS(t, e, n) { return t.hasAttributeNS(e, n) } getAttribute(t, e) { return t.getAttribute(e) } getAttributeNS(t, e, n) { return t.getAttributeNS(e, n) } setAttribute(t, e, n) { t.setAttribute(e, n) } setAttributeNS(t, e, n, i) { t.setAttributeNS(e, n, i) } removeAttribute(t, e) { t.removeAttribute(e) } removeAttributeNS(t, e, n) { t.removeAttributeNS(e, n) } templateAwareRoot(t) { return this.isTemplateElement(t) ? this.content(t) : t } createHtmlDocument() { return document.implementation.createHTMLDocument("fakeTitle") } getDefaultDocument() { return document } getBoundingClientRect(t) { try { return t.getBoundingClientRect() } catch (e) { return { top: 0, bottom: 0, left: 0, right: 0, width: 0, height: 0 } } } getTitle(t) { return t.title } setTitle(t, e) { t.title = e || "" } elementMatches(t, e) { return !!this.isElementNode(t) && (t.matches && t.matches(e) || t.msMatchesSelector && t.msMatchesSelector(e) || t.webkitMatchesSelector && t.webkitMatchesSelector(e)) } isTemplateElement(t) { return this.isElementNode(t) && "TEMPLATE" === t.nodeName } isTextNode(t) { return t.nodeType === Node.TEXT_NODE } isCommentNode(t) { return t.nodeType === Node.COMMENT_NODE } isElementNode(t) { return t.nodeType === Node.ELEMENT_NODE } hasShadowRoot(t) { return null != t.shadowRoot && t instanceof HTMLElement } isShadowRoot(t) { return t instanceof DocumentFragment } importIntoDoc(t) { return document.importNode(this.templateAwareRoot(t), !0) } adoptNode(t) { return document.adoptNode(t) } getHref(t) { return t.getAttribute("href") } getEventKey(t) { let e = t.key; if (null == e) { if (e = t.keyIdentifier, null == e) return "Unidentified"; e.startsWith("U+") && (e = String.fromCharCode(parseInt(e.substring(2), 16)), 3 === t.location && nc.hasOwnProperty(e) && (e = nc[e])) } return ec[e] || e } getGlobalEventTarget(t, e) { return "window" === e ? window : "document" === e ? t : "body" === e ? t.body : null } getHistory() { return window.history } getLocation() { return window.location } getBaseHref(t) { const e = oc || (oc = document.querySelector("base"), oc) ? oc.getAttribute("href") : null; return null == e ? null : (n = e, sc || (sc = document.createElement("a")), sc.setAttribute("href", n), "/" === sc.pathname.charAt(0) ? sc.pathname : "/" + sc.pathname); var n } resetBaseElement() { oc = null } getUserAgent() { return window.navigator.userAgent } setData(t, e, n) { this.setAttribute(t, "data-" + e, n) } getData(t, e) { return this.getAttribute(t, "data-" + e) } getComputedStyle(t) { return getComputedStyle(t) } supportsWebAnimation() { return "function" == typeof Element.prototype.animate } performanceNow() { return window.performance && window.performance.now ? window.performance.now() : (new Date).getTime() } supportsCookies() { return !0 } getCookie(t) { return Hl(document.cookie, t) } setCookie(t, e) { document.cookie = encodeURIComponent(t) + "=" + encodeURIComponent(e) } } let sc, oc = null; function lc() { return !!window.history.pushState } let ac = (() => { class t extends rl { constructor(t) { super(), this._doc = t, this._init() } _init() { this.location = Ja().getLocation(), this._history = Ja().getHistory() } getBaseHrefFromDOM() { return Ja().getBaseHref(this._doc) } onPopState(t) { Ja().getGlobalEventTarget(this._doc, "window").addEventListener("popstate", t, !1) } onHashChange(t) { Ja().getGlobalEventTarget(this._doc, "window").addEventListener("hashchange", t, !1) } get href() { return this.location.href } get protocol() { return this.location.protocol } get hostname() { return this.location.hostname } get port() { return this.location.port } get pathname() { return this.location.pathname } get search() { return this.location.search } get hash() { return this.location.hash } set pathname(t) { this.location.pathname = t } pushState(t, e, n) { lc() ? this._history.pushState(t, e, n) : this.location.hash = n } replaceState(t, e, n) { lc() ? this._history.replaceState(t, e, n) : this.location.hash = n } forward() { this._history.forward() } back() { this._history.back() } getState() { return this._history.state } } return t.ctorParameters = () => [{ type: void 0, decorators: [{ type: at, args: [ta] }] }], t })(); const cc = new Tt("TRANSITION_ID"), uc = [{ provide: Cr, useFactory: function (t, e, n) { return () => { n.get(Sr).donePromise.then(() => { const n = Ja(); Array.prototype.slice.apply(n.querySelectorAll(e, "style[ng-transition]")).filter(e => n.getAttribute(e, "ng-transition") === t).forEach(t => n.remove(t)) }) } }, deps: [cc, ta, zt], multi: !0 }]; class hc { static init() { var t; t = new hc, ss = t } addToWindow(t) { xt.getAngularTestability = (e, n = !0) => { const i = t.findTestabilityInTree(e, n); if (null == i) throw new Error("Could not find testability for element."); return i }, xt.getAllAngularTestabilities = () => t.getAllTestabilities(), xt.getAllAngularRootElements = () => t.getAllRootElements(), xt.frameworkStabilizers || (xt.frameworkStabilizers = []), xt.frameworkStabilizers.push(t => { const e = xt.getAllAngularTestabilities(); let n = e.length, i = !1; const r = function (e) { i = i || e, n--, 0 == n && t(i) }; e.forEach((function (t) { t.whenStable(r) })) }) } findTestabilityInTree(t, e, n) { if (null == e) return null; const i = t.getTestability(e); return null != i ? i : n ? Ja().isShadowRoot(e) ? this.findTestabilityInTree(t, Ja().getHost(e), !0) : this.findTestabilityInTree(t, Ja().parentElement(e), !0) : null } } function dc(t, e) { "undefined" != typeof COMPILED && COMPILED || ((xt.ng = xt.ng || {})[t] = e) } const pc = (() => ({ ApplicationRef: ds, NgZone: Zr }))(); function fc(t) { return Ss(t) } const mc = new Tt("EventManagerPlugins"); let gc = (() => class { constructor(t, e) { this._zone = e, this._eventNameToPlugin = new Map, t.forEach(t => t.manager = this), this._plugins = t.slice().reverse() } addEventListener(t, e, n) { return this._findPluginFor(e).addEventListener(t, e, n) } addGlobalEventListener(t, e, n) { return this._findPluginFor(e).addGlobalEventListener(t, e, n) } getZone() { return this._zone } _findPluginFor(t) { const e = this._eventNameToPlugin.get(t); if (e) return e; const n = this._plugins; for (let i = 0; i < n.length; i++) { const e = n[i]; if (e.supports(t)) return this._eventNameToPlugin.set(t, e), e } throw new Error("No event manager plugin found for event " + t) } })(); class _c { constructor(t) { this._doc = t } addGlobalEventListener(t, e, n) { const i = Ja().getGlobalEventTarget(this._doc, t); if (!i) throw new Error(`Unsupported event target ${i} for event ${e}`); return this.addEventListener(i, e, n) } } let yc = (() => class { constructor() { this._stylesSet = new Set } addStyles(t) { const e = new Set; t.forEach(t => { this._stylesSet.has(t) || (this._stylesSet.add(t), e.add(t)) }), this.onStylesAdded(e) } onStylesAdded(t) { } getAllStyles() { return Array.from(this._stylesSet) } })(), vc = (() => class extends yc { constructor(t) { super(), this._doc = t, this._hostNodes = new Set, this._styleNodes = new Set, this._hostNodes.add(t.head) } _addStylesToHost(t, e) { t.forEach(t => { const n = this._doc.createElement("style"); n.textContent = t, this._styleNodes.add(e.appendChild(n)) }) } addHost(t) { this._addStylesToHost(this._stylesSet, t), this._hostNodes.add(t) } removeHost(t) { this._hostNodes.delete(t) } onStylesAdded(t) { this._hostNodes.forEach(e => this._addStylesToHost(t, e)) } ngOnDestroy() { this._styleNodes.forEach(t => Ja().remove(t)) } })(); const bc = { svg: "http://www.w3.org/2000/svg", xhtml: "http://www.w3.org/1999/xhtml", xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/" }, wc = /%COMP%/g; function Cc(t, e, n) { for (let i = 0; i < e.length; i++) { let r = e[i]; Array.isArray(r) ? Cc(t, r, n) : (r = r.replace(wc, t), n.push(r)) } return n } function Sc(t) { return e => { !1 === t(e) && (e.preventDefault(), e.returnValue = !1) } } let Ec = (() => class { constructor(t, e, n) { this.eventManager = t, this.sharedStylesHost = e, this.appId = n, this.rendererByCompId = new Map, this.defaultRenderer = new xc(t) } createRenderer(t, e) { if (!t || !e) return this.defaultRenderer; switch (e.encapsulation) { case Zt.Emulated: { let n = this.rendererByCompId.get(e.id); return n || (n = new Pc(this.eventManager, this.sharedStylesHost, e, this.appId), this.rendererByCompId.set(e.id, n)), n.applyToHost(t), n } case Zt.Native: case Zt.ShadowDom: return new Oc(this.eventManager, this.sharedStylesHost, t, e); default: if (!this.rendererByCompId.has(e.id)) { const t = Cc(e.id, e.styles, []); this.sharedStylesHost.addStyles(t), this.rendererByCompId.set(e.id, this.defaultRenderer) } return this.defaultRenderer } } begin() { } end() { } })(); class xc { constructor(t) { this.eventManager = t, this.data = Object.create(null) } destroy() { } createElement(t, e) { return e ? document.createElementNS(bc[e] || e, t) : document.createElement(t) } createComment(t) { return document.createComment(t) } createText(t) { return document.createTextNode(t) } appendChild(t, e) { t.appendChild(e) } insertBefore(t, e, n) { t && t.insertBefore(e, n) } removeChild(t, e) { t && t.removeChild(e) } selectRootElement(t, e) { let n = "string" == typeof t ? document.querySelector(t) : t; if (!n) throw new Error(`The selector "${t}" did not match any elements`); return e || (n.textContent = ""), n } parentNode(t) { return t.parentNode } nextSibling(t) { return t.nextSibling } setAttribute(t, e, n, i) { if (i) { e = i + ":" + e; const r = bc[i]; r ? t.setAttributeNS(r, e, n) : t.setAttribute(e, n) } else t.setAttribute(e, n) } removeAttribute(t, e, n) { if (n) { const i = bc[n]; i ? t.removeAttributeNS(i, e) : t.removeAttribute(`${n}:${e}`) } else t.removeAttribute(e) } addClass(t, e) { t.classList.add(e) } removeClass(t, e) { t.classList.remove(e) } setStyle(t, e, n, i) { i & Je.DashCase ? t.style.setProperty(e, n, i & Je.Important ? "important" : "") : t.style[e] = n } removeStyle(t, e, n) { n & Je.DashCase ? t.style.removeProperty(e) : t.style[e] = "" } setProperty(t, e, n) { kc(e, "property"), t[e] = n } setValue(t, e) { t.nodeValue = e } listen(t, e, n) { return kc(e, "listener"), "string" == typeof t ? this.eventManager.addGlobalEventListener(t, e, Sc(n)) : this.eventManager.addEventListener(t, e, Sc(n)) } } const Tc = (() => "@".charCodeAt(0))(); function kc(t, e) { if (t.charCodeAt(0) === Tc) throw new Error(`Found the synthetic ${e} ${t}. Please include either "BrowserAnimationsModule" or "NoopAnimationsModule" in your application.`) } class Pc extends xc { constructor(t, e, n, i) { super(t), this.component = n; const r = Cc(i + "-" + n.id, n.styles, []); e.addStyles(r), this.contentAttr = "_ngcontent-%COMP%".replace(wc, i + "-" + n.id), this.hostAttr = function (t) { return "_nghost-%COMP%".replace(wc, t) }(i + "-" + n.id) } applyToHost(t) { super.setAttribute(t, this.hostAttr, "") } createElement(t, e) { const n = super.createElement(t, e); return super.setAttribute(n, this.contentAttr, ""), n } } class Oc extends xc { constructor(t, e, n, i) { super(t), this.sharedStylesHost = e, this.hostEl = n, this.component = i, this.shadowRoot = i.encapsulation === Zt.ShadowDom ? n.attachShadow({ mode: "open" }) : n.createShadowRoot(), this.sharedStylesHost.addHost(this.shadowRoot); const r = Cc(i.id, i.styles, []); for (let s = 0; s < r.length; s++) { const t = document.createElement("style"); t.textContent = r[s], this.shadowRoot.appendChild(t) } } nodeOrShadowRoot(t) { return t === this.hostEl ? this.shadowRoot : t } destroy() { this.sharedStylesHost.removeHost(this.shadowRoot) } appendChild(t, e) { return super.appendChild(this.nodeOrShadowRoot(t), e) } insertBefore(t, e, n) { return super.insertBefore(this.nodeOrShadowRoot(t), e, n) } removeChild(t, e) { return super.removeChild(this.nodeOrShadowRoot(t), e) } parentNode(t) { return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t))) } } const Ic = (() => "undefined" != typeof Zone && Zone.__symbol__ || function (t) { return "__zone_symbol__" + t })(), Ac = Ic("addEventListener"), Rc = Ic("removeEventListener"), Nc = {}, Mc = "__zone_symbol__propagationStopped", Dc = (() => { const t = "undefined" != typeof Zone && Zone[Ic("BLACK_LISTED_EVENTS")]; if (t) { const e = {}; return t.forEach(t => { e[t] = t }), e } })(), Fc = function (t) { return !!Dc && Dc.hasOwnProperty(t) }, Lc = function (t) { const e = Nc[t.type]; if (!e) return; const n = this[e]; if (!n) return; const i = [t]; if (1 === n.length) { const t = n[0]; return t.zone !== Zone.current ? t.zone.run(t.handler, this, i) : t.handler.apply(this, i) } { const e = n.slice(); for (let n = 0; n < e.length && !0 !== t[Mc]; n++) { const t = e[n]; t.zone !== Zone.current ? t.zone.run(t.handler, this, i) : t.handler.apply(this, i) } } }; let Vc = (() => class extends _c { constructor(t, e, n) { super(t), this.ngZone = e, n && function (t) { return "server" === t }(n) || this.patchEvent() } patchEvent() { if ("undefined" == typeof Event || !Event || !Event.prototype) return; if (Event.prototype.__zone_symbol__stopImmediatePropagation) return; const t = Event.prototype.__zone_symbol__stopImmediatePropagation = Event.prototype.stopImmediatePropagation; Event.prototype.stopImmediatePropagation = function () { this && (this[Mc] = !0), t && t.apply(this, arguments) } } supports(t) { return !0 } addEventListener(t, e, n) { let i = n; if (!t[Ac] || Zr.isInAngularZone() && !Fc(e)) t.addEventListener(e, i, !1); else { let n = Nc[e]; n || (n = Nc[e] = Ic("ANGULAR" + e + "FALSE")); let r = t[n]; const s = r && r.length > 0; r || (r = t[n] = []); const o = Fc(e) ? Zone.root : Zone.current; if (0 === r.length) r.push({ zone: o, handler: i }); else { let t = !1; for (let e = 0; e < r.length; e++)if (r[e].handler === i) { t = !0; break } t || r.push({ zone: o, handler: i }) } s || t[Ac](e, Lc, !1) } return () => this.removeEventListener(t, e, i) } removeEventListener(t, e, n) { let i = t[Rc]; if (!i) return t.removeEventListener.apply(t, [e, n, !1]); let r = Nc[e], s = r && t[r]; if (!s) return t.removeEventListener.apply(t, [e, n, !1]); let o = !1; for (let l = 0; l < s.length; l++)if (s[l].handler === n) { o = !0, s.splice(l, 1); break } o ? 0 === s.length && i.apply(t, [e, Lc, !1]) : t.removeEventListener.apply(t, [e, n, !1]) } })(); const zc = { pan: !0, panstart: !0, panmove: !0, panend: !0, pancancel: !0, panleft: !0, panright: !0, panup: !0, pandown: !0, pinch: !0, pinchstart: !0, pinchmove: !0, pinchend: !0, pinchcancel: !0, pinchin: !0, pinchout: !0, press: !0, pressup: !0, rotate: !0, rotatestart: !0, rotatemove: !0, rotateend: !0, rotatecancel: !0, swipe: !0, swipeleft: !0, swiperight: !0, swipeup: !0, swipedown: !0, tap: !0 }, jc = new Tt("HammerGestureConfig"), Uc = new Tt("HammerLoader"); let Hc = (() => class { constructor() { this.events = [], this.overrides = {} } buildHammer(t) { const e = new Hammer(t, this.options); e.get("pinch").set({ enable: !0 }), e.get("rotate").set({ enable: !0 }); for (const n in this.overrides) e.get(n).set(this.overrides[n]); return e } })(), Bc = (() => class extends _c { constructor(t, e, n, i) { super(t), this._config = e, this.console = n, this.loader = i } supports(t) { return !(!zc.hasOwnProperty(t.toLowerCase()) && !this.isCustomEvent(t) || !window.Hammer && !this.loader && (this.console.warn(`The "${t}" event cannot be bound because Hammer.JS is not loaded and no custom loader has been specified.`), 1)) } addEventListener(t, e, n) { const i = this.manager.getZone(); if (e = e.toLowerCase(), !window.Hammer && this.loader) { let i = !1, r = () => { i = !0 }; return this.loader().then(() => { if (!window.Hammer) return this.console.warn("The custom HAMMER_LOADER completed, but Hammer.JS is not present."), void (r = () => { }); i || (r = this.addEventListener(t, e, n)) }).catch(() => { this.console.warn(`The "${e}" event cannot be bound because the custom Hammer.JS loader failed.`), r = () => { } }), () => { r() } } return i.runOutsideAngular(() => { const r = this._config.buildHammer(t), s = function (t) { i.runGuarded((function () { n(t) })) }; return r.on(e, s), () => { r.off(e, s), "function" == typeof r.destroy && r.destroy() } }) } isCustomEvent(t) { return this._config.events.indexOf(t) > -1 } })(); const $c = ["alt", "control", "meta", "shift"], Wc = { alt: t => t.altKey, control: t => t.ctrlKey, meta: t => t.metaKey, shift: t => t.shiftKey }; let qc = (() => { class t extends _c { constructor(t) { super(t) } supports(e) { return null != t.parseEventName(e) } addEventListener(e, n, i) { const r = t.parseEventName(n), s = t.eventCallback(r.fullKey, i, this.manager.getZone()); return this.manager.getZone().runOutsideAngular(() => Ja().onAndCancel(e, r.domEventName, s)) } static parseEventName(e) { const n = e.toLowerCase().split("."), i = n.shift(); if (0 === n.length || "keydown" !== i && "keyup" !== i) return null; const r = t._normalizeKey(n.pop()); let s = ""; if ($c.forEach(t => { const e = n.indexOf(t); e > -1 && (n.splice(e, 1), s += t + ".") }), s += r, 0 != n.length || 0 === r.length) return null; const o = {}; return o.domEventName = i, o.fullKey = s, o } static getEventFullKey(t) { let e = "", n = Ja().getEventKey(t); return n = n.toLowerCase(), " " === n ? n = "space" : "." === n && (n = "dot"), $c.forEach(i => { i != n && (0, Wc[i])(t) && (e += i + ".") }), e += n, e } static eventCallback(e, n, i) { return r => { t.getEventFullKey(r) === e && i.runGuarded(() => n(r)) } } static _normalizeKey(t) { switch (t) { case "esc": return "escape"; default: return t } } } return t })(); class Gc { } let Zc = (() => class extends Gc { constructor(t) { super(), this._doc = t } sanitize(t, e) { if (null == e) return null; switch (t) { case ve.NONE: return e; case ve.HTML: return e instanceof Kc ? e.changingThisBreaksApplicationSecurity : (this.checkNotSafeValue(e, "HTML"), function (t, e) { let n = null; try { _e = _e || new Xt(t); let i = e ? String(e) : ""; n = _e.getInertBodyElement(i); let r = 5, s = i; do { if (0 === r) throw new Error("Failed to sanitize html because the input is unstable"); r--, i = s, s = n.innerHTML, n = _e.getInertBodyElement(i) } while (i !== s); const o = new pe, l = o.sanitizeChildren(ye(n) || n); return Yt() && o.sanitizedSomething && console.warn("WARNING: sanitizing HTML stripped some content, see http://g.co/ng/security#xss"), l } finally { if (n) { const t = ye(n) || n; for (; t.firstChild;)t.removeChild(t.firstChild) } } }(this._doc, String(e))); case ve.STYLE: return e instanceof Yc ? e.changingThisBreaksApplicationSecurity : (this.checkNotSafeValue(e, "Style"), function (t) { if (!(t = String(t).trim())) return ""; const e = t.match(Ce); return e && ee(e[1]) === e[1] || t.match(we) && function (t) { let e = !0, n = !0; for (let i = 0; i < t.length; i++) { const r = t.charAt(i); "'" === r && n ? e = !e : '"' === r && e && (n = !n) } return e && n }(t) ? t : (Yt() && console.warn(`WARNING: sanitizing unsafe style value ${t} (see http://g.co/ng/security#xss).`), "unsafe") }(e)); case ve.SCRIPT: if (e instanceof Xc) return e.changingThisBreaksApplicationSecurity; throw this.checkNotSafeValue(e, "Script"), new Error("unsafe value used in a script context"); case ve.URL: return e instanceof tu || e instanceof Jc ? e.changingThisBreaksApplicationSecurity : (this.checkNotSafeValue(e, "URL"), ee(String(e))); case ve.RESOURCE_URL: if (e instanceof tu) return e.changingThisBreaksApplicationSecurity; throw this.checkNotSafeValue(e, "ResourceURL"), new Error("unsafe value used in a resource URL context (see http://g.co/ng/security#xss)"); default: throw new Error(`Unexpected SecurityContext ${t} (see http://g.co/ng/security#xss)`) } } checkNotSafeValue(t, e) { if (t instanceof Qc) throw new Error(`Required a safe ${e}, got a ${t.getTypeName()} (see http://g.co/ng/security#xss)`) } bypassSecurityTrustHtml(t) { return new Kc(t) } bypassSecurityTrustStyle(t) { return new Yc(t) } bypassSecurityTrustScript(t) { return new Xc(t) } bypassSecurityTrustUrl(t) { return new Jc(t) } bypassSecurityTrustResourceUrl(t) { return new tu(t) } })(); class Qc { constructor(t) { this.changingThisBreaksApplicationSecurity = t } toString() { return "SafeValue must use [property]=binding: " + this.changingThisBreaksApplicationSecurity + " (see http://g.co/ng/security#xss)" } } class Kc extends Qc { getTypeName() { return "HTML" } } class Yc extends Qc { getTypeName() { return "Style" } } class Xc extends Qc { getTypeName() { return "Script" } } class Jc extends Qc { getTypeName() { return "URL" } } class tu extends Qc { getTypeName() { return "ResourceURL" } } const eu = as(xs, "browser", [{ provide: Pr, useValue: "browser" }, { provide: kr, useValue: function () { rc.makeCurrent(), hc.init() }, multi: !0 }, { provide: rl, useClass: ac, deps: [ta] }, { provide: ta, useFactory: function () { return document }, deps: [] }]); function nu() { return new Te } let iu = (() => { class t { constructor(t) { if (t) throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.") } static withServerTransition(e) { return { ngModule: t, providers: [{ provide: Er, useValue: e.appId }, { provide: cc, useExisting: Er }, uc] } } } return t })(); "undefined" != typeof window && window; class ru { constructor(t, e) { this.id = t, this.url = e } } class su extends ru { constructor(t, e, n = "imperative", i = null) { super(t, e), this.navigationTrigger = n, this.restoredState = i } toString() { return `NavigationStart(id: ${this.id}, url: '${this.url}')` } } class ou extends ru { constructor(t, e, n) { super(t, e), this.urlAfterRedirects = n } toString() { return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')` } } class lu extends ru { constructor(t, e, n) { super(t, e), this.reason = n } toString() { return `NavigationCancel(id: ${this.id}, url: '${this.url}')` } } class au extends ru { constructor(t, e, n) { super(t, e), this.error = n } toString() { return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})` } } class cu extends ru { constructor(t, e, n, i) { super(t, e), this.urlAfterRedirects = n, this.state = i } toString() { return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class uu extends ru { constructor(t, e, n, i) { super(t, e), this.urlAfterRedirects = n, this.state = i } toString() { return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class hu extends ru { constructor(t, e, n, i, r) { super(t, e), this.urlAfterRedirects = n, this.state = i, this.shouldActivate = r } toString() { return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})` } } class du extends ru { constructor(t, e, n, i) { super(t, e), this.urlAfterRedirects = n, this.state = i } toString() { return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class pu extends ru { constructor(t, e, n, i) { super(t, e), this.urlAfterRedirects = n, this.state = i } toString() { return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class fu { constructor(t) { this.route = t } toString() { return `RouteConfigLoadStart(path: ${this.route.path})` } } class mu { constructor(t) { this.route = t } toString() { return `RouteConfigLoadEnd(path: ${this.route.path})` } } class gu { constructor(t) { this.snapshot = t } toString() { return `ChildActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class _u { constructor(t) { this.snapshot = t } toString() { return `ChildActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class yu { constructor(t) { this.snapshot = t } toString() { return `ActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class vu { constructor(t) { this.snapshot = t } toString() { return `ActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class bu { constructor(t, e, n) { this.routerEvent = t, this.position = e, this.anchor = n } toString() { return `Scroll(anchor: '${this.anchor}', position: '${this.position ? `${this.position[0]}, ${this.position[1]}` : null}')` } } let wu = (() => class { })(); class Cu { constructor(t) { this.params = t || {} } has(t) { return this.params.hasOwnProperty(t) } get(t) { if (this.has(t)) { const e = this.params[t]; return Array.isArray(e) ? e[0] : e } return null } getAll(t) { if (this.has(t)) { const e = this.params[t]; return Array.isArray(e) ? e : [e] } return [] } get keys() { return Object.keys(this.params) } } function Su(t) { return new Cu(t) } function Eu(t) { const e = Error("NavigationCancelingError: " + t); return e.ngNavigationCancelingError = !0, e } function xu(t, e, n) { const i = n.path.split("/"); if (i.length > t.length) return null; if ("full" === n.pathMatch && (e.hasChildren() || i.length < t.length)) return null; const r = {}; for (let s = 0; s < i.length; s++) { const e = i[s], n = t[s]; if (e.startsWith(":")) r[e.substring(1)] = n; else if (e !== n.path) return null } return { consumed: t.slice(0, i.length), posParams: r } } class Tu { constructor(t, e) { this.routes = t, this.module = e } } function ku(t, e = "") { for (let n = 0; n < t.length; n++) { const i = t[n]; Pu(i, Ou(e, i)) } } function Pu(t, e) { if (!t) throw new Error(`\n      Invalid configuration of route '${e}': Encountered undefined route.\n      The reason might be an extra comma.\n\n      Example:\n      const routes: Routes = [\n        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },\n        { path: 'dashboard',  component: DashboardComponent },, << two commas\n        { path: 'detail/:id', component: HeroDetailComponent }\n      ];\n    `); if (Array.isArray(t)) throw new Error(`Invalid configuration of route '${e}': Array cannot be specified`); if (!t.component && !t.children && !t.loadChildren && t.outlet && "primary" !== t.outlet) throw new Error(`Invalid configuration of route '${e}': a componentless route without children or loadChildren cannot have a named outlet set`); if (t.redirectTo && t.children) throw new Error(`Invalid configuration of route '${e}': redirectTo and children cannot be used together`); if (t.redirectTo && t.loadChildren) throw new Error(`Invalid configuration of route '${e}': redirectTo and loadChildren cannot be used together`); if (t.children && t.loadChildren) throw new Error(`Invalid configuration of route '${e}': children and loadChildren cannot be used together`); if (t.redirectTo && t.component) throw new Error(`Invalid configuration of route '${e}': redirectTo and component cannot be used together`); if (t.path && t.matcher) throw new Error(`Invalid configuration of route '${e}': path and matcher cannot be used together`); if (void 0 === t.redirectTo && !t.component && !t.children && !t.loadChildren) throw new Error(`Invalid configuration of route '${e}'. One of the following must be provided: component, redirectTo, children or loadChildren`); if (void 0 === t.path && void 0 === t.matcher) throw new Error(`Invalid configuration of route '${e}': routes must have either a path or a matcher specified`); if ("string" == typeof t.path && "/" === t.path.charAt(0)) throw new Error(`Invalid configuration of route '${e}': path cannot start with a slash`); if ("" === t.path && void 0 !== t.redirectTo && void 0 === t.pathMatch) throw new Error(`Invalid configuration of route '{path: "${e}", redirectTo: "${t.redirectTo}"}': please provide 'pathMatch'. The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.`); if (void 0 !== t.pathMatch && "full" !== t.pathMatch && "prefix" !== t.pathMatch) throw new Error(`Invalid configuration of route '${e}': pathMatch can only be set to 'prefix' or 'full'`); t.children && ku(t.children, e) } function Ou(t, e) { return e ? t || e.path ? t && !e.path ? t + "/" : !t && e.path ? e.path : `${t}/${e.path}` : "" : t } function Iu(t) { const e = t.children && t.children.map(Iu), n = e ? Object.assign({}, t, { children: e }) : Object.assign({}, t); return !n.component && (e || n.loadChildren) && n.outlet && "primary" !== n.outlet && (n.component = wu), n } function Au(t, e) { const n = Object.keys(t), i = Object.keys(e); if (!n || !i || n.length != i.length) return !1; let r; for (let s = 0; s < n.length; s++)if (r = n[s], t[r] !== e[r]) return !1; return !0 } function Ru(t) { return Array.prototype.concat.apply([], t) } function Nu(t) { return t.length > 0 ? t[t.length - 1] : null } function Mu(t, e) { for (const n in t) t.hasOwnProperty(n) && e(t[n], n) } function Du(t) { return Le(t) ? t : Fe(t) ? q(Promise.resolve(t)) : oa(t) } function Fu(t, e, n) { return n ? function (t, e) { return Au(t, e) }(t.queryParams, e.queryParams) && function t(e, n) { if (!ju(e.segments, n.segments)) return !1; if (e.numberOfChildren !== n.numberOfChildren) return !1; for (const i in n.children) { if (!e.children[i]) return !1; if (!t(e.children[i], n.children[i])) return !1 } return !0 }(t.root, e.root) : function (t, e) { return Object.keys(e).length <= Object.keys(t).length && Object.keys(e).every(n => e[n] === t[n]) }(t.queryParams, e.queryParams) && function t(e, n) { return function e(n, i, r) { if (n.segments.length > r.length) return !!ju(n.segments.slice(0, r.length), r) && !i.hasChildren(); if (n.segments.length === r.length) { if (!ju(n.segments, r)) return !1; for (const e in i.children) { if (!n.children[e]) return !1; if (!t(n.children[e], i.children[e])) return !1 } return !0 } { const t = r.slice(0, n.segments.length), s = r.slice(n.segments.length); return !!ju(n.segments, t) && !!n.children.primary && e(n.children.primary, i, s) } }(e, n, n.segments) }(t.root, e.root) } class Lu { constructor(t, e, n) { this.root = t, this.queryParams = e, this.fragment = n } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = Su(this.queryParams)), this._queryParamMap } toString() { return $u.serialize(this) } } class Vu { constructor(t, e) { this.segments = t, this.children = e, this.parent = null, Mu(e, (t, e) => t.parent = this) } hasChildren() { return this.numberOfChildren > 0 } get numberOfChildren() { return Object.keys(this.children).length } toString() { return Wu(this) } } class zu { constructor(t, e) { this.path = t, this.parameters = e } get parameterMap() { return this._parameterMap || (this._parameterMap = Su(this.parameters)), this._parameterMap } toString() { return Yu(this) } } function ju(t, e) { return t.length === e.length && t.every((t, n) => t.path === e[n].path) } function Uu(t, e) { let n = []; return Mu(t.children, (t, i) => { "primary" === i && (n = n.concat(e(t, i))) }), Mu(t.children, (t, i) => { "primary" !== i && (n = n.concat(e(t, i))) }), n } class Hu { } class Bu { parse(t) { const e = new nh(t); return new Lu(e.parseRootSegment(), e.parseQueryParams(), e.parseFragment()) } serialize(t) { return `${"/" + function t(e, n) { if (!e.hasChildren()) return Wu(e); if (n) { const n = e.children.primary ? t(e.children.primary, !1) : "", i = []; return Mu(e.children, (e, n) => { "primary" !== n && i.push(`${n}:${t(e, !1)}`) }), i.length > 0 ? `${n}(${i.join("//")})` : n } { const n = Uu(e, (n, i) => "primary" === i ? [t(e.children.primary, !1)] : [`${i}:${t(n, !1)}`]); return `${Wu(e)}/(${n.join("//")})` } }(t.root, !0)}${function (t) { const e = Object.keys(t).map(e => { const n = t[e]; return Array.isArray(n) ? n.map(t => `${Gu(e)}=${Gu(t)}`).join("&") : `${Gu(e)}=${Gu(n)}` }); return e.length ? "?" + e.join("&") : "" }(t.queryParams)}${"string" == typeof t.fragment ? "#" + encodeURI(t.fragment) : ""}` } } const $u = new Bu; function Wu(t) { return t.segments.map(t => Yu(t)).join("/") } function qu(t) { return encodeURIComponent(t).replace(/%40/g, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",") } function Gu(t) { return qu(t).replace(/%3B/gi, ";") } function Zu(t) { return qu(t).replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/%26/gi, "&") } function Qu(t) { return decodeURIComponent(t) } function Ku(t) { return Qu(t.replace(/\+/g, "%20")) } function Yu(t) { return `${Zu(t.path)}${e = t.parameters, Object.keys(e).map(t => `;${Zu(t)}=${Zu(e[t])}`).join("")}`; var e } const Xu = /^[^\/()?;=#]+/; function Ju(t) { const e = t.match(Xu); return e ? e[0] : "" } const th = /^[^=?&#]+/, eh = /^[^?&#]+/; class nh { constructor(t) { this.url = t, this.remaining = t } parseRootSegment() { return this.consumeOptional("/"), "" === this.remaining || this.peekStartsWith("?") || this.peekStartsWith("#") ? new Vu([], {}) : new Vu([], this.parseChildren()) } parseQueryParams() { const t = {}; if (this.consumeOptional("?")) do { this.parseQueryParam(t) } while (this.consumeOptional("&")); return t } parseFragment() { return this.consumeOptional("#") ? decodeURIComponent(this.remaining) : null } parseChildren() { if ("" === this.remaining) return {}; this.consumeOptional("/"); const t = []; for (this.peekStartsWith("(") || t.push(this.parseSegment()); this.peekStartsWith("/") && !this.peekStartsWith("//") && !this.peekStartsWith("/(");)this.capture("/"), t.push(this.parseSegment()); let e = {}; this.peekStartsWith("/(") && (this.capture("/"), e = this.parseParens(!0)); let n = {}; return this.peekStartsWith("(") && (n = this.parseParens(!1)), (t.length > 0 || Object.keys(e).length > 0) && (n.primary = new Vu(t, e)), n } parseSegment() { const t = Ju(this.remaining); if ("" === t && this.peekStartsWith(";")) throw new Error(`Empty path url segment cannot have parameters: '${this.remaining}'.`); return this.capture(t), new zu(Qu(t), this.parseMatrixParams()) } parseMatrixParams() { const t = {}; for (; this.consumeOptional(";");)this.parseParam(t); return t } parseParam(t) { const e = Ju(this.remaining); if (!e) return; this.capture(e); let n = ""; if (this.consumeOptional("=")) { const t = Ju(this.remaining); t && (n = t, this.capture(n)) } t[Qu(e)] = Qu(n) } parseQueryParam(t) { const e = function (t) { const e = t.match(th); return e ? e[0] : "" }(this.remaining); if (!e) return; this.capture(e); let n = ""; if (this.consumeOptional("=")) { const t = function (t) { const e = t.match(eh); return e ? e[0] : "" }(this.remaining); t && (n = t, this.capture(n)) } const i = Ku(e), r = Ku(n); if (t.hasOwnProperty(i)) { let e = t[i]; Array.isArray(e) || (e = [e], t[i] = e), e.push(r) } else t[i] = r } parseParens(t) { const e = {}; for (this.capture("("); !this.consumeOptional(")") && this.remaining.length > 0;) { const n = Ju(this.remaining), i = this.remaining[n.length]; if ("/" !== i && ")" !== i && ";" !== i) throw new Error(`Cannot parse url '${this.url}'`); let r = void 0; n.indexOf(":") > -1 ? (r = n.substr(0, n.indexOf(":")), this.capture(r), this.capture(":")) : t && (r = "primary"); const s = this.parseChildren(); e[r] = 1 === Object.keys(s).length ? s.primary : new Vu([], s), this.consumeOptional("//") } return e } peekStartsWith(t) { return this.remaining.startsWith(t) } consumeOptional(t) { return !!this.peekStartsWith(t) && (this.remaining = this.remaining.substring(t.length), !0) } capture(t) { if (!this.consumeOptional(t)) throw new Error(`Expected "${t}".`) } } class ih { constructor(t) { this._root = t } get root() { return this._root.value } parent(t) { const e = this.pathFromRoot(t); return e.length > 1 ? e[e.length - 2] : null } children(t) { const e = rh(t, this._root); return e ? e.children.map(t => t.value) : [] } firstChild(t) { const e = rh(t, this._root); return e && e.children.length > 0 ? e.children[0].value : null } siblings(t) { const e = sh(t, this._root); return e.length < 2 ? [] : e[e.length - 2].children.map(t => t.value).filter(e => e !== t) } pathFromRoot(t) { return sh(t, this._root).map(t => t.value) } } function rh(t, e) { if (t === e.value) return e; for (const n of e.children) { const e = rh(t, n); if (e) return e } return null } function sh(t, e) { if (t === e.value) return [e]; for (const n of e.children) { const i = sh(t, n); if (i.length) return i.unshift(e), i } return [] } class oh { constructor(t, e) { this.value = t, this.children = e } toString() { return `TreeNode(${this.value})` } } function lh(t) { const e = {}; return t && t.children.forEach(t => e[t.value.outlet] = t), e } class ah extends ih { constructor(t, e) { super(t), this.snapshot = e, fh(this, t) } toString() { return this.snapshot.toString() } } function ch(t, e) { const n = function (t, e) { const n = new dh([], {}, {}, "", {}, "primary", e, null, t.root, -1, {}); return new ph("", new oh(n, [])) }(t, e), i = new la([new zu("", {})]), r = new la({}), s = new la({}), o = new la({}), l = new la(""), a = new uh(i, r, o, l, s, "primary", e, n.root); return a.snapshot = n.root, new ah(new oh(a, []), n) } class uh { constructor(t, e, n, i, r, s, o, l) { this.url = t, this.params = e, this.queryParams = n, this.fragment = i, this.data = r, this.outlet = s, this.component = o, this._futureSnapshot = l } get routeConfig() { return this._futureSnapshot.routeConfig } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = this.params.pipe(H(t => Su(t)))), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = this.queryParams.pipe(H(t => Su(t)))), this._queryParamMap } toString() { return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})` } } function hh(t, e = "emptyOnly") { const n = t.pathFromRoot; let i = 0; if ("always" !== e) for (i = n.length - 1; i >= 1;) { const t = n[i], e = n[i - 1]; if (t.routeConfig && "" === t.routeConfig.path) i--; else { if (e.component) break; i-- } } return function (t) { return t.reduce((t, e) => ({ params: Object.assign({}, t.params, e.params), data: Object.assign({}, t.data, e.data), resolve: Object.assign({}, t.resolve, e._resolvedData) }), { params: {}, data: {}, resolve: {} }) }(n.slice(i)) } class dh { constructor(t, e, n, i, r, s, o, l, a, c, u) { this.url = t, this.params = e, this.queryParams = n, this.fragment = i, this.data = r, this.outlet = s, this.component = o, this.routeConfig = l, this._urlSegment = a, this._lastPathIndex = c, this._resolve = u } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = Su(this.params)), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = Su(this.queryParams)), this._queryParamMap } toString() { return `Route(url:'${this.url.map(t => t.toString()).join("/")}', path:'${this.routeConfig ? this.routeConfig.path : ""}')` } } class ph extends ih { constructor(t, e) { super(e), this.url = t, fh(this, e) } toString() { return mh(this._root) } } function fh(t, e) { e.value._routerState = t, e.children.forEach(e => fh(t, e)) } function mh(t) { const e = t.children.length > 0 ? ` { ${t.children.map(mh).join(", ")} } ` : ""; return `${t.value}${e}` } function gh(t) { if (t.snapshot) { const e = t.snapshot, n = t._futureSnapshot; t.snapshot = n, Au(e.queryParams, n.queryParams) || t.queryParams.next(n.queryParams), e.fragment !== n.fragment && t.fragment.next(n.fragment), Au(e.params, n.params) || t.params.next(n.params), function (t, e) { if (t.length !== e.length) return !1; for (let n = 0; n < t.length; ++n)if (!Au(t[n], e[n])) return !1; return !0 }(e.url, n.url) || t.url.next(n.url), Au(e.data, n.data) || t.data.next(n.data) } else t.snapshot = t._futureSnapshot, t.data.next(t._futureSnapshot.data) } function _h(t, e) { var n, i; return Au(t.params, e.params) && ju(n = t.url, i = e.url) && n.every((t, e) => Au(t.parameters, i[e].parameters)) && !(!t.parent != !e.parent) && (!t.parent || _h(t.parent, e.parent)) } function yh(t) { return "object" == typeof t && null != t && !t.outlets && !t.segmentPath } function vh(t, e, n, i, r) { let s = {}; return i && Mu(i, (t, e) => { s[e] = Array.isArray(t) ? t.map(t => "" + t) : "" + t }), new Lu(n.root === t ? e : function t(e, n, i) { const r = {}; return Mu(e.children, (e, s) => { r[s] = e === n ? i : t(e, n, i) }), new Vu(e.segments, r) }(n.root, t, e), s, r) } class bh { constructor(t, e, n) { if (this.isAbsolute = t, this.numberOfDoubleDots = e, this.commands = n, t && n.length > 0 && yh(n[0])) throw new Error("Root segment cannot have matrix parameters"); const i = n.find(t => "object" == typeof t && null != t && t.outlets); if (i && i !== Nu(n)) throw new Error("{outlets:{}} has to be the last command") } toRoot() { return this.isAbsolute && 1 === this.commands.length && "/" == this.commands[0] } } class wh { constructor(t, e, n) { this.segmentGroup = t, this.processChildren = e, this.index = n } } function Ch(t) { return "object" == typeof t && null != t && t.outlets ? t.outlets.primary : "" + t } function Sh(t, e, n) { if (t || (t = new Vu([], {})), 0 === t.segments.length && t.hasChildren()) return Eh(t, e, n); const i = function (t, e, n) { let i = 0, r = e; const s = { match: !1, pathIndex: 0, commandIndex: 0 }; for (; r < t.segments.length;) { if (i >= n.length) return s; const e = t.segments[r], o = Ch(n[i]), l = i < n.length - 1 ? n[i + 1] : null; if (r > 0 && void 0 === o) break; if (o && l && "object" == typeof l && void 0 === l.outlets) { if (!Ph(o, l, e)) return s; i += 2 } else { if (!Ph(o, {}, e)) return s; i++ } r++ } return { match: !0, pathIndex: r, commandIndex: i } }(t, e, n), r = n.slice(i.commandIndex); if (i.match && i.pathIndex < t.segments.length) { const e = new Vu(t.segments.slice(0, i.pathIndex), {}); return e.children.primary = new Vu(t.segments.slice(i.pathIndex), t.children), Eh(e, 0, r) } return i.match && 0 === r.length ? new Vu(t.segments, {}) : i.match && !t.hasChildren() ? xh(t, e, n) : i.match ? Eh(t, 0, r) : xh(t, e, n) } function Eh(t, e, n) { if (0 === n.length) return new Vu(t.segments, {}); { const i = function (t) { return "object" != typeof t[0] || void 0 === t[0].outlets ? { primary: t } : t[0].outlets }(n), r = {}; return Mu(i, (n, i) => { null !== n && (r[i] = Sh(t.children[i], e, n)) }), Mu(t.children, (t, e) => { void 0 === i[e] && (r[e] = t) }), new Vu(t.segments, r) } } function xh(t, e, n) { const i = t.segments.slice(0, e); let r = 0; for (; r < n.length;) { if ("object" == typeof n[r] && void 0 !== n[r].outlets) { const t = Th(n[r].outlets); return new Vu(i, t) } if (0 === r && yh(n[0])) { i.push(new zu(t.segments[e].path, n[0])), r++; continue } const s = Ch(n[r]), o = r < n.length - 1 ? n[r + 1] : null; s && o && yh(o) ? (i.push(new zu(s, kh(o))), r += 2) : (i.push(new zu(s, {})), r++) } return new Vu(i, {}) } function Th(t) { const e = {}; return Mu(t, (t, n) => { null !== t && (e[n] = xh(new Vu([], {}), 0, t)) }), e } function kh(t) { const e = {}; return Mu(t, (t, n) => e[n] = "" + t), e } function Ph(t, e, n) { return t == n.path && Au(e, n.parameters) } class Oh { constructor(t, e, n, i) { this.routeReuseStrategy = t, this.futureState = e, this.currState = n, this.forwardEvent = i } activate(t) { const e = this.futureState._root, n = this.currState ? this.currState._root : null; this.deactivateChildRoutes(e, n, t), gh(this.futureState.root), this.activateChildRoutes(e, n, t) } deactivateChildRoutes(t, e, n) { const i = lh(e); t.children.forEach(t => { const e = t.value.outlet; this.deactivateRoutes(t, i[e], n), delete i[e] }), Mu(i, (t, e) => { this.deactivateRouteAndItsChildren(t, n) }) } deactivateRoutes(t, e, n) { const i = t.value, r = e ? e.value : null; if (i === r) if (i.component) { const r = n.getContext(i.outlet); r && this.deactivateChildRoutes(t, e, r.children) } else this.deactivateChildRoutes(t, e, n); else r && this.deactivateRouteAndItsChildren(e, n) } deactivateRouteAndItsChildren(t, e) { this.routeReuseStrategy.shouldDetach(t.value.snapshot) ? this.detachAndStoreRouteSubtree(t, e) : this.deactivateRouteAndOutlet(t, e) } detachAndStoreRouteSubtree(t, e) { const n = e.getContext(t.value.outlet); if (n && n.outlet) { const e = n.outlet.detach(), i = n.children.onOutletDeactivated(); this.routeReuseStrategy.store(t.value.snapshot, { componentRef: e, route: t, contexts: i }) } } deactivateRouteAndOutlet(t, e) { const n = e.getContext(t.value.outlet); if (n) { const i = lh(t), r = t.value.component ? n.children : e; Mu(i, (t, e) => this.deactivateRouteAndItsChildren(t, r)), n.outlet && (n.outlet.deactivate(), n.children.onOutletDeactivated()) } } activateChildRoutes(t, e, n) { const i = lh(e); t.children.forEach(t => { this.activateRoutes(t, i[t.value.outlet], n), this.forwardEvent(new vu(t.value.snapshot)) }), t.children.length && this.forwardEvent(new _u(t.value.snapshot)) } activateRoutes(t, e, n) { const i = t.value, r = e ? e.value : null; if (gh(i), i === r) if (i.component) { const r = n.getOrCreateContext(i.outlet); this.activateChildRoutes(t, e, r.children) } else this.activateChildRoutes(t, e, n); else if (i.component) { const e = n.getOrCreateContext(i.outlet); if (this.routeReuseStrategy.shouldAttach(i.snapshot)) { const t = this.routeReuseStrategy.retrieve(i.snapshot); this.routeReuseStrategy.store(i.snapshot, null), e.children.onOutletReAttached(t.contexts), e.attachRef = t.componentRef, e.route = t.route.value, e.outlet && e.outlet.attach(t.componentRef, t.route.value), Ih(t.route) } else { const n = function (t) { for (let e = t.parent; e; e = e.parent) { const t = e.routeConfig; if (t && t._loadedConfig) return t._loadedConfig; if (t && t.component) return null } return null }(i.snapshot), r = n ? n.module.componentFactoryResolver : null; e.attachRef = null, e.route = i, e.resolver = r, e.outlet && e.outlet.activateWith(i, r), this.activateChildRoutes(t, null, e.children) } } else this.activateChildRoutes(t, null, n) } } function Ih(t) { gh(t.value), t.children.forEach(Ih) } function Ah(t) { return "function" == typeof t } function Rh(t) { return t instanceof Lu } class Nh { constructor(t) { this.segmentGroup = t || null } } class Mh { constructor(t) { this.urlTree = t } } function Dh(t) { return new w(e => e.error(new Nh(t))) } function Fh(t) { return new w(e => e.error(new Mh(t))) } function Lh(t) { return new w(e => e.error(new Error(`Only absolute redirects can have named outlets. redirectTo: '${t}'`))) } class Vh { constructor(t, e, n, i, r) { this.configLoader = e, this.urlSerializer = n, this.urlTree = i, this.config = r, this.allowRedirects = !0, this.ngModule = t.get(qe) } apply() { return this.expandSegmentGroup(this.ngModule, this.config, this.urlTree.root, "primary").pipe(H(t => this.createUrlTree(t, this.urlTree.queryParams, this.urlTree.fragment))).pipe(Ra(t => { if (t instanceof Mh) return this.allowRedirects = !1, this.match(t.urlTree); if (t instanceof Nh) throw this.noMatchError(t); throw t })) } match(t) { return this.expandSegmentGroup(this.ngModule, this.config, t.root, "primary").pipe(H(e => this.createUrlTree(e, t.queryParams, t.fragment))).pipe(Ra(t => { if (t instanceof Nh) throw this.noMatchError(t); throw t })) } noMatchError(t) { return new Error(`Cannot match any routes. URL Segment: '${t.segmentGroup}'`) } createUrlTree(t, e, n) { const i = t.segments.length > 0 ? new Vu([], { primary: t }) : t; return new Lu(i, e, n) } expandSegmentGroup(t, e, n, i) { return 0 === n.segments.length && n.hasChildren() ? this.expandChildren(t, e, n).pipe(H(t => new Vu([], t))) : this.expandSegment(t, n, e, n.segments, i, !0) } expandChildren(t, e, n) { return function (t, e) { if (0 === Object.keys(t).length) return oa({}); const n = [], i = [], r = {}; return Mu(t, (t, s) => { const o = e(s, t).pipe(H(t => r[s] = t)); "primary" === s ? n.push(o) : i.push(o) }), oa.apply(null, n.concat(i)).pipe(fa(), Aa(), H(() => r)) }(n.children, (n, i) => this.expandSegmentGroup(t, e, i, n)) } expandSegment(t, e, n, i, r, s) { return oa(...n).pipe(H(o => this.expandSegmentAgainstRoute(t, e, n, o, i, r, s).pipe(Ra(t => { if (t instanceof Nh) return oa(null); throw t }))), fa(), Va(t => !!t), Ra((t, n) => { if (t instanceof ca || "EmptyError" === t.name) { if (this.noLeftoversInUrl(e, i, r)) return oa(new Vu([], {})); throw new Nh(e) } throw t })) } noLeftoversInUrl(t, e, n) { return 0 === e.length && !t.children[n] } expandSegmentAgainstRoute(t, e, n, i, r, s, o) { return Hh(i) !== s ? Dh(e) : void 0 === i.redirectTo ? this.matchSegmentAgainstRoute(t, e, i, r) : o && this.allowRedirects ? this.expandSegmentAgainstRouteUsingRedirect(t, e, n, i, r, s) : Dh(e) } expandSegmentAgainstRouteUsingRedirect(t, e, n, i, r, s) { return "**" === i.path ? this.expandWildCardWithParamsAgainstRouteUsingRedirect(t, n, i, s) : this.expandRegularSegmentAgainstRouteUsingRedirect(t, e, n, i, r, s) } expandWildCardWithParamsAgainstRouteUsingRedirect(t, e, n, i) { const r = this.applyRedirectCommands([], n.redirectTo, {}); return n.redirectTo.startsWith("/") ? Fh(r) : this.lineralizeSegments(n, r).pipe(G(n => { const r = new Vu(n, {}); return this.expandSegment(t, r, e, n, i, !1) })) } expandRegularSegmentAgainstRouteUsingRedirect(t, e, n, i, r, s) { const { matched: o, consumedSegments: l, lastChild: a, positionalParamSegments: c } = zh(e, i, r); if (!o) return Dh(e); const u = this.applyRedirectCommands(l, i.redirectTo, c); return i.redirectTo.startsWith("/") ? Fh(u) : this.lineralizeSegments(i, u).pipe(G(i => this.expandSegment(t, e, n, i.concat(r.slice(a)), s, !1))) } matchSegmentAgainstRoute(t, e, n, i) { if ("**" === n.path) return n.loadChildren ? this.configLoader.load(t.injector, n).pipe(H(t => (n._loadedConfig = t, new Vu(i, {})))) : oa(new Vu(i, {})); const { matched: r, consumedSegments: s, lastChild: o } = zh(e, n, i); if (!r) return Dh(e); const l = i.slice(o); return this.getChildConfig(t, n, i).pipe(G(t => { const n = t.module, i = t.routes, { segmentGroup: r, slicedSegments: o } = function (t, e, n, i) { return n.length > 0 && function (t, e, n) { return n.some(n => Uh(t, e, n) && "primary" !== Hh(n)) }(t, n, i) ? { segmentGroup: jh(new Vu(e, function (t, e) { const n = {}; n.primary = e; for (const i of t) "" === i.path && "primary" !== Hh(i) && (n[Hh(i)] = new Vu([], {})); return n }(i, new Vu(n, t.children)))), slicedSegments: [] } : 0 === n.length && function (t, e, n) { return n.some(n => Uh(t, e, n)) }(t, n, i) ? { segmentGroup: jh(new Vu(t.segments, function (t, e, n, i) { const r = {}; for (const s of n) Uh(t, e, s) && !i[Hh(s)] && (r[Hh(s)] = new Vu([], {})); return Object.assign({}, i, r) }(t, n, i, t.children))), slicedSegments: n } : { segmentGroup: t, slicedSegments: n } }(e, s, l, i); return 0 === o.length && r.hasChildren() ? this.expandChildren(n, i, r).pipe(H(t => new Vu(s, t))) : 0 === i.length && 0 === o.length ? oa(new Vu(s, {})) : this.expandSegment(n, r, i, o, "primary", !0).pipe(H(t => new Vu(s.concat(t.segments), t.children))) })) } getChildConfig(t, e, n) { return e.children ? oa(new Tu(e.children, t)) : e.loadChildren ? void 0 !== e._loadedConfig ? oa(e._loadedConfig) : function (t, e, n) { const i = e.canLoad; return i && 0 !== i.length ? q(i).pipe(H(i => { const r = t.get(i); let s; if (function (t) { return t && Ah(t.canLoad) }(r)) s = r.canLoad(e, n); else { if (!Ah(r)) throw new Error("Invalid CanLoad guard"); s = r(e, n) } return Du(s) })).pipe(fa(), (r = t => !0 === t, t => t.lift(new za(r, void 0, t)))) : oa(!0); var r }(t.injector, e, n).pipe(G(n => n ? this.configLoader.load(t.injector, e).pipe(H(t => (e._loadedConfig = t, t))) : function (t) { return new w(e => e.error(Eu(`Cannot load children because the guard of the route "path: '${t.path}'" returned false`))) }(e))) : oa(new Tu([], t)) } lineralizeSegments(t, e) { let n = [], i = e.root; for (; ;) { if (n = n.concat(i.segments), 0 === i.numberOfChildren) return oa(n); if (i.numberOfChildren > 1 || !i.children.primary) return Lh(t.redirectTo); i = i.children.primary } } applyRedirectCommands(t, e, n) { return this.applyRedirectCreatreUrlTree(e, this.urlSerializer.parse(e), t, n) } applyRedirectCreatreUrlTree(t, e, n, i) { const r = this.createSegmentGroup(t, e.root, n, i); return new Lu(r, this.createQueryParams(e.queryParams, this.urlTree.queryParams), e.fragment) } createQueryParams(t, e) { const n = {}; return Mu(t, (t, i) => { if ("string" == typeof t && t.startsWith(":")) { const r = t.substring(1); n[i] = e[r] } else n[i] = t }), n } createSegmentGroup(t, e, n, i) { const r = this.createSegments(t, e.segments, n, i); let s = {}; return Mu(e.children, (e, r) => { s[r] = this.createSegmentGroup(t, e, n, i) }), new Vu(r, s) } createSegments(t, e, n, i) { return e.map(e => e.path.startsWith(":") ? this.findPosParam(t, e, i) : this.findOrReturn(e, n)) } findPosParam(t, e, n) { const i = n[e.path.substring(1)]; if (!i) throw new Error(`Cannot redirect to '${t}'. Cannot find '${e.path}'.`); return i } findOrReturn(t, e) { let n = 0; for (const i of e) { if (i.path === t.path) return e.splice(n), i; n++ } return t } } function zh(t, e, n) { if ("" === e.path) return "full" === e.pathMatch && (t.hasChildren() || n.length > 0) ? { matched: !1, consumedSegments: [], lastChild: 0, positionalParamSegments: {} } : { matched: !0, consumedSegments: [], lastChild: 0, positionalParamSegments: {} }; const i = (e.matcher || xu)(n, t, e); return i ? { matched: !0, consumedSegments: i.consumed, lastChild: i.consumed.length, positionalParamSegments: i.posParams } : { matched: !1, consumedSegments: [], lastChild: 0, positionalParamSegments: {} } } function jh(t) { if (1 === t.numberOfChildren && t.children.primary) { const e = t.children.primary; return new Vu(t.segments.concat(e.segments), e.children) } return t } function Uh(t, e, n) { return (!(t.hasChildren() || e.length > 0) || "full" !== n.pathMatch) && "" === n.path && void 0 !== n.redirectTo } function Hh(t) { return t.outlet || "primary" } class Bh { constructor(t) { this.path = t, this.route = this.path[this.path.length - 1] } } class $h { constructor(t, e) { this.component = t, this.route = e } } function Wh(t, e, n) { const i = t._root; return function t(e, n, i, r, s = { canDeactivateChecks: [], canActivateChecks: [] }) { const o = lh(n); return e.children.forEach(e => { !function (e, n, i, r, s = { canDeactivateChecks: [], canActivateChecks: [] }) { const o = e.value, l = n ? n.value : null, a = i ? i.getContext(e.value.outlet) : null; if (l && o.routeConfig === l.routeConfig) { const c = function (t, e, n) { if ("function" == typeof n) return n(t, e); switch (n) { case "pathParamsChange": return !ju(t.url, e.url); case "pathParamsOrQueryParamsChange": return !ju(t.url, e.url) || !Au(t.queryParams, e.queryParams); case "always": return !0; case "paramsOrQueryParamsChange": return !_h(t, e) || !Au(t.queryParams, e.queryParams); case "paramsChange": default: return !_h(t, e) } }(l, o, o.routeConfig.runGuardsAndResolvers); c ? s.canActivateChecks.push(new Bh(r)) : (o.data = l.data, o._resolvedData = l._resolvedData), t(e, n, o.component ? a ? a.children : null : i, r, s), c && s.canDeactivateChecks.push(new $h(a && a.outlet && a.outlet.component || null, l)) } else l && Gh(n, a, s), s.canActivateChecks.push(new Bh(r)), t(e, null, o.component ? a ? a.children : null : i, r, s) }(e, o[e.value.outlet], i, r.concat([e.value]), s), delete o[e.value.outlet] }), Mu(o, (t, e) => Gh(t, i.getContext(e), s)), s }(i, e ? e._root : null, n, [i.value]) } function qh(t, e, n) { const i = function (t) { if (!t) return null; for (let e = t.parent; e; e = e.parent) { const t = e.routeConfig; if (t && t._loadedConfig) return t._loadedConfig } return null }(e); return (i ? i.module.injector : n).get(t) } function Gh(t, e, n) { const i = lh(t), r = t.value; Mu(i, (t, i) => { Gh(t, r.component ? e ? e.children.getContext(i) : null : e, n) }), n.canDeactivateChecks.push(new $h(r.component && e && e.outlet && e.outlet.isActivated ? e.outlet.component : null, r)) } const Zh = Symbol("INITIAL_VALUE"); function Qh() { return Ua(t => function (...t) { let e = null, n = null; return O(t[t.length - 1]) && (n = t.pop()), "function" == typeof t[t.length - 1] && (e = t.pop()), 1 === t.length && a(t[0]) && (t = t[0]), W(t, n).lift(new ha(e)) }(...t.map(t => t.pipe(Da(1), $a(Zh)))).pipe(Wa((t, e) => { let n = !1; return e.reduce((t, i, r) => { if (t !== Zh) return t; if (i === Zh && (n = !0), !n) { if (!1 === i) return i; if (r === e.length - 1 || Rh(i)) return i } return t }, t) }, Zh), ma(t => t !== Zh), H(t => Rh(t) ? t : !0 === t), Da(1))) } function Kh(t, e) { return null !== t && e && e(new yu(t)), oa(!0) } function Yh(t, e) { return null !== t && e && e(new gu(t)), oa(!0) } function Xh(t, e, n) { const i = e.routeConfig ? e.routeConfig.canActivate : null; return i && 0 !== i.length ? oa(i.map(i => pa(() => { const r = qh(i, e, n); let s; if (function (t) { return t && Ah(t.canActivate) }(r)) s = Du(r.canActivate(e, t)); else { if (!Ah(r)) throw new Error("Invalid CanActivate guard"); s = Du(r(e, t)) } return s.pipe(Va()) }))).pipe(Qh()) : oa(!0) } function Jh(t, e, n) { const i = e[e.length - 1], r = e.slice(0, e.length - 1).reverse().map(t => function (t) { const e = t.routeConfig ? t.routeConfig.canActivateChild : null; return e && 0 !== e.length ? { node: t, guards: e } : null }(t)).filter(t => null !== t).map(e => pa(() => oa(e.guards.map(r => { const s = qh(r, e.node, n); let o; if (function (t) { return t && Ah(t.canActivateChild) }(s)) o = Du(s.canActivateChild(i, t)); else { if (!Ah(s)) throw new Error("Invalid CanActivateChild guard"); o = Du(s(i, t)) } return o.pipe(Va()) })).pipe(Qh()))); return oa(r).pipe(Qh()) } class td { } class ed { constructor(t, e, n, i, r, s) { this.rootComponentType = t, this.config = e, this.urlTree = n, this.url = i, this.paramsInheritanceStrategy = r, this.relativeLinkResolution = s } recognize() { try { const t = rd(this.urlTree.root, [], [], this.config, this.relativeLinkResolution).segmentGroup, e = this.processSegmentGroup(this.config, t, "primary"), n = new dh([], Object.freeze({}), Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, {}, "primary", this.rootComponentType, null, this.urlTree.root, -1, {}), i = new oh(n, e), r = new ph(this.url, i); return this.inheritParamsAndData(r._root), oa(r) } catch (t) { return new w(e => e.error(t)) } } inheritParamsAndData(t) { const e = t.value, n = hh(e, this.paramsInheritanceStrategy); e.params = Object.freeze(n.params), e.data = Object.freeze(n.data), t.children.forEach(t => this.inheritParamsAndData(t)) } processSegmentGroup(t, e, n) { return 0 === e.segments.length && e.hasChildren() ? this.processChildren(t, e) : this.processSegment(t, e, e.segments, n) } processChildren(t, e) { const n = Uu(e, (e, n) => this.processSegmentGroup(t, e, n)); return function (t) { const e = {}; t.forEach(t => { const n = e[t.value.outlet]; if (n) { const e = n.url.map(t => t.toString()).join("/"), i = t.value.url.map(t => t.toString()).join("/"); throw new Error(`Two segments cannot have the same outlet name: '${e}' and '${i}'.`) } e[t.value.outlet] = t.value }) }(n), n.sort((t, e) => "primary" === t.value.outlet ? -1 : "primary" === e.value.outlet ? 1 : t.value.outlet.localeCompare(e.value.outlet)), n } processSegment(t, e, n, i) { for (const s of t) try { return this.processSegmentAgainstRoute(s, e, n, i) } catch (r) { if (!(r instanceof td)) throw r } if (this.noLeftoversInUrl(e, n, i)) return []; throw new td } noLeftoversInUrl(t, e, n) { return 0 === e.length && !t.children[n] } processSegmentAgainstRoute(t, e, n, i) { if (t.redirectTo) throw new td; if ((t.outlet || "primary") !== i) throw new td; let r, s = [], o = []; if ("**" === t.path) { const s = n.length > 0 ? Nu(n).parameters : {}; r = new dh(n, s, Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, ld(t), i, t.component, t, nd(e), id(e) + n.length, ad(t)) } else { const l = function (t, e, n) { if ("" === e.path) { if ("full" === e.pathMatch && (t.hasChildren() || n.length > 0)) throw new td; return { consumedSegments: [], lastChild: 0, parameters: {} } } const i = (e.matcher || xu)(n, t, e); if (!i) throw new td; const r = {}; Mu(i.posParams, (t, e) => { r[e] = t.path }); const s = i.consumed.length > 0 ? Object.assign({}, r, i.consumed[i.consumed.length - 1].parameters) : r; return { consumedSegments: i.consumed, lastChild: i.consumed.length, parameters: s } }(e, t, n); s = l.consumedSegments, o = n.slice(l.lastChild), r = new dh(s, l.parameters, Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, ld(t), i, t.component, t, nd(e), id(e) + s.length, ad(t)) } const l = function (t) { return t.children ? t.children : t.loadChildren ? t._loadedConfig.routes : [] }(t), { segmentGroup: a, slicedSegments: c } = rd(e, s, o, l, this.relativeLinkResolution); if (0 === c.length && a.hasChildren()) { const t = this.processChildren(l, a); return [new oh(r, t)] } if (0 === l.length && 0 === c.length) return [new oh(r, [])]; const u = this.processSegment(l, a, c, "primary"); return [new oh(r, u)] } } function nd(t) { let e = t; for (; e._sourceSegment;)e = e._sourceSegment; return e } function id(t) { let e = t, n = e._segmentIndexShift ? e._segmentIndexShift : 0; for (; e._sourceSegment;)e = e._sourceSegment, n += e._segmentIndexShift ? e._segmentIndexShift : 0; return n - 1 } function rd(t, e, n, i, r) { if (n.length > 0 && function (t, e, n) { return n.some(n => sd(t, e, n) && "primary" !== od(n)) }(t, n, i)) { const r = new Vu(e, function (t, e, n, i) { const r = {}; r.primary = i, i._sourceSegment = t, i._segmentIndexShift = e.length; for (const s of n) if ("" === s.path && "primary" !== od(s)) { const n = new Vu([], {}); n._sourceSegment = t, n._segmentIndexShift = e.length, r[od(s)] = n } return r }(t, e, i, new Vu(n, t.children))); return r._sourceSegment = t, r._segmentIndexShift = e.length, { segmentGroup: r, slicedSegments: [] } } if (0 === n.length && function (t, e, n) { return n.some(n => sd(t, e, n)) }(t, n, i)) { const s = new Vu(t.segments, function (t, e, n, i, r, s) { const o = {}; for (const l of i) if (sd(t, n, l) && !r[od(l)]) { const n = new Vu([], {}); n._sourceSegment = t, n._segmentIndexShift = "legacy" === s ? t.segments.length : e.length, o[od(l)] = n } return Object.assign({}, r, o) }(t, e, n, i, t.children, r)); return s._sourceSegment = t, s._segmentIndexShift = e.length, { segmentGroup: s, slicedSegments: n } } const s = new Vu(t.segments, t.children); return s._sourceSegment = t, s._segmentIndexShift = e.length, { segmentGroup: s, slicedSegments: n } } function sd(t, e, n) { return (!(t.hasChildren() || e.length > 0) || "full" !== n.pathMatch) && "" === n.path && void 0 === n.redirectTo } function od(t) { return t.outlet || "primary" } function ld(t) { return t.data || {} } function ad(t) { return t.resolve || {} } function cd(t, e, n, i) { const r = qh(t, e, i); return Du(r.resolve ? r.resolve(e, n) : r(e, n)) } function ud(t) { return function (e) { return e.pipe(Ua(e => { const n = t(e); return n ? q(n).pipe(H(() => e)) : q([e]) })) } } class hd { } class dd { shouldDetach(t) { return !1 } store(t, e) { } shouldAttach(t) { return !1 } retrieve(t) { return null } shouldReuseRoute(t, e) { return t.routeConfig === e.routeConfig } } const pd = new Tt("ROUTES"); class fd { constructor(t, e, n, i) { this.loader = t, this.compiler = e, this.onLoadStartListener = n, this.onLoadEndListener = i } load(t, e) { return this.onLoadStartListener && this.onLoadStartListener(e), this.loadModuleFactory(e.loadChildren).pipe(H(n => { this.onLoadEndListener && this.onLoadEndListener(e); const i = n.create(t); return new Tu(Ru(i.injector.get(pd)).map(Iu), i) })) } loadModuleFactory(t) { return "string" == typeof t ? q(this.loader.load(t)) : Du(t()).pipe(G(t => t instanceof Ge ? oa(t) : q(this.compiler.compileModuleAsync(t)))) } } class md { } class gd { shouldProcessUrl(t) { return !0 } extract(t) { return t } merge(t, e) { return t } } function _d(t) { throw t } function yd(t, e, n) { return e.parse("/") } function vd(t, e) { return oa(null) } class bd { constructor(t, e, n, i, r, s, o, l) { this.rootComponentType = t, this.urlSerializer = e, this.rootContexts = n, this.location = i, this.config = l, this.lastSuccessfulNavigation = null, this.currentNavigation = null, this.navigationId = 0, this.isNgZoneEnabled = !1, this.events = new k, this.errorHandler = _d, this.malformedUriErrorHandler = yd, this.navigated = !1, this.lastSuccessfulId = -1, this.hooks = { beforePreactivation: vd, afterPreactivation: vd }, this.urlHandlingStrategy = new gd, this.routeReuseStrategy = new dd, this.onSameUrlNavigation = "ignore", this.paramsInheritanceStrategy = "emptyOnly", this.urlUpdateStrategy = "deferred", this.relativeLinkResolution = "legacy", this.ngModule = r.get(qe), this.console = r.get(Ir); const a = r.get(Zr); this.isNgZoneEnabled = a instanceof Zr, this.resetConfig(l), this.currentUrlTree = new Lu(new Vu([], {}), {}, null), this.rawUrlTree = this.currentUrlTree, this.browserUrlTree = this.currentUrlTree, this.configLoader = new fd(s, o, t => this.triggerEvent(new fu(t)), t => this.triggerEvent(new mu(t))), this.routerState = ch(this.currentUrlTree, this.rootComponentType), this.transitions = new la({ id: 0, currentUrlTree: this.currentUrlTree, currentRawUrl: this.currentUrlTree, extractedUrl: this.urlHandlingStrategy.extract(this.currentUrlTree), urlAfterRedirects: this.urlHandlingStrategy.extract(this.currentUrlTree), rawUrl: this.currentUrlTree, extras: {}, resolve: null, reject: null, promise: Promise.resolve(!0), source: "imperative", restoredState: null, currentSnapshot: this.routerState.snapshot, targetSnapshot: null, currentRouterState: this.routerState, targetRouterState: null, guards: { canActivateChecks: [], canDeactivateChecks: [] }, guardsResult: null }), this.navigations = this.setupNavigations(this.transitions), this.processNavigations() } setupNavigations(t) { const e = this.events; return t.pipe(ma(t => 0 !== t.id), H(t => Object.assign({}, t, { extractedUrl: this.urlHandlingStrategy.extract(t.rawUrl) })), Ua(t => { let n = !1, i = !1; return oa(t).pipe(Sa(t => { this.currentNavigation = { id: t.id, initialUrl: t.currentRawUrl, extractedUrl: t.extractedUrl, trigger: t.source, extras: t.extras, previousNavigation: this.lastSuccessfulNavigation ? Object.assign({}, this.lastSuccessfulNavigation, { previousNavigation: null }) : null } }), Ua(t => { const n = !this.navigated || t.extractedUrl.toString() !== this.browserUrlTree.toString(); if (("reload" === this.onSameUrlNavigation || n) && this.urlHandlingStrategy.shouldProcessUrl(t.rawUrl)) return oa(t).pipe(Ua(t => { const n = this.transitions.getValue(); return e.next(new su(t.id, this.serializeUrl(t.extractedUrl), t.source, t.restoredState)), n !== this.transitions.getValue() ? ia : [t] }), Ua(t => Promise.resolve(t)), (i = this.ngModule.injector, r = this.configLoader, s = this.urlSerializer, o = this.config, function (t) { return t.pipe(Ua(t => function (t, e, n, i, r) { return new Vh(t, e, n, i, r).apply() }(i, r, s, t.extractedUrl, o).pipe(H(e => Object.assign({}, t, { urlAfterRedirects: e }))))) }), Sa(t => { this.currentNavigation = Object.assign({}, this.currentNavigation, { finalUrl: t.urlAfterRedirects }) }), function (t, e, n, i, r) { return function (s) { return s.pipe(G(s => function (t, e, n, i, r = "emptyOnly", s = "legacy") { return new ed(t, e, n, i, r, s).recognize() }(t, e, s.urlAfterRedirects, n(s.urlAfterRedirects), i, r).pipe(H(t => Object.assign({}, s, { targetSnapshot: t }))))) } }(this.rootComponentType, this.config, t => this.serializeUrl(t), this.paramsInheritanceStrategy, this.relativeLinkResolution), Sa(t => { "eager" === this.urlUpdateStrategy && (t.extras.skipLocationChange || this.setBrowserUrl(t.urlAfterRedirects, !!t.extras.replaceUrl, t.id, t.extras.state), this.browserUrlTree = t.urlAfterRedirects) }), Sa(t => { const n = new cu(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot); e.next(n) })); var i, r, s, o; if (n && this.rawUrlTree && this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)) { const { id: n, extractedUrl: i, source: r, restoredState: s, extras: o } = t, l = new su(n, this.serializeUrl(i), r, s); e.next(l); const a = ch(i, this.rootComponentType).snapshot; return oa(Object.assign({}, t, { targetSnapshot: a, urlAfterRedirects: i, extras: Object.assign({}, o, { skipLocationChange: !1, replaceUrl: !1 }) })) } return this.rawUrlTree = t.rawUrl, this.browserUrlTree = t.urlAfterRedirects, t.resolve(null), ia }), ud(t => { const { targetSnapshot: e, id: n, extractedUrl: i, rawUrl: r, extras: { skipLocationChange: s, replaceUrl: o } } = t; return this.hooks.beforePreactivation(e, { navigationId: n, appliedUrlTree: i, rawUrlTree: r, skipLocationChange: !!s, replaceUrl: !!o }) }), Sa(t => { const e = new uu(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot); this.triggerEvent(e) }), H(t => Object.assign({}, t, { guards: Wh(t.targetSnapshot, t.currentSnapshot, this.rootContexts) })), function (t, e) { return function (n) { return n.pipe(G(n => { const { targetSnapshot: i, currentSnapshot: r, guards: { canActivateChecks: s, canDeactivateChecks: o } } = n; return 0 === o.length && 0 === s.length ? oa(Object.assign({}, n, { guardsResult: !0 })) : function (t, e, n, i) { return q(t).pipe(G(t => function (t, e, n, i, r) { const s = e && e.routeConfig ? e.routeConfig.canDeactivate : null; return s && 0 !== s.length ? oa(s.map(s => { const o = qh(s, e, r); let l; if (function (t) { return t && Ah(t.canDeactivate) }(o)) l = Du(o.canDeactivate(t, e, n, i)); else { if (!Ah(o)) throw new Error("Invalid CanDeactivate guard"); l = Du(o(t, e, n, i)) } return l.pipe(Va()) })).pipe(Qh()) : oa(!0) }(t.component, t.route, n, e, i)), Va(t => !0 !== t, !0)) }(o, i, r, t).pipe(G(n => n && "boolean" == typeof n ? function (t, e, n, i) { return q(e).pipe(Za(e => q([Yh(e.route.parent, i), Kh(e.route, i), Jh(t, e.path, n), Xh(t, e.route, n)]).pipe(fa(), Va(t => !0 !== t, !0))), Va(t => !0 !== t, !0)) }(i, s, t, e) : oa(n)), H(t => Object.assign({}, n, { guardsResult: t }))) })) } }(this.ngModule.injector, t => this.triggerEvent(t)), Sa(t => { if (Rh(t.guardsResult)) { const e = Eu(`Redirecting to "${this.serializeUrl(t.guardsResult)}"`); throw e.url = t.guardsResult, e } }), Sa(t => { const e = new hu(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot, !!t.guardsResult); this.triggerEvent(e) }), ma(t => { if (!t.guardsResult) { this.resetUrlToCurrentUrlTree(); const n = new lu(t.id, this.serializeUrl(t.extractedUrl), ""); return e.next(n), t.resolve(!1), !1 } return !0 }), ud(t => { if (t.guards.canActivateChecks.length) return oa(t).pipe(Sa(t => { const e = new du(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot); this.triggerEvent(e) }), (e = this.paramsInheritanceStrategy, n = this.ngModule.injector, function (t) { return t.pipe(G(t => { const { targetSnapshot: i, guards: { canActivateChecks: r } } = t; return r.length ? q(r).pipe(Za(t => function (t, e, n, i) { return function (t, e, n, i) { const r = Object.keys(t); if (0 === r.length) return oa({}); if (1 === r.length) { const s = r[0]; return cd(t[s], e, n, i).pipe(H(t => ({ [s]: t }))) } const s = {}; return q(r).pipe(G(r => cd(t[r], e, n, i).pipe(H(t => (s[r] = t, t))))).pipe(Aa(), H(() => s)) }(t._resolve, t, e, i).pipe(H(e => (t._resolvedData = e, t.data = Object.assign({}, t.data, hh(t, n).resolve), null))) }(t.route, i, e, n)), function (t, e) { return arguments.length >= 2 ? function (n) { return v(Wa(t, e), ba(1), Pa(e))(n) } : function (e) { return v(Wa((e, n, i) => t(e, n, i + 1)), ba(1))(e) } }((t, e) => t), H(e => t)) : oa(t) })) }), Sa(t => { const e = new pu(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot); this.triggerEvent(e) })); var e, n }), ud(t => { const { targetSnapshot: e, id: n, extractedUrl: i, rawUrl: r, extras: { skipLocationChange: s, replaceUrl: o } } = t; return this.hooks.afterPreactivation(e, { navigationId: n, appliedUrlTree: i, rawUrlTree: r, skipLocationChange: !!s, replaceUrl: !!o }) }), H(t => { const e = function (t, e, n) { const i = function t(e, n, i) { if (i && e.shouldReuseRoute(n.value, i.value.snapshot)) { const r = i.value; r._futureSnapshot = n.value; const s = function (e, n, i) { return n.children.map(n => { for (const r of i.children) if (e.shouldReuseRoute(r.value.snapshot, n.value)) return t(e, n, r); return t(e, n) }) }(e, n, i); return new oh(r, s) } { const i = e.retrieve(n.value); if (i) { const t = i.route; return function t(e, n) { if (e.value.routeConfig !== n.value.routeConfig) throw new Error("Cannot reattach ActivatedRouteSnapshot created from a different route"); if (e.children.length !== n.children.length) throw new Error("Cannot reattach ActivatedRouteSnapshot with a different number of children"); n.value._futureSnapshot = e.value; for (let i = 0; i < e.children.length; ++i)t(e.children[i], n.children[i]) }(n, t), t } { const i = new uh(new la((r = n.value).url), new la(r.params), new la(r.queryParams), new la(r.fragment), new la(r.data), r.outlet, r.component, r), s = n.children.map(n => t(e, n)); return new oh(i, s) } } var r }(t, e._root, n ? n._root : void 0); return new ah(i, e) }(this.routeReuseStrategy, t.targetSnapshot, t.currentRouterState); return Object.assign({}, t, { targetRouterState: e }) }), Sa(t => { this.currentUrlTree = t.urlAfterRedirects, this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, t.rawUrl), this.routerState = t.targetRouterState, "deferred" === this.urlUpdateStrategy && (t.extras.skipLocationChange || this.setBrowserUrl(this.rawUrlTree, !!t.extras.replaceUrl, t.id, t.extras.state), this.browserUrlTree = t.urlAfterRedirects) }), (r = this.rootContexts, s = this.routeReuseStrategy, o = t => this.triggerEvent(t), H(t => (new Oh(s, t.targetRouterState, t.currentRouterState, o).activate(r), t))), Sa({ next() { n = !0 }, complete() { n = !0 } }), Qa(() => { if (!n && !i) { this.resetUrlToCurrentUrlTree(); const n = new lu(t.id, this.serializeUrl(t.extractedUrl), `Navigation ID ${t.id} is not equal to the current navigation id ${this.navigationId}`); e.next(n), t.resolve(!1) } this.currentNavigation = null }), Ra(n => { if (i = !0, (r = n) && r.ngNavigationCancelingError) { const i = Rh(n.url); i || (this.navigated = !0, this.resetStateAndUrl(t.currentRouterState, t.currentUrlTree, t.rawUrl)); const r = new lu(t.id, this.serializeUrl(t.extractedUrl), n.message); e.next(r), t.resolve(!1), i && this.navigateByUrl(n.url) } else { this.resetStateAndUrl(t.currentRouterState, t.currentUrlTree, t.rawUrl); const i = new au(t.id, this.serializeUrl(t.extractedUrl), n); e.next(i); try { t.resolve(this.errorHandler(n)) } catch (s) { t.reject(s) } } var r; return ia })); var r, s, o })) } resetRootComponentType(t) { this.rootComponentType = t, this.routerState.root.component = this.rootComponentType } getTransition() { const t = this.transitions.value; return t.urlAfterRedirects = this.browserUrlTree, t } setTransition(t) { this.transitions.next(Object.assign({}, this.getTransition(), t)) } initialNavigation() { this.setUpLocationChangeListener(), 0 === this.navigationId && this.navigateByUrl(this.location.path(!0), { replaceUrl: !0 }) } setUpLocationChangeListener() { this.locationSubscription || (this.locationSubscription = this.location.subscribe(t => { let e = this.parseUrl(t.url); const n = "popstate" === t.type ? "popstate" : "hashchange", i = t.state && t.state.navigationId ? t.state : null; setTimeout(() => { this.scheduleNavigation(e, n, i, { replaceUrl: !0 }) }, 0) })) } get url() { return this.serializeUrl(this.currentUrlTree) } getCurrentNavigation() { return this.currentNavigation } triggerEvent(t) { this.events.next(t) } resetConfig(t) { ku(t), this.config = t.map(Iu), this.navigated = !1, this.lastSuccessfulId = -1 } ngOnDestroy() { this.dispose() } dispose() { this.locationSubscription && (this.locationSubscription.unsubscribe(), this.locationSubscription = null) } createUrlTree(t, e = {}) { const { relativeTo: n, queryParams: i, fragment: r, preserveQueryParams: s, queryParamsHandling: o, preserveFragment: l } = e; Yt() && s && console && console.warn && console.warn("preserveQueryParams is deprecated, use queryParamsHandling instead."); const a = n || this.routerState.root, c = l ? this.currentUrlTree.fragment : r; let u = null; if (o) switch (o) { case "merge": u = Object.assign({}, this.currentUrlTree.queryParams, i); break; case "preserve": u = this.currentUrlTree.queryParams; break; default: u = i || null } else u = s ? this.currentUrlTree.queryParams : i || null; return null !== u && (u = this.removeEmptyProps(u)), function (t, e, n, i, r) { if (0 === n.length) return vh(e.root, e.root, e, i, r); const s = function (t) { if ("string" == typeof t[0] && 1 === t.length && "/" === t[0]) return new bh(!0, 0, t); let e = 0, n = !1; const i = t.reduce((t, i, r) => { if ("object" == typeof i && null != i) { if (i.outlets) { const e = {}; return Mu(i.outlets, (t, n) => { e[n] = "string" == typeof t ? t.split("/") : t }), [...t, { outlets: e }] } if (i.segmentPath) return [...t, i.segmentPath] } return "string" != typeof i ? [...t, i] : 0 === r ? (i.split("/").forEach((i, r) => { 0 == r && "." === i || (0 == r && "" === i ? n = !0 : ".." === i ? e++ : "" != i && t.push(i)) }), t) : [...t, i] }, []); return new bh(n, e, i) }(n); if (s.toRoot()) return vh(e.root, new Vu([], {}), e, i, r); const o = function (t, e, n) { if (t.isAbsolute) return new wh(e.root, !0, 0); if (-1 === n.snapshot._lastPathIndex) return new wh(n.snapshot._urlSegment, !0, 0); const i = yh(t.commands[0]) ? 0 : 1; return function (t, e, n) { let i = t, r = e, s = n; for (; s > r;) { if (s -= r, i = i.parent, !i) throw new Error("Invalid number of '../'"); r = i.segments.length } return new wh(i, !1, r - s) }(n.snapshot._urlSegment, n.snapshot._lastPathIndex + i, t.numberOfDoubleDots) }(s, e, t), l = o.processChildren ? Eh(o.segmentGroup, o.index, s.commands) : Sh(o.segmentGroup, o.index, s.commands); return vh(o.segmentGroup, l, e, i, r) }(a, this.currentUrlTree, t, u, c) } navigateByUrl(t, e = { skipLocationChange: !1 }) { Yt() && this.isNgZoneEnabled && !Zr.isInAngularZone() && this.console.warn("Navigation triggered outside Angular zone, did you forget to call 'ngZone.run()'?"); const n = Rh(t) ? t : this.parseUrl(t), i = this.urlHandlingStrategy.merge(n, this.rawUrlTree); return this.scheduleNavigation(i, "imperative", null, e) } navigate(t, e = { skipLocationChange: !1 }) { return function (t) { for (let e = 0; e < t.length; e++) { const n = t[e]; if (null == n) throw new Error(`The requested path contains ${n} segment at index ${e}`) } }(t), this.navigateByUrl(this.createUrlTree(t, e), e) } serializeUrl(t) { return this.urlSerializer.serialize(t) } parseUrl(t) { let e; try { e = this.urlSerializer.parse(t) } catch (n) { e = this.malformedUriErrorHandler(n, this.urlSerializer, t) } return e } isActive(t, e) { if (Rh(t)) return Fu(this.currentUrlTree, t, e); const n = this.parseUrl(t); return Fu(this.currentUrlTree, n, e) } removeEmptyProps(t) { return Object.keys(t).reduce((e, n) => { const i = t[n]; return null != i && (e[n] = i), e }, {}) } processNavigations() { this.navigations.subscribe(t => { this.navigated = !0, this.lastSuccessfulId = t.id, this.events.next(new ou(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(this.currentUrlTree))), this.lastSuccessfulNavigation = this.currentNavigation, this.currentNavigation = null, t.resolve(!0) }, t => { this.console.warn("Unhandled Navigation Error: ") }) } scheduleNavigation(t, e, n, i) { const r = this.getTransition(); if (r && "imperative" !== e && "imperative" === r.source && r.rawUrl.toString() === t.toString()) return Promise.resolve(!0); if (r && "hashchange" == e && "popstate" === r.source && r.rawUrl.toString() === t.toString()) return Promise.resolve(!0); if (r && "popstate" == e && "hashchange" === r.source && r.rawUrl.toString() === t.toString()) return Promise.resolve(!0); let s = null, o = null; const l = new Promise((t, e) => { s = t, o = e }), a = ++this.navigationId; return this.setTransition({ id: a, source: e, restoredState: n, currentUrlTree: this.currentUrlTree, currentRawUrl: this.rawUrlTree, rawUrl: t, extras: i, resolve: s, reject: o, promise: l, currentSnapshot: this.routerState.snapshot, currentRouterState: this.routerState }), l.catch(t => Promise.reject(t)) } setBrowserUrl(t, e, n, i) { const r = this.urlSerializer.serialize(t); i = i || {}, this.location.isCurrentPathEqualTo(r) || e ? this.location.replaceState(r, "", Object.assign({}, i, { navigationId: n })) : this.location.go(r, "", Object.assign({}, i, { navigationId: n })) } resetStateAndUrl(t, e, n) { this.routerState = t, this.currentUrlTree = e, this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, n), this.resetUrlToCurrentUrlTree() } resetUrlToCurrentUrlTree() { this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), "", { navigationId: this.lastSuccessfulId }) } } let wd = (() => class { constructor(t, e, n) { this.router = t, this.route = e, this.locationStrategy = n, this.commands = [], this.subscription = t.events.subscribe(t => { t instanceof ou && this.updateTargetUrlAndHref() }) } set routerLink(t) { this.commands = null != t ? Array.isArray(t) ? t : [t] : [] } set preserveQueryParams(t) { Yt() && console && console.warn && console.warn("preserveQueryParams is deprecated, use queryParamsHandling instead."), this.preserve = t } ngOnChanges(t) { this.updateTargetUrlAndHref() } ngOnDestroy() { this.subscription.unsubscribe() } onClick(t, e, n, i) { if (0 !== t || e || n || i) return !0; if ("string" == typeof this.target && "_self" != this.target) return !0; const r = { skipLocationChange: Cd(this.skipLocationChange), replaceUrl: Cd(this.replaceUrl), state: this.state }; return this.router.navigateByUrl(this.urlTree, r), !1 } updateTargetUrlAndHref() { this.href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.urlTree)) } get urlTree() { return this.router.createUrlTree(this.commands, { relativeTo: this.route, queryParams: this.queryParams, fragment: this.fragment, preserveQueryParams: Cd(this.preserve), queryParamsHandling: this.queryParamsHandling, preserveFragment: Cd(this.preserveFragment) }) } })(); function Cd(t) { return "" === t || !!t } class Sd { constructor() { this.outlet = null, this.route = null, this.resolver = null, this.children = new Ed, this.attachRef = null } } class Ed { constructor() { this.contexts = new Map } onChildOutletCreated(t, e) { const n = this.getOrCreateContext(t); n.outlet = e, this.contexts.set(t, n) } onChildOutletDestroyed(t) { const e = this.getContext(t); e && (e.outlet = null) } onOutletDeactivated() { const t = this.contexts; return this.contexts = new Map, t } onOutletReAttached(t) { this.contexts = t } getOrCreateContext(t) { let e = this.getContext(t); return e || (e = new Sd, this.contexts.set(t, e)), e } getContext(t) { return this.contexts.get(t) || null } } let xd = (() => class { constructor(t, e, n, i, r) { this.parentContexts = t, this.location = e, this.resolver = n, this.changeDetector = r, this.activated = null, this._activatedRoute = null, this.activateEvents = new vr, this.deactivateEvents = new vr, this.name = i || "primary", t.onChildOutletCreated(this.name, this) } ngOnDestroy() { this.parentContexts.onChildOutletDestroyed(this.name) } ngOnInit() { if (!this.activated) { const t = this.parentContexts.getContext(this.name); t && t.route && (t.attachRef ? this.attach(t.attachRef, t.route) : this.activateWith(t.route, t.resolver || null)) } } get isActivated() { return !!this.activated } get component() { if (!this.activated) throw new Error("Outlet is not activated"); return this.activated.instance } get activatedRoute() { if (!this.activated) throw new Error("Outlet is not activated"); return this._activatedRoute } get activatedRouteData() { return this._activatedRoute ? this._activatedRoute.snapshot.data : {} } detach() { if (!this.activated) throw new Error("Outlet is not activated"); this.location.detach(); const t = this.activated; return this.activated = null, this._activatedRoute = null, t } attach(t, e) { this.activated = t, this._activatedRoute = e, this.location.insert(t.hostView) } deactivate() { if (this.activated) { const t = this.component; this.activated.destroy(), this.activated = null, this._activatedRoute = null, this.deactivateEvents.emit(t) } } activateWith(t, e) { if (this.isActivated) throw new Error("Cannot activate an already activated outlet"); this._activatedRoute = t; const n = (e = e || this.resolver).resolveComponentFactory(t._futureSnapshot.routeConfig.component), i = this.parentContexts.getOrCreateContext(this.name).children, r = new Td(t, i, this.location.injector); this.activated = this.location.createComponent(n, this.location.length, r), this.changeDetector.markForCheck(), this.activateEvents.emit(this.activated.instance) } })(); class Td { constructor(t, e, n) { this.route = t, this.childContexts = e, this.parent = n } get(t, e) { return t === uh ? this.route : t === Ed ? this.childContexts : this.parent.get(t, e) } } class kd { } class Pd { preload(t, e) { return e().pipe(Ra(() => oa(null))) } } class Od { preload(t, e) { return oa(null) } } let Id = (() => class { constructor(t, e, n, i, r) { this.router = t, this.injector = i, this.preloadingStrategy = r, this.loader = new fd(e, n, e => t.triggerEvent(new fu(e)), e => t.triggerEvent(new mu(e))) } setUpPreloading() { this.subscription = this.router.events.pipe(ma(t => t instanceof ou), Za(() => this.preload())).subscribe(() => { }) } preload() { const t = this.injector.get(qe); return this.processRoutes(t, this.router.config) } ngOnDestroy() { this.subscription.unsubscribe() } processRoutes(t, e) { const n = []; for (const i of e) if (i.loadChildren && !i.canLoad && i._loadedConfig) { const t = i._loadedConfig; n.push(this.processRoutes(t.module, t.routes)) } else i.loadChildren && !i.canLoad ? n.push(this.preloadConfig(t, i)) : i.children && n.push(this.processRoutes(t, i.children)); return q(n).pipe(Y(), H(t => { })) } preloadConfig(t, e) { return this.preloadingStrategy.preload(e, () => this.loader.load(t.injector, e).pipe(G(t => (e._loadedConfig = t, this.processRoutes(t.module, t.routes))))) } })(); class Ad { constructor(t, e, n = {}) { this.router = t, this.viewportScroller = e, this.options = n, this.lastId = 0, this.lastSource = "imperative", this.restoredId = 0, this.store = {}, n.scrollPositionRestoration = n.scrollPositionRestoration || "disabled", n.anchorScrolling = n.anchorScrolling || "disabled" } init() { "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.setHistoryScrollRestoration("manual"), this.routerEventsSubscription = this.createScrollEvents(), this.scrollEventsSubscription = this.consumeScrollEvents() } createScrollEvents() { return this.router.events.subscribe(t => { t instanceof su ? (this.store[this.lastId] = this.viewportScroller.getScrollPosition(), this.lastSource = t.navigationTrigger, this.restoredId = t.restoredState ? t.restoredState.navigationId : 0) : t instanceof ou && (this.lastId = t.id, this.scheduleScrollEvent(t, this.router.parseUrl(t.urlAfterRedirects).fragment)) }) } consumeScrollEvents() { return this.router.events.subscribe(t => { t instanceof bu && (t.position ? "top" === this.options.scrollPositionRestoration ? this.viewportScroller.scrollToPosition([0, 0]) : "enabled" === this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition(t.position) : t.anchor && "enabled" === this.options.anchorScrolling ? this.viewportScroller.scrollToAnchor(t.anchor) : "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition([0, 0])) }) } scheduleScrollEvent(t, e) { this.router.triggerEvent(new bu(t, "popstate" === this.lastSource ? this.store[this.restoredId] : null, e)) } ngOnDestroy() { this.routerEventsSubscription && this.routerEventsSubscription.unsubscribe(), this.scrollEventsSubscription && this.scrollEventsSubscription.unsubscribe() } } const Rd = new Tt("ROUTER_CONFIGURATION"), Nd = new Tt("ROUTER_FORROOT_GUARD"), Md = [al, { provide: Hu, useClass: Bu }, { provide: bd, useFactory: Ud, deps: [ds, Hu, Ed, al, zt, fs, zr, pd, Rd, [md, new ct], [hd, new ct]] }, Ed, { provide: uh, useFactory: Hd, deps: [bd] }, { provide: fs, useClass: _s }, Id, Od, Pd, { provide: Rd, useValue: { enableTracing: !1 } }]; function Dd() { return new ls("Router", bd) } let Fd = (() => { class t { constructor(t, e) { } static forRoot(e, n) { return { ngModule: t, providers: [Md, jd(e), { provide: Nd, useFactory: zd, deps: [[bd, new ct, new ht]] }, { provide: Rd, useValue: n || {} }, { provide: ol, useFactory: Vd, deps: [rl, [new at(ll), new ct], Rd] }, { provide: Ad, useFactory: Ld, deps: [bd, ea, Rd] }, { provide: kd, useExisting: n && n.preloadingStrategy ? n.preloadingStrategy : Od }, { provide: ls, multi: !0, useFactory: Dd }, [Bd, { provide: Cr, multi: !0, useFactory: $d, deps: [Bd] }, { provide: qd, useFactory: Wd, deps: [Bd] }, { provide: Or, multi: !0, useExisting: qd }]] } } static forChild(e) { return { ngModule: t, providers: [jd(e)] } } } return t })(); function Ld(t, e, n) { return n.scrollOffset && e.setOffset(n.scrollOffset), new Ad(t, e, n) } function Vd(t, e, n = {}) { return n.useHash ? new ul(t, e) : new hl(t, e) } function zd(t) { if (t) throw new Error("RouterModule.forRoot() called twice. Lazy loaded modules should use RouterModule.forChild() instead."); return "guarded" } function jd(t) { return [{ provide: Gt, multi: !0, useValue: t }, { provide: pd, multi: !0, useValue: t }] } function Ud(t, e, n, i, r, s, o, l, a = {}, c, u) { const h = new bd(null, e, n, i, r, s, o, Ru(l)); if (c && (h.urlHandlingStrategy = c), u && (h.routeReuseStrategy = u), a.errorHandler && (h.errorHandler = a.errorHandler), a.malformedUriErrorHandler && (h.malformedUriErrorHandler = a.malformedUriErrorHandler), a.enableTracing) { const t = Ja(); h.events.subscribe(e => { t.logGroup("Router Event: " + e.constructor.name), t.log(e.toString()), t.log(e), t.logGroupEnd() }) } return a.onSameUrlNavigation && (h.onSameUrlNavigation = a.onSameUrlNavigation), a.paramsInheritanceStrategy && (h.paramsInheritanceStrategy = a.paramsInheritanceStrategy), a.urlUpdateStrategy && (h.urlUpdateStrategy = a.urlUpdateStrategy), a.relativeLinkResolution && (h.relativeLinkResolution = a.relativeLinkResolution), h } function Hd(t) { return t.routerState.root } let Bd = (() => class { constructor(t) { this.injector = t, this.initNavigation = !1, this.resultOfPreactivationDone = new k } appInitializer() { return this.injector.get(sl, Promise.resolve(null)).then(() => { let t = null; const e = new Promise(e => t = e), n = this.injector.get(bd), i = this.injector.get(Rd); if (this.isLegacyDisabled(i) || this.isLegacyEnabled(i)) t(!0); else if ("disabled" === i.initialNavigation) n.setUpLocationChangeListener(), t(!0); else { if ("enabled" !== i.initialNavigation) throw new Error(`Invalid initialNavigation options: '${i.initialNavigation}'`); n.hooks.afterPreactivation = () => this.initNavigation ? oa(null) : (this.initNavigation = !0, t(!0), this.resultOfPreactivationDone), n.initialNavigation() } return e }) } bootstrapListener(t) { const e = this.injector.get(Rd), n = this.injector.get(Id), i = this.injector.get(Ad), r = this.injector.get(bd), s = this.injector.get(ds); t === s.components[0] && (this.isLegacyEnabled(e) ? r.initialNavigation() : this.isLegacyDisabled(e) && r.setUpLocationChangeListener(), n.setUpPreloading(), i.init(), r.resetRootComponentType(s.componentTypes[0]), this.resultOfPreactivationDone.next(null), this.resultOfPreactivationDone.complete()) } isLegacyEnabled(t) { return "legacy_enabled" === t.initialNavigation || !0 === t.initialNavigation || void 0 === t.initialNavigation } isLegacyDisabled(t) { return "legacy_disabled" === t.initialNavigation || !1 === t.initialNavigation } })(); function $d(t) { return t.appInitializer.bind(t) } function Wd(t) { return t.bootstrapListener.bind(t) } const qd = new Tt("Router Initializer"); var Gd = jn({ encapsulation: 2, styles: [], data: {} }); function Zd(t) { return Zs(0, [(t()(), Rs(0, 16777216, null, null, 1, "router-outlet", [], null, null, null, null, null)), Ki(1, 212992, null, 0, xd, [Ed, En, Be, [8, null], _n], null, null)], (function (t, e) { t(e, 1, 0) }), null) } function Qd(t) { return Zs(0, [(t()(), Rs(0, 0, null, null, 1, "ng-component", [], null, null, null, Zd, Gd)), Ki(1, 49152, null, 0, wu, [], null, null)], null, null) } var Kd = Ti("ng-component", wu, Qd, {}, {}, []); class Yd { } function Xd(t, e = null) { return { type: 2, steps: t, options: e } } function Jd(t) { return { type: 6, styles: t, offset: null } } function tp(t) { Promise.resolve(null).then(t) } class ep { constructor(t = 0, e = 0) { this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._started = !1, this._destroyed = !1, this._finished = !1, this.parentPlayer = null, this.totalTime = t + e } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(t => t()), this._onDoneFns = []) } onStart(t) { this._onStartFns.push(t) } onDone(t) { this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } hasStarted() { return this._started } init() { } play() { this.hasStarted() || (this._onStart(), this.triggerMicrotask()), this._started = !0 } triggerMicrotask() { tp(() => this._onFinish()) } _onStart() { this._onStartFns.forEach(t => t()), this._onStartFns = [] } pause() { } restart() { } finish() { this._onFinish() } destroy() { this._destroyed || (this._destroyed = !0, this.hasStarted() || this._onStart(), this.finish(), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } reset() { } setPosition(t) { } getPosition() { return 0 } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns; e.forEach(t => t()), e.length = 0 } } class np { constructor(t) { this._onDoneFns = [], this._onStartFns = [], this._finished = !1, this._started = !1, this._destroyed = !1, this._onDestroyFns = [], this.parentPlayer = null, this.totalTime = 0, this.players = t; let e = 0, n = 0, i = 0; const r = this.players.length; 0 == r ? tp(() => this._onFinish()) : this.players.forEach(t => { t.onDone(() => { ++e == r && this._onFinish() }), t.onDestroy(() => { ++n == r && this._onDestroy() }), t.onStart(() => { ++i == r && this._onStart() }) }), this.totalTime = this.players.reduce((t, e) => Math.max(t, e.totalTime), 0) } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(t => t()), this._onDoneFns = []) } init() { this.players.forEach(t => t.init()) } onStart(t) { this._onStartFns.push(t) } _onStart() { this.hasStarted() || (this._started = !0, this._onStartFns.forEach(t => t()), this._onStartFns = []) } onDone(t) { this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } hasStarted() { return this._started } play() { this.parentPlayer || this.init(), this._onStart(), this.players.forEach(t => t.play()) } pause() { this.players.forEach(t => t.pause()) } restart() { this.players.forEach(t => t.restart()) } finish() { this._onFinish(), this.players.forEach(t => t.finish()) } destroy() { this._onDestroy() } _onDestroy() { this._destroyed || (this._destroyed = !0, this._onFinish(), this.players.forEach(t => t.destroy()), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } reset() { this.players.forEach(t => t.reset()), this._destroyed = !1, this._finished = !1, this._started = !1 } setPosition(t) { const e = t * this.totalTime; this.players.forEach(t => { const n = t.totalTime ? Math.min(1, e / t.totalTime) : 1; t.setPosition(n) }) } getPosition() { let t = 0; return this.players.forEach(e => { const n = e.getPosition(); t = Math.min(n, t) }), t } beforeDestroy() { this.players.forEach(t => { t.beforeDestroy && t.beforeDestroy() }) } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns; e.forEach(t => t()), e.length = 0 } } function ip(t) { return null != t && "" + t != "false" } function rp(t) { return Array.isArray(t) ? t : [t] } function sp(t) { return null == t ? "" : "string" == typeof t ? t : t + "px" } function op(t) { return t instanceof Qe ? t.nativeElement : t } const lp = new nn("8.2.3"); let ap; try { ap = "undefined" != typeof Intl && Intl.v8BreakIterator } catch (aC) { ap = !1 } let cp, up = (() => { class t { constructor(t) { this._platformId = t, this.isBrowser = this._platformId ? "browser" === this._platformId : "object" == typeof document && !!document, this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent), this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent), this.BLINK = this.isBrowser && !(!window.chrome && !ap) && "undefined" != typeof CSS && !this.EDGE && !this.TRIDENT, this.WEBKIT = this.isBrowser && /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT, this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !("MSStream" in window), this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent), this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT, this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT } } return t.ngInjectableDef = ft({ factory: function () { return new t(Nt(Pr, 8)) }, token: t, providedIn: "root" }), t })(), hp = (() => class { })(); const dp = ["color", "button", "checkbox", "date", "datetime-local", "email", "file", "hidden", "image", "month", "number", "password", "radio", "range", "reset", "search", "submit", "tel", "text", "time", "url", "week"]; function pp() { if (cp) return cp; if ("object" != typeof document || !document) return cp = new Set(dp), cp; let t = document.createElement("input"); return cp = new Set(dp.filter(e => (t.setAttribute("type", e), t.type === e))), cp } let fp; function mp(t) { return function () { if (null == fp && "undefined" != typeof window) try { window.addEventListener("test", null, Object.defineProperty({}, "passive", { get: () => fp = !0 })) } finally { fp = fp || !1 } return fp }() ? t : !!t.capture } class gp extends d { constructor(t, e) { super() } schedule(t, e = 0) { return this } } class _p extends gp { constructor(t, e) { super(t, e), this.scheduler = t, this.work = e, this.pending = !1 } schedule(t, e = 0) { if (this.closed) return this; this.state = t; const n = this.id, i = this.scheduler; return null != n && (this.id = this.recycleAsyncId(i, n, e)), this.pending = !0, this.delay = e, this.id = this.id || this.requestAsyncId(i, this.id, e), this } requestAsyncId(t, e, n = 0) { return setInterval(t.flush.bind(t, this), n) } recycleAsyncId(t, e, n = 0) { if (null !== n && this.delay === n && !1 === this.pending) return e; clearInterval(e) } execute(t, e) { if (this.closed) return new Error("executing a cancelled action"); this.pending = !1; const n = this._execute(t, e); if (n) return n; !1 === this.pending && null != this.id && (this.id = this.recycleAsyncId(this.scheduler, this.id, null)) } _execute(t, e) { let n = !1, i = void 0; try { this.work(t) } catch (r) { n = !0, i = !!r && r || new Error(r) } if (n) return this.unsubscribe(), i } _unsubscribe() { const t = this.id, e = this.scheduler, n = e.actions, i = n.indexOf(this); this.work = null, this.state = null, this.pending = !1, this.scheduler = null, -1 !== i && n.splice(i, 1), null != t && (this.id = this.recycleAsyncId(e, t, null)), this.delay = null } } let yp = (() => { class t { constructor(e, n = t.now) { this.SchedulerAction = e, this.now = n } schedule(t, e = 0, n) { return new this.SchedulerAction(this, t).schedule(n, e) } } return t.now = () => Date.now(), t })(); class vp extends yp { constructor(t, e = yp.now) { super(t, () => vp.delegate && vp.delegate !== this ? vp.delegate.now() : e()), this.actions = [], this.active = !1, this.scheduled = void 0 } schedule(t, e = 0, n) { return vp.delegate && vp.delegate !== this ? vp.delegate.schedule(t, e, n) : super.schedule(t, e, n) } flush(t) { const { actions: e } = this; if (this.active) return void e.push(t); let n; this.active = !0; do { if (n = t.execute(t.state, t.delay)) break } while (t = e.shift()); if (this.active = !1, n) { for (; t = e.shift();)t.unsubscribe(); throw n } } } const bp = new vp(_p); function wp(t, e = bp) { return n => n.lift(new Cp(t, e)) } class Cp { constructor(t, e) { this.dueTime = t, this.scheduler = e } call(t, e) { return e.subscribe(new Sp(t, this.dueTime, this.scheduler)) } } class Sp extends m { constructor(t, e, n) { super(t), this.dueTime = e, this.scheduler = n, this.debouncedSubscription = null, this.lastValue = null, this.hasValue = !1 } _next(t) { this.clearDebounce(), this.lastValue = t, this.hasValue = !0, this.add(this.debouncedSubscription = this.scheduler.schedule(Ep, this.dueTime, this)) } _complete() { this.debouncedNext(), this.destination.complete() } debouncedNext() { if (this.clearDebounce(), this.hasValue) { const { lastValue: t } = this; this.lastValue = null, this.hasValue = !1, this.destination.next(t) } } clearDebounce() { const t = this.debouncedSubscription; null !== t && (this.remove(t), t.unsubscribe(), this.debouncedSubscription = null) } } function Ep(t) { t.debouncedNext() } let xp = (() => { class t { constructor(t) { this._platform = t } isDisabled(t) { return t.hasAttribute("disabled") } isVisible(t) { return function (t) { return !!(t.offsetWidth || t.offsetHeight || "function" == typeof t.getClientRects && t.getClientRects().length) }(t) && "visible" === getComputedStyle(t).visibility } isTabbable(t) { if (!this._platform.isBrowser) return !1; const e = function (t) { try { return t.frameElement } catch (aC) { return null } }((n = t).ownerDocument && n.ownerDocument.defaultView || window); var n; if (e) { const t = e && e.nodeName.toLowerCase(); if (-1 === kp(e)) return !1; if ((this._platform.BLINK || this._platform.WEBKIT) && "object" === t) return !1; if ((this._platform.BLINK || this._platform.WEBKIT) && !this.isVisible(e)) return !1 } let i = t.nodeName.toLowerCase(), r = kp(t); if (t.hasAttribute("contenteditable")) return -1 !== r; if ("iframe" === i) return !1; if ("audio" === i) { if (!t.hasAttribute("controls")) return !1; if (this._platform.BLINK) return !0 } if ("video" === i) { if (!t.hasAttribute("controls") && this._platform.TRIDENT) return !1; if (this._platform.BLINK || this._platform.FIREFOX) return !0 } return ("object" !== i || !this._platform.BLINK && !this._platform.WEBKIT) && !(this._platform.WEBKIT && this._platform.IOS && !function (t) { let e = t.nodeName.toLowerCase(), n = "input" === e && t.type; return "text" === n || "password" === n || "select" === e || "textarea" === e }(t)) && t.tabIndex >= 0 } isFocusable(t) { return function (t) { return !function (t) { return function (t) { return "input" == t.nodeName.toLowerCase() }(t) && "hidden" == t.type }(t) && (function (t) { let e = t.nodeName.toLowerCase(); return "input" === e || "select" === e || "button" === e || "textarea" === e }(t) || function (t) { return function (t) { return "a" == t.nodeName.toLowerCase() }(t) && t.hasAttribute("href") }(t) || t.hasAttribute("contenteditable") || Tp(t)) }(t) && !this.isDisabled(t) && this.isVisible(t) } } return t.ngInjectableDef = ft({ factory: function () { return new t(Nt(up)) }, token: t, providedIn: "root" }), t })(); function Tp(t) { if (!t.hasAttribute("tabindex") || void 0 === t.tabIndex) return !1; let e = t.getAttribute("tabindex"); return "-32768" != e && !(!e || isNaN(parseInt(e, 10))) } function kp(t) { if (!Tp(t)) return null; const e = parseInt(t.getAttribute("tabindex") || "", 10); return isNaN(e) ? -1 : e } class Pp { constructor(t, e, n, i, r = !1) { this._element = t, this._checker = e, this._ngZone = n, this._document = i, this._hasAttached = !1, this.startAnchorListener = () => this.focusLastTabbableElement(), this.endAnchorListener = () => this.focusFirstTabbableElement(), this._enabled = !0, r || this.attachAnchors() } get enabled() { return this._enabled } set enabled(t) { this._enabled = t, this._startAnchor && this._endAnchor && (this._toggleAnchorTabIndex(t, this._startAnchor), this._toggleAnchorTabIndex(t, this._endAnchor)) } destroy() { const t = this._startAnchor, e = this._endAnchor; t && (t.removeEventListener("focus", this.startAnchorListener), t.parentNode && t.parentNode.removeChild(t)), e && (e.removeEventListener("focus", this.endAnchorListener), e.parentNode && e.parentNode.removeChild(e)), this._startAnchor = this._endAnchor = null } attachAnchors() { return !!this._hasAttached || (this._ngZone.runOutsideAngular(() => { this._startAnchor || (this._startAnchor = this._createAnchor(), this._startAnchor.addEventListener("focus", this.startAnchorListener)), this._endAnchor || (this._endAnchor = this._createAnchor(), this._endAnchor.addEventListener("focus", this.endAnchorListener)) }), this._element.parentNode && (this._element.parentNode.insertBefore(this._startAnchor, this._element), this._element.parentNode.insertBefore(this._endAnchor, this._element.nextSibling), this._hasAttached = !0), this._hasAttached) } focusInitialElementWhenReady() { return new Promise(t => { this._executeOnStable(() => t(this.focusInitialElement())) }) } focusFirstTabbableElementWhenReady() { return new Promise(t => { this._executeOnStable(() => t(this.focusFirstTabbableElement())) }) } focusLastTabbableElementWhenReady() { return new Promise(t => { this._executeOnStable(() => t(this.focusLastTabbableElement())) }) } _getRegionBoundary(t) { let e = this._element.querySelectorAll(`[cdk-focus-region-${t}], [cdkFocusRegion${t}], [cdk-focus-${t}]`); for (let n = 0; n < e.length; n++)e[n].hasAttribute("cdk-focus-" + t) ? console.warn(`Found use of deprecated attribute 'cdk-focus-${t}', use 'cdkFocusRegion${t}' instead. The deprecated attribute will be removed in 8.0.0.`, e[n]) : e[n].hasAttribute("cdk-focus-region-" + t) && console.warn(`Found use of deprecated attribute 'cdk-focus-region-${t}', use 'cdkFocusRegion${t}' instead. The deprecated attribute will be removed in 8.0.0.`, e[n]); return "start" == t ? e.length ? e[0] : this._getFirstTabbableElement(this._element) : e.length ? e[e.length - 1] : this._getLastTabbableElement(this._element) } focusInitialElement() { const t = this._element.querySelector("[cdk-focus-initial], [cdkFocusInitial]"); return t ? (t.hasAttribute("cdk-focus-initial") && console.warn("Found use of deprecated attribute 'cdk-focus-initial', use 'cdkFocusInitial' instead. The deprecated attribute will be removed in 8.0.0", t), Yt() && !this._checker.isFocusable(t) && console.warn("Element matching '[cdkFocusInitial]' is not focusable.", t), t.focus(), !0) : this.focusFirstTabbableElement() } focusFirstTabbableElement() { const t = this._getRegionBoundary("start"); return t && t.focus(), !!t } focusLastTabbableElement() { const t = this._getRegionBoundary("end"); return t && t.focus(), !!t } hasAttached() { return this._hasAttached } _getFirstTabbableElement(t) { if (this._checker.isFocusable(t) && this._checker.isTabbable(t)) return t; let e = t.children || t.childNodes; for (let n = 0; n < e.length; n++) { let t = e[n].nodeType === this._document.ELEMENT_NODE ? this._getFirstTabbableElement(e[n]) : null; if (t) return t } return null } _getLastTabbableElement(t) { if (this._checker.isFocusable(t) && this._checker.isTabbable(t)) return t; let e = t.children || t.childNodes; for (let n = e.length - 1; n >= 0; n--) { let t = e[n].nodeType === this._document.ELEMENT_NODE ? this._getLastTabbableElement(e[n]) : null; if (t) return t } return null } _createAnchor() { const t = this._document.createElement("div"); return this._toggleAnchorTabIndex(this._enabled, t), t.classList.add("cdk-visually-hidden"), t.classList.add("cdk-focus-trap-anchor"), t.setAttribute("aria-hidden", "true"), t } _toggleAnchorTabIndex(t, e) { t ? e.setAttribute("tabindex", "0") : e.removeAttribute("tabindex") } _executeOnStable(t) { this._ngZone.isStable ? t() : this._ngZone.onStable.asObservable().pipe(Da(1)).subscribe(t) } } let Op = (() => { class t { constructor(t, e, n) { this._checker = t, this._ngZone = e, this._document = n } create(t, e = !1) { return new Pp(t, this._checker, this._ngZone, this._document, e) } } return t.ngInjectableDef = ft({ factory: function () { return new t(Nt(xp), Nt(Zr), Nt(ta)) }, token: t, providedIn: "root" }), t })(); const Ip = mp({ passive: !0, capture: !0 }); let Ap = (() => { class t { constructor(t, e) { this._ngZone = t, this._platform = e, this._origin = null, this._windowFocused = !1, this._elementInfo = new Map, this._monitoredElementCount = 0, this._documentKeydownListener = () => { this._lastTouchTarget = null, this._setOriginForCurrentEventQueue("keyboard") }, this._documentMousedownListener = () => { this._lastTouchTarget || this._setOriginForCurrentEventQueue("mouse") }, this._documentTouchstartListener = t => { null != this._touchTimeoutId && clearTimeout(this._touchTimeoutId), this._lastTouchTarget = t.composedPath ? t.composedPath()[0] : t.target, this._touchTimeoutId = setTimeout(() => this._lastTouchTarget = null, 650) }, this._windowFocusListener = () => { this._windowFocused = !0, this._windowFocusTimeoutId = setTimeout(() => this._windowFocused = !1) } } monitor(t, e = !1) { if (!this._platform.isBrowser) return oa(null); const n = op(t); if (this._elementInfo.has(n)) { let t = this._elementInfo.get(n); return t.checkChildren = e, t.subject.asObservable() } let i = { unlisten: () => { }, checkChildren: e, subject: new k }; this._elementInfo.set(n, i), this._incrementMonitoredElementCount(); let r = t => this._onFocus(t, n), s = t => this._onBlur(t, n); return this._ngZone.runOutsideAngular(() => { n.addEventListener("focus", r, !0), n.addEventListener("blur", s, !0) }), i.unlisten = () => { n.removeEventListener("focus", r, !0), n.removeEventListener("blur", s, !0) }, i.subject.asObservable() } stopMonitoring(t) { const e = op(t), n = this._elementInfo.get(e); n && (n.unlisten(), n.subject.complete(), this._setClasses(e), this._elementInfo.delete(e), this._decrementMonitoredElementCount()) } focusVia(t, e, n) { const i = op(t); this._setOriginForCurrentEventQueue(e), "function" == typeof i.focus && i.focus(n) } ngOnDestroy() { this._elementInfo.forEach((t, e) => this.stopMonitoring(e)) } _toggleClass(t, e, n) { n ? t.classList.add(e) : t.classList.remove(e) } _setClasses(t, e) { this._elementInfo.get(t) && (this._toggleClass(t, "cdk-focused", !!e), this._toggleClass(t, "cdk-touch-focused", "touch" === e), this._toggleClass(t, "cdk-keyboard-focused", "keyboard" === e), this._toggleClass(t, "cdk-mouse-focused", "mouse" === e), this._toggleClass(t, "cdk-program-focused", "program" === e)) } _setOriginForCurrentEventQueue(t) { this._ngZone.runOutsideAngular(() => { this._origin = t, this._originTimeoutId = setTimeout(() => this._origin = null, 1) }) } _wasCausedByTouch(t) { let e = t.target; return this._lastTouchTarget instanceof Node && e instanceof Node && (e === this._lastTouchTarget || e.contains(this._lastTouchTarget)) } _onFocus(t, e) { const n = this._elementInfo.get(e); if (!n || !n.checkChildren && e !== t.target) return; let i = this._origin; i || (i = this._windowFocused && this._lastFocusOrigin ? this._lastFocusOrigin : this._wasCausedByTouch(t) ? "touch" : "program"), this._setClasses(e, i), this._emitOrigin(n.subject, i), this._lastFocusOrigin = i } _onBlur(t, e) { const n = this._elementInfo.get(e); !n || n.checkChildren && t.relatedTarget instanceof Node && e.contains(t.relatedTarget) || (this._setClasses(e), this._emitOrigin(n.subject, null)) } _emitOrigin(t, e) { this._ngZone.run(() => t.next(e)) } _incrementMonitoredElementCount() { 1 == ++this._monitoredElementCount && this._platform.isBrowser && this._ngZone.runOutsideAngular(() => { document.addEventListener("keydown", this._documentKeydownListener, Ip), document.addEventListener("mousedown", this._documentMousedownListener, Ip), document.addEventListener("touchstart", this._documentTouchstartListener, Ip), window.addEventListener("focus", this._windowFocusListener) }) } _decrementMonitoredElementCount() { --this._monitoredElementCount || (document.removeEventListener("keydown", this._documentKeydownListener, Ip), document.removeEventListener("mousedown", this._documentMousedownListener, Ip), document.removeEventListener("touchstart", this._documentTouchstartListener, Ip), window.removeEventListener("focus", this._windowFocusListener), clearTimeout(this._windowFocusTimeoutId), clearTimeout(this._touchTimeoutId), clearTimeout(this._originTimeoutId)) } } return t.ngInjectableDef = ft({ factory: function () { return new t(Nt(Zr), Nt(up)) }, token: t, providedIn: "root" }), t })(); const Rp = new nn("8.2.3"), Np = new Tt("mat-sanity-checks", { providedIn: "root", factory: function () { return !0 } }); let Mp, Dp = (() => class { constructor(t, e) { this._sanityChecksEnabled = t, this._hammerLoader = e, this._hasDoneGlobalChecks = !1, this._hasCheckedHammer = !1, this._document = "object" == typeof document && document ? document : null, this._window = "object" == typeof window && window ? window : null, this._areChecksEnabled() && !this._hasDoneGlobalChecks && (this._checkDoctypeIsDefined(), this._checkThemeIsPresent(), this._checkCdkVersionMatch(), this._hasDoneGlobalChecks = !0) } _areChecksEnabled() { return this._sanityChecksEnabled && Yt() && !this._isTestEnv() } _isTestEnv() { const t = this._window; return t && (t.__karma__ || t.jasmine) } _checkDoctypeIsDefined() { this._document && !this._document.doctype && console.warn("Current document does not have a doctype. This may cause some Angular Material components not to behave as expected.") } _checkThemeIsPresent() { if (!this._document || !this._document.body || "function" != typeof getComputedStyle) return; const t = this._document.createElement("div"); t.classList.add("mat-theme-loaded-marker"), this._document.body.appendChild(t); const e = getComputedStyle(t); e && "none" !== e.display && console.warn("Could not find Angular Material core theme. Most Material components may not work as expected. For more info refer to the theming guide: https://material.angular.io/guide/theming"), this._document.body.removeChild(t) } _checkCdkVersionMatch() { Rp.full !== lp.full && console.warn("The Angular Material version (" + Rp.full + ") does not match the Angular CDK version (" + lp.full + ").\nPlease ensure the versions of these two packages exactly match.") } _checkHammerIsAvailable() { !this._hasCheckedHammer && this._window && (!this._areChecksEnabled() || this._window.Hammer || this._hammerLoader || console.warn("Could not find HammerJS. Certain Angular Material components may not work correctly."), this._hasCheckedHammer = !0) } })(); function Fp(t) { return class extends t { constructor(...t) { super(...t), this._disabled = !1 } get disabled() { return this._disabled } set disabled(t) { this._disabled = ip(t) } } } function Lp(t, e) { return class extends t { get color() { return this._color } set color(t) { const n = t || e; n !== this._color && (this._color && this._elementRef.nativeElement.classList.remove("mat-" + this._color), n && this._elementRef.nativeElement.classList.add("mat-" + n), this._color = n) } constructor(...t) { super(...t), this.color = e } } } function Vp(t) { return class extends t { constructor(...t) { super(...t), this._disableRipple = !1 } get disableRipple() { return this._disableRipple } set disableRipple(t) { this._disableRipple = ip(t) } } } function zp(t) { return class extends t { constructor(...t) { super(...t), this.errorState = !1, this.stateChanges = new k } updateErrorState() { const t = this.errorState, e = (this.errorStateMatcher || this._defaultErrorStateMatcher).isErrorState(this.ngControl ? this.ngControl.control : null, this._parentFormGroup || this._parentForm); e !== t && (this.errorState = e, this.stateChanges.next()) } } } try { Mp = "undefined" != typeof Intl } catch (aC) { Mp = !1 } let jp = (() => { class t { isErrorState(t, e) { return !!(t && t.invalid && (t.touched || e && e.submitted)) } } return t.ngInjectableDef = ft({ factory: function () { return new t }, token: t, providedIn: "root" }), t })(); const Up = function () { var t = { FADING_IN: 0, VISIBLE: 1, FADING_OUT: 2, HIDDEN: 3 }; return t[t.FADING_IN] = "FADING_IN", t[t.VISIBLE] = "VISIBLE", t[t.FADING_OUT] = "FADING_OUT", t[t.HIDDEN] = "HIDDEN", t }(); class Hp { constructor(t, e, n) { this._renderer = t, this.element = e, this.config = n, this.state = Up.HIDDEN } fadeOut() { this._renderer.fadeOutRipple(this) } } const Bp = { enterDuration: 450, exitDuration: 400 }, $p = mp({ passive: !0 }); class Wp { constructor(t, e, n, i) { this._target = t, this._ngZone = e, this._isPointerDown = !1, this._triggerEvents = new Map, this._activeRipples = new Set, this._onMousedown = t => { const e = function (t) { return 0 === t.buttons }(t), n = this._lastTouchStartEvent && Date.now() < this._lastTouchStartEvent + 800; this._target.rippleDisabled || e || n || (this._isPointerDown = !0, this.fadeInRipple(t.clientX, t.clientY, this._target.rippleConfig)) }, this._onTouchStart = t => { if (!this._target.rippleDisabled) { this._lastTouchStartEvent = Date.now(), this._isPointerDown = !0; const e = t.changedTouches; for (let t = 0; t < e.length; t++)this.fadeInRipple(e[t].clientX, e[t].clientY, this._target.rippleConfig) } }, this._onPointerUp = () => { this._isPointerDown && (this._isPointerDown = !1, this._activeRipples.forEach(t => { !t.config.persistent && (t.state === Up.VISIBLE || t.config.terminateOnPointerUp && t.state === Up.FADING_IN) && t.fadeOut() })) }, i.isBrowser && (this._containerElement = op(n), this._triggerEvents.set("mousedown", this._onMousedown).set("mouseup", this._onPointerUp).set("mouseleave", this._onPointerUp).set("touchstart", this._onTouchStart).set("touchend", this._onPointerUp).set("touchcancel", this._onPointerUp)) } fadeInRipple(t, e, n = {}) { const i = this._containerRect = this._containerRect || this._containerElement.getBoundingClientRect(), r = Object.assign({}, Bp, n.animation); n.centered && (t = i.left + i.width / 2, e = i.top + i.height / 2); const s = n.radius || function (t, e, n) { const i = Math.max(Math.abs(t - n.left), Math.abs(t - n.right)), r = Math.max(Math.abs(e - n.top), Math.abs(e - n.bottom)); return Math.sqrt(i * i + r * r) }(t, e, i), o = t - i.left, l = e - i.top, a = r.enterDuration, c = document.createElement("div"); c.classList.add("mat-ripple-element"), c.style.left = o - s + "px", c.style.top = l - s + "px", c.style.height = 2 * s + "px", c.style.width = 2 * s + "px", c.style.backgroundColor = n.color || null, c.style.transitionDuration = a + "ms", this._containerElement.appendChild(c), window.getComputedStyle(c).getPropertyValue("opacity"), c.style.transform = "scale(1)"; const u = new Hp(this, c, n); return u.state = Up.FADING_IN, this._activeRipples.add(u), n.persistent || (this._mostRecentTransientRipple = u), this._runTimeoutOutsideZone(() => { const t = u === this._mostRecentTransientRipple; u.state = Up.VISIBLE, n.persistent || t && this._isPointerDown || u.fadeOut() }, a), u } fadeOutRipple(t) { const e = this._activeRipples.delete(t); if (t === this._mostRecentTransientRipple && (this._mostRecentTransientRipple = null), this._activeRipples.size || (this._containerRect = null), !e) return; const n = t.element, i = Object.assign({}, Bp, t.config.animation); n.style.transitionDuration = i.exitDuration + "ms", n.style.opacity = "0", t.state = Up.FADING_OUT, this._runTimeoutOutsideZone(() => { t.state = Up.HIDDEN, n.parentNode.removeChild(n) }, i.exitDuration) } fadeOutAll() { this._activeRipples.forEach(t => t.fadeOut()) } setupTriggerEvents(t) { const e = op(t); e && e !== this._triggerElement && (this._removeTriggerEvents(), this._ngZone.runOutsideAngular(() => { this._triggerEvents.forEach((t, n) => { e.addEventListener(n, t, $p) }) }), this._triggerElement = e) } _runTimeoutOutsideZone(t, e = 0) { this._ngZone.runOutsideAngular(() => setTimeout(t, e)) } _removeTriggerEvents() { this._triggerElement && this._triggerEvents.forEach((t, e) => { this._triggerElement.removeEventListener(e, t, $p) }) } } const qp = new Tt("mat-ripple-global-options"); let Gp = (() => class { constructor(t, e, n, i, r) { this._elementRef = t, this.radius = 0, this._disabled = !1, this._isInitialized = !1, this._globalOptions = i || {}, this._rippleRenderer = new Wp(this, e, t, n), "NoopAnimations" === r && (this._globalOptions.animation = { enterDuration: 0, exitDuration: 0 }) } get disabled() { return this._disabled } set disabled(t) { this._disabled = t, this._setupTriggerEventsIfEnabled() } get trigger() { return this._trigger || this._elementRef.nativeElement } set trigger(t) { this._trigger = t, this._setupTriggerEventsIfEnabled() } ngOnInit() { this._isInitialized = !0, this._setupTriggerEventsIfEnabled() } ngOnDestroy() { this._rippleRenderer._removeTriggerEvents() } fadeOutAll() { this._rippleRenderer.fadeOutAll() } get rippleConfig() { return { centered: this.centered, radius: this.radius, color: this.color, animation: Object.assign({}, this._globalOptions.animation, this.animation), terminateOnPointerUp: this._globalOptions.terminateOnPointerUp } } get rippleDisabled() { return this.disabled || !!this._globalOptions.disabled } _setupTriggerEventsIfEnabled() { !this.disabled && this._isInitialized && this._rippleRenderer.setupTriggerEvents(this.trigger) } launch(t, e = 0, n) { return "number" == typeof t ? this._rippleRenderer.fadeInRipple(t, e, Object.assign({}, this.rippleConfig, n)) : this._rippleRenderer.fadeInRipple(0, 0, Object.assign({}, this.rippleConfig, t)) } })(), Zp = (() => class { })(); const Qp = new Tt("mat-label-global-options"); function Kp(t, e, n, r) { return i(n) && (r = n, n = void 0), r ? Kp(t, e, n).pipe(H(t => a(t) ? r(...t) : r(t))) : new w(i => { !function t(e, n, i, r, s) { let o; if (function (t) { return t && "function" == typeof t.addEventListener && "function" == typeof t.removeEventListener }(e)) { const t = e; e.addEventListener(n, i, s), o = () => t.removeEventListener(n, i, s) } else if (function (t) { return t && "function" == typeof t.on && "function" == typeof t.off }(e)) { const t = e; e.on(n, i), o = () => t.off(n, i) } else if (function (t) { return t && "function" == typeof t.addListener && "function" == typeof t.removeListener }(e)) { const t = e; e.addListener(n, i), o = () => t.removeListener(n, i) } else { if (!e || !e.length) throw new TypeError("Invalid event target"); for (let o = 0, l = e.length; o < l; o++)t(e[o], n, i, r, s) } r.add(o) }(t, e, (function (t) { i.next(arguments.length > 1 ? Array.prototype.slice.call(arguments) : t) }), i, n) }) } function Yp(t) { return e => e.lift(new Xp(t)) } class Xp { constructor(t) { this.notifier = t } call(t, e) { const n = new Jp(t), i = j(n, this.notifier); return i && !n.seenValue ? (n.add(i), e.subscribe(n)) : n } } class Jp extends U { constructor(t) { super(t), this.seenValue = !1 } notifyNext(t, e, n, i, r) { this.seenValue = !0, this.complete() } notifyComplete() { } } class tf { } function ef(t) { return Error(`A hint was already declared for 'align="${t}"'.`) } let nf = 0, rf = (() => class { constructor() { this.align = "start", this.id = "mat-hint-" + nf++ } })(), sf = (() => class { })(), of = (() => class { })(), lf = 0; class af { constructor(t) { this._elementRef = t } } const cf = Lp(af, "primary"), uf = new Tt("MAT_FORM_FIELD_DEFAULT_OPTIONS"); let hf = (() => class extends cf { constructor(t, e, n, i, r, s, o, l) { super(t), this._elementRef = t, this._changeDetectorRef = e, this._dir = i, this._defaults = r, this._platform = s, this._ngZone = o, this._outlineGapCalculationNeededImmediately = !1, this._outlineGapCalculationNeededOnStable = !1, this._destroyed = new k, this._showAlwaysAnimate = !1, this._subscriptAnimationState = "", this._hintLabel = "", this._hintLabelId = "mat-hint-" + lf++, this._labelId = "mat-form-field-label-" + lf++, this._previousDirection = "ltr", this._labelOptions = n || {}, this.floatLabel = this._labelOptions.float || "auto", this._animationsEnabled = "NoopAnimations" !== l, this.appearance = r && r.appearance ? r.appearance : "legacy", this._hideRequiredMarker = !(!r || null == r.hideRequiredMarker) && r.hideRequiredMarker } get appearance() { return this._appearance } set appearance(t) { const e = this._appearance; this._appearance = t || this._defaults && this._defaults.appearance || "legacy", "outline" === this._appearance && e !== t && (this._outlineGapCalculationNeededOnStable = !0) } get hideRequiredMarker() { return this._hideRequiredMarker } set hideRequiredMarker(t) { this._hideRequiredMarker = ip(t) } get _shouldAlwaysFloat() { return "always" === this.floatLabel && !this._showAlwaysAnimate } get _canLabelFloat() { return "never" !== this.floatLabel } get hintLabel() { return this._hintLabel } set hintLabel(t) { this._hintLabel = t, this._processHints() } get floatLabel() { return "legacy" !== this.appearance && "never" === this._floatLabel ? "auto" : this._floatLabel } set floatLabel(t) { t !== this._floatLabel && (this._floatLabel = t || this._labelOptions.float || "auto", this._changeDetectorRef.markForCheck()) } get _control() { return this._explicitFormFieldControl || this._controlNonStatic || this._controlStatic } set _control(t) { this._explicitFormFieldControl = t } get _labelChild() { return this._labelChildNonStatic || this._labelChildStatic } getConnectedOverlayOrigin() { return this._connectionContainerRef || this._elementRef } ngAfterContentInit() { this._validateControlChild(); const t = this._control; t.controlType && this._elementRef.nativeElement.classList.add("mat-form-field-type-" + t.controlType), t.stateChanges.pipe($a(null)).subscribe(() => { this._validatePlaceholders(), this._syncDescribedByIds(), this._changeDetectorRef.markForCheck() }), t.ngControl && t.ngControl.valueChanges && t.ngControl.valueChanges.pipe(Yp(this._destroyed)).subscribe(() => this._changeDetectorRef.markForCheck()), this._ngZone.runOutsideAngular(() => { this._ngZone.onStable.asObservable().pipe(Yp(this._destroyed)).subscribe(() => { this._outlineGapCalculationNeededOnStable && this.updateOutlineGap() }) }), X(this._prefixChildren.changes, this._suffixChildren.changes).subscribe(() => { this._outlineGapCalculationNeededOnStable = !0, this._changeDetectorRef.markForCheck() }), this._hintChildren.changes.pipe($a(null)).subscribe(() => { this._processHints(), this._changeDetectorRef.markForCheck() }), this._errorChildren.changes.pipe($a(null)).subscribe(() => { this._syncDescribedByIds(), this._changeDetectorRef.markForCheck() }), this._dir && this._dir.change.pipe(Yp(this._destroyed)).subscribe(() => { this.updateOutlineGap(), this._previousDirection = this._dir.value }) } ngAfterContentChecked() { this._validateControlChild(), this._outlineGapCalculationNeededImmediately && this.updateOutlineGap() } ngAfterViewInit() { this._subscriptAnimationState = "enter", this._changeDetectorRef.detectChanges() } ngOnDestroy() { this._destroyed.next(), this._destroyed.complete() } _shouldForward(t) { const e = this._control ? this._control.ngControl : null; return e && e[t] } _hasPlaceholder() { return !!(this._control && this._control.placeholder || this._placeholderChild) } _hasLabel() { return !!this._labelChild } _shouldLabelFloat() { return this._canLabelFloat && (this._control.shouldLabelFloat || this._shouldAlwaysFloat) } _hideControlPlaceholder() { return "legacy" === this.appearance && !this._hasLabel() || this._hasLabel() && !this._shouldLabelFloat() } _hasFloatingLabel() { return this._hasLabel() || "legacy" === this.appearance && this._hasPlaceholder() } _getDisplayedMessages() { return this._errorChildren && this._errorChildren.length > 0 && this._control.errorState ? "error" : "hint" } _animateAndLockLabel() { this._hasFloatingLabel() && this._canLabelFloat && (this._animationsEnabled && (this._showAlwaysAnimate = !0, Kp(this._label.nativeElement, "transitionend").pipe(Da(1)).subscribe(() => { this._showAlwaysAnimate = !1 })), this.floatLabel = "always", this._changeDetectorRef.markForCheck()) } _validatePlaceholders() { if (this._control.placeholder && this._placeholderChild) throw Error("Placeholder attribute and child element were both specified.") } _processHints() { this._validateHints(), this._syncDescribedByIds() } _validateHints() { if (this._hintChildren) { let t, e; this._hintChildren.forEach(n => { if ("start" === n.align) { if (t || this.hintLabel) throw ef("start"); t = n } else if ("end" === n.align) { if (e) throw ef("end"); e = n } }) } } _syncDescribedByIds() { if (this._control) { let t = []; if ("hint" === this._getDisplayedMessages()) { const e = this._hintChildren ? this._hintChildren.find(t => "start" === t.align) : null, n = this._hintChildren ? this._hintChildren.find(t => "end" === t.align) : null; e ? t.push(e.id) : this._hintLabel && t.push(this._hintLabelId), n && t.push(n.id) } else this._errorChildren && (t = this._errorChildren.map(t => t.id)); this._control.setDescribedByIds(t) } } _validateControlChild() { if (!this._control) throw Error("mat-form-field must contain a MatFormFieldControl.") } updateOutlineGap() { const t = this._label ? this._label.nativeElement : null; if ("outline" !== this.appearance || !t || !t.children.length || !t.textContent.trim()) return; if (!this._platform.isBrowser) return; if (!document.documentElement.contains(this._elementRef.nativeElement)) return void (this._outlineGapCalculationNeededImmediately = !0); let e = 0, n = 0; const i = this._connectionContainerRef.nativeElement, r = i.querySelectorAll(".mat-form-field-outline-start"), s = i.querySelectorAll(".mat-form-field-outline-gap"); if (this._label && this._label.nativeElement.children.length) { const r = i.getBoundingClientRect(); if (0 === r.width && 0 === r.height) return this._outlineGapCalculationNeededOnStable = !0, void (this._outlineGapCalculationNeededImmediately = !1); const s = this._getStartEnd(r), o = this._getStartEnd(t.children[0].getBoundingClientRect()); let l = 0; for (const e of t.children) l += e.offsetWidth; e = o - s - 5, n = l > 0 ? .75 * l + 10 : 0 } for (let o = 0; o < r.length; o++)r.item(o).style.width = e + "px"; for (let o = 0; o < s.length; o++)s.item(o).style.width = n + "px"; this._outlineGapCalculationNeededOnStable = this._outlineGapCalculationNeededImmediately = !1 } _getStartEnd(t) { return "rtl" === this._previousDirection ? t.right : t.left } })(), df = (() => class { })(), pf = (() => { class t { create(t) { return "undefined" == typeof MutationObserver ? null : new MutationObserver(t) } } return t.ngInjectableDef = ft({ factory: function () { return new t }, token: t, providedIn: "root" }), t })(), ff = (() => { class t { constructor(t) { this._mutationObserverFactory = t, this._observedElements = new Map } ngOnDestroy() { this._observedElements.forEach((t, e) => this._cleanupObserver(e)) } observe(t) { const e = op(t); return new w(t => { const n = this._observeElement(e).subscribe(t); return () => { n.unsubscribe(), this._unobserveElement(e) } }) } _observeElement(t) { if (this._observedElements.has(t)) this._observedElements.get(t).count++; else { const e = new k, n = this._mutationObserverFactory.create(t => e.next(t)); n && n.observe(t, { characterData: !0, childList: !0, subtree: !0 }), this._observedElements.set(t, { observer: n, stream: e, count: 1 }) } return this._observedElements.get(t).stream } _unobserveElement(t) { this._observedElements.has(t) && (this._observedElements.get(t).count--, this._observedElements.get(t).count || this._cleanupObserver(t)) } _cleanupObserver(t) { if (this._observedElements.has(t)) { const { observer: e, stream: n } = this._observedElements.get(t); e && e.disconnect(), n.complete(), this._observedElements.delete(t) } } } return t.ngInjectableDef = ft({ factory: function () { return new t(Nt(pf)) }, token: t, providedIn: "root" }), t })(), mf = (() => class { constructor(t, e, n) { this._contentObserver = t, this._elementRef = e, this._ngZone = n, this.event = new vr, this._disabled = !1, this._currentSubscription = null } get disabled() { return this._disabled } set disabled(t) { this._disabled = ip(t), this._disabled ? this._unsubscribe() : this._subscribe() } get debounce() { return this._debounce } set debounce(t) { this._debounce = function (t, e = 0) { return function (t) { return !isNaN(parseFloat(t)) && !isNaN(Number(t)) }(t) ? Number(t) : e }(t), this._subscribe() } ngAfterContentInit() { this._currentSubscription || this.disabled || this._subscribe() } ngOnDestroy() { this._unsubscribe() } _subscribe() { this._unsubscribe(); const t = this._contentObserver.observe(this._elementRef); this._ngZone.runOutsideAngular(() => { this._currentSubscription = (this.debounce ? t.pipe(wp(this.debounce)) : t).subscribe(this.event) }) } _unsubscribe() { this._currentSubscription && this._currentSubscription.unsubscribe() } })(), gf = (() => class { })(); const _f = new Tt("cdk-dir-doc", { providedIn: "root", factory: function () { return Mt(ta) } }); let yf = (() => { class t { constructor(t) { if (this.value = "ltr", this.change = new vr, t) { const e = t.documentElement ? t.documentElement.dir : null, n = (t.body ? t.body.dir : null) || e; this.value = "ltr" === n || "rtl" === n ? n : "ltr" } } ngOnDestroy() { this.change.complete() } } return t.ngInjectableDef = ft({ factory: function () { return new t(Nt(_f, 8)) }, token: t, providedIn: "root" }), t })(), vf = (() => class { })(); function bf() { return "undefined" != typeof process } function wf(t) { switch (t.length) { case 0: return new ep; case 1: return t[0]; default: return new np(t) } } function Cf(t, e, n, i, r = {}, s = {}) { const o = [], l = []; let a = -1, c = null; if (i.forEach(t => { const n = t.offset, i = n == a, u = i && c || {}; Object.keys(t).forEach(n => { let i = n, l = t[n]; if ("offset" !== n) switch (i = e.normalizePropertyName(i, o), l) { case "!": l = r[n]; break; case "*": l = s[n]; break; default: l = e.normalizeStyleValue(n, i, l, o) }u[i] = l }), i || l.push(u), c = u, a = n }), o.length) { const t = "\n - "; throw new Error(`Unable to animate due to the following errors:${t}${o.join(t)}`) } return l } function Sf(t, e, n, i) { switch (e) { case "start": t.onStart(() => i(n && Ef(n, "start", t))); break; case "done": t.onDone(() => i(n && Ef(n, "done", t))); break; case "destroy": t.onDestroy(() => i(n && Ef(n, "destroy", t))) } } function Ef(t, e, n) { const i = n.totalTime, r = xf(t.element, t.triggerName, t.fromState, t.toState, e || t.phaseName, null == i ? t.totalTime : i, !!n.disabled), s = t._data; return null != s && (r._data = s), r } function xf(t, e, n, i, r = "", s = 0, o) { return { element: t, triggerName: e, fromState: n, toState: i, phaseName: r, totalTime: s, disabled: !!o } } function Tf(t, e, n) { let i; return t instanceof Map ? (i = t.get(e), i || t.set(e, i = n)) : (i = t[e], i || (i = t[e] = n)), i } function kf(t) { const e = t.indexOf(":"); return [t.substring(1, e), t.substr(e + 1)] } let Pf = (t, e) => !1, Of = (t, e) => !1, If = (t, e, n) => []; const Af = bf(); (Af || "undefined" != typeof Element) && (Pf = (t, e) => t.contains(e), Of = (() => { if (Af || Element.prototype.matches) return (t, e) => t.matches(e); { const t = Element.prototype, e = t.matchesSelector || t.mozMatchesSelector || t.msMatchesSelector || t.oMatchesSelector || t.webkitMatchesSelector; return e ? (t, n) => e.apply(t, [n]) : Of } })(), If = (t, e, n) => { let i = []; if (n) i.push(...t.querySelectorAll(e)); else { const n = t.querySelector(e); n && i.push(n) } return i }); let Rf = null, Nf = !1; function Mf(t) { Rf || (Rf = ("undefined" != typeof document ? document.body : null) || {}, Nf = !!Rf.style && "WebkitAppearance" in Rf.style); let e = !0; return Rf.style && !function (t) { return "ebkit" == t.substring(1, 6) }(t) && (e = t in Rf.style, !e && Nf) && (e = "Webkit" + t.charAt(0).toUpperCase() + t.substr(1) in Rf.style), e } const Df = Of, Ff = Pf, Lf = If; function Vf(t) { const e = {}; return Object.keys(t).forEach(n => { const i = n.replace(/([a-z])([A-Z])/g, "$1-$2"); e[i] = t[n] }), e } let zf = (() => class { validateStyleProperty(t) { return Mf(t) } matchesElement(t, e) { return Df(t, e) } containsElement(t, e) { return Ff(t, e) } query(t, e, n) { return Lf(t, e, n) } computeStyle(t, e, n) { return n || "" } animate(t, e, n, i, r, s = [], o) { return new ep(n, i) } })(), jf = (() => { class t { } return t.NOOP = new zf, t })(); function Uf(t) { if ("number" == typeof t) return t; const e = t.match(/^(-?[\.\d]+)(m?s)/); return !e || e.length < 2 ? 0 : Hf(parseFloat(e[1]), e[2]) } function Hf(t, e) { switch (e) { case "s": return 1e3 * t; default: return t } } function Bf(t, e, n) { return t.hasOwnProperty("duration") ? t : function (t, e, n) { let i, r = 0, s = ""; if ("string" == typeof t) { const n = t.match(/^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i); if (null === n) return e.push(`The provided timing value "${t}" is invalid.`), { duration: 0, delay: 0, easing: "" }; i = Hf(parseFloat(n[1]), n[2]); const o = n[3]; null != o && (r = Hf(parseFloat(o), n[4])); const l = n[5]; l && (s = l) } else i = t; if (!n) { let n = !1, s = e.length; i < 0 && (e.push("Duration values below 0 are not allowed for this animation step."), n = !0), r < 0 && (e.push("Delay values below 0 are not allowed for this animation step."), n = !0), n && e.splice(s, 0, `The provided timing value "${t}" is invalid.`) } return { duration: i, delay: r, easing: s } }(t, e, n) } function $f(t, e = {}) { return Object.keys(t).forEach(n => { e[n] = t[n] }), e } function Wf(t, e, n = {}) { if (e) for (let i in t) n[i] = t[i]; else $f(t, n); return n } function qf(t, e, n) { return n ? e + ":" + n + ";" : "" } function Gf(t) { let e = ""; for (let n = 0; n < t.style.length; n++) { const i = t.style.item(n); e += qf(0, i, t.style.getPropertyValue(i)) } for (const n in t.style) t.style.hasOwnProperty(n) && !n.startsWith("_") && (e += qf(0, n.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(), t.style[n])); t.setAttribute("style", e) } function Zf(t, e, n) { t.style && (Object.keys(e).forEach(i => { const r = nm(i); n && !n.hasOwnProperty(i) && (n[i] = t.style[r]), t.style[r] = e[i] }), bf() && Gf(t)) } function Qf(t, e) { t.style && (Object.keys(e).forEach(e => { const n = nm(e); t.style[n] = "" }), bf() && Gf(t)) } function Kf(t) { return Array.isArray(t) ? 1 == t.length ? t[0] : Xd(t) : t } const Yf = new RegExp("{{\\s*(.+?)\\s*}}", "g"); function Xf(t) { let e = []; if ("string" == typeof t) { const n = t.toString(); let i; for (; i = Yf.exec(n);)e.push(i[1]); Yf.lastIndex = 0 } return e } function Jf(t, e, n) { const i = t.toString(), r = i.replace(Yf, (t, i) => { let r = e[i]; return e.hasOwnProperty(i) || (n.push("Please provide a value for the animation param " + i), r = ""), r.toString() }); return r == i ? t : r } function tm(t) { const e = []; let n = t.next(); for (; !n.done;)e.push(n.value), n = t.next(); return e } const em = /-+([a-z0-9])/g; function nm(t) { return t.replace(em, (...t) => t[1].toUpperCase()) } function im(t, e) { return 0 === t || 0 === e } function rm(t, e, n) { const i = Object.keys(n); if (i.length && e.length) { let s = e[0], o = []; if (i.forEach(t => { s.hasOwnProperty(t) || o.push(t), s[t] = n[t] }), o.length) for (var r = 1; r < e.length; r++) { let n = e[r]; o.forEach((function (e) { n[e] = om(t, e) })) } } return e } function sm(t, e, n) { switch (e.type) { case 7: return t.visitTrigger(e, n); case 0: return t.visitState(e, n); case 1: return t.visitTransition(e, n); case 2: return t.visitSequence(e, n); case 3: return t.visitGroup(e, n); case 4: return t.visitAnimate(e, n); case 5: return t.visitKeyframes(e, n); case 6: return t.visitStyle(e, n); case 8: return t.visitReference(e, n); case 9: return t.visitAnimateChild(e, n); case 10: return t.visitAnimateRef(e, n); case 11: return t.visitQuery(e, n); case 12: return t.visitStagger(e, n); default: throw new Error("Unable to resolve animation metadata node #" + e.type) } } function om(t, e) { return window.getComputedStyle(t)[e] } function lm(t, e) { const n = []; return "string" == typeof t ? t.split(/\s*,\s*/).forEach(t => function (t, e, n) { if (":" == t[0]) { const i = function (t, e) { switch (t) { case ":enter": return "void => *"; case ":leave": return "* => void"; case ":increment": return (t, e) => parseFloat(e) > parseFloat(t); case ":decrement": return (t, e) => parseFloat(e) < parseFloat(t); default: return e.push(`The transition alias value "${t}" is not supported`), "* => *" } }(t, n); if ("function" == typeof i) return void e.push(i); t = i } const i = t.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/); if (null == i || i.length < 4) return n.push(`The provided transition expression "${t}" is not supported`), e; const r = i[1], s = i[2], o = i[3]; e.push(um(r, o)), "<" != s[0] || "*" == r && "*" == o || e.push(um(o, r)) }(t, n, e)) : n.push(t), n } const am = new Set(["true", "1"]), cm = new Set(["false", "0"]); function um(t, e) { const n = am.has(t) || cm.has(t), i = am.has(e) || cm.has(e); return (r, s) => { let o = "*" == t || t == r, l = "*" == e || e == s; return !o && n && "boolean" == typeof r && (o = r ? am.has(t) : cm.has(t)), !l && i && "boolean" == typeof s && (l = s ? am.has(e) : cm.has(e)), o && l } } const hm = new RegExp("s*:selfs*,?", "g"); function dm(t, e, n) { return new pm(t).build(e, n) } class pm { constructor(t) { this._driver = t } build(t, e) { const n = new fm(e); return this._resetContextStyleTimingState(n), sm(this, Kf(t), n) } _resetContextStyleTimingState(t) { t.currentQuerySelector = "", t.collectedStyles = {}, t.collectedStyles[""] = {}, t.currentTime = 0 } visitTrigger(t, e) { let n = e.queryCount = 0, i = e.depCount = 0; const r = [], s = []; return "@" == t.name.charAt(0) && e.errors.push("animation triggers cannot be prefixed with an `@` sign (e.g. trigger('@foo', [...]))"), t.definitions.forEach(t => { if (this._resetContextStyleTimingState(e), 0 == t.type) { const n = t, i = n.name; i.toString().split(/\s*,\s*/).forEach(t => { n.name = t, r.push(this.visitState(n, e)) }), n.name = i } else if (1 == t.type) { const r = this.visitTransition(t, e); n += r.queryCount, i += r.depCount, s.push(r) } else e.errors.push("only state() and transition() definitions can sit inside of a trigger()") }), { type: 7, name: t.name, states: r, transitions: s, queryCount: n, depCount: i, options: null } } visitState(t, e) { const n = this.visitStyle(t.styles, e), i = t.options && t.options.params || null; if (n.containsDynamicStyles) { const r = new Set, s = i || {}; if (n.styles.forEach(t => { if (mm(t)) { const e = t; Object.keys(e).forEach(t => { Xf(e[t]).forEach(t => { s.hasOwnProperty(t) || r.add(t) }) }) } }), r.size) { const n = tm(r.values()); e.errors.push(`state("${t.name}", ...) must define default values for all the following style substitutions: ${n.join(", ")}`) } } return { type: 0, name: t.name, style: n, options: i ? { params: i } : null } } visitTransition(t, e) { e.queryCount = 0, e.depCount = 0; const n = sm(this, Kf(t.animation), e); return { type: 1, matchers: lm(t.expr, e.errors), animation: n, queryCount: e.queryCount, depCount: e.depCount, options: gm(t.options) } } visitSequence(t, e) { return { type: 2, steps: t.steps.map(t => sm(this, t, e)), options: gm(t.options) } } visitGroup(t, e) { const n = e.currentTime; let i = 0; const r = t.steps.map(t => { e.currentTime = n; const r = sm(this, t, e); return i = Math.max(i, e.currentTime), r }); return e.currentTime = i, { type: 3, steps: r, options: gm(t.options) } } visitAnimate(t, e) { const n = function (t, e) { let n = null; if (t.hasOwnProperty("duration")) n = t; else if ("number" == typeof t) return _m(Bf(t, e).duration, 0, ""); const i = t; if (i.split(/\s+/).some(t => "{" == t.charAt(0) && "{" == t.charAt(1))) { const t = _m(0, 0, ""); return t.dynamic = !0, t.strValue = i, t } return n = n || Bf(i, e), _m(n.duration, n.delay, n.easing) }(t.timings, e.errors); let i; e.currentAnimateTimings = n; let r = t.styles ? t.styles : Jd({}); if (5 == r.type) i = this.visitKeyframes(r, e); else { let r = t.styles, s = !1; if (!r) { s = !0; const t = {}; n.easing && (t.easing = n.easing), r = Jd(t) } e.currentTime += n.duration + n.delay; const o = this.visitStyle(r, e); o.isEmptyStep = s, i = o } return e.currentAnimateTimings = null, { type: 4, timings: n, style: i, options: null } } visitStyle(t, e) { const n = this._makeStyleAst(t, e); return this._validateStyleAst(n, e), n } _makeStyleAst(t, e) { const n = []; Array.isArray(t.styles) ? t.styles.forEach(t => { "string" == typeof t ? "*" == t ? n.push(t) : e.errors.push(`The provided style string value ${t} is not allowed.`) : n.push(t) }) : n.push(t.styles); let i = !1, r = null; return n.forEach(t => { if (mm(t)) { const e = t, n = e.easing; if (n && (r = n, delete e.easing), !i) for (let t in e) if (e[t].toString().indexOf("{{") >= 0) { i = !0; break } } }), { type: 6, styles: n, easing: r, offset: t.offset, containsDynamicStyles: i, options: null } } _validateStyleAst(t, e) { const n = e.currentAnimateTimings; let i = e.currentTime, r = e.currentTime; n && r > 0 && (r -= n.duration + n.delay), t.styles.forEach(t => { "string" != typeof t && Object.keys(t).forEach(n => { if (!this._driver.validateStyleProperty(n)) return void e.errors.push(`The provided animation property "${n}" is not a supported CSS property for animations`); const s = e.collectedStyles[e.currentQuerySelector], o = s[n]; let l = !0; o && (r != i && r >= o.startTime && i <= o.endTime && (e.errors.push(`The CSS property "${n}" that exists between the times of "${o.startTime}ms" and "${o.endTime}ms" is also being animated in a parallel animation between the times of "${r}ms" and "${i}ms"`), l = !1), r = o.startTime), l && (s[n] = { startTime: r, endTime: i }), e.options && function (t, e, n) { const i = e.params || {}, r = Xf(t); r.length && r.forEach(t => { i.hasOwnProperty(t) || n.push(`Unable to resolve the local animation param ${t} in the given list of values`) }) }(t[n], e.options, e.errors) }) }) } visitKeyframes(t, e) { const n = { type: 5, styles: [], options: null }; if (!e.currentAnimateTimings) return e.errors.push("keyframes() must be placed inside of a call to animate()"), n; let i = 0; const r = []; let s = !1, o = !1, l = 0; const a = t.steps.map(t => { const n = this._makeStyleAst(t, e); let a = null != n.offset ? n.offset : function (t) { if ("string" == typeof t) return null; let e = null; if (Array.isArray(t)) t.forEach(t => { if (mm(t) && t.hasOwnProperty("offset")) { const n = t; e = parseFloat(n.offset), delete n.offset } }); else if (mm(t) && t.hasOwnProperty("offset")) { const n = t; e = parseFloat(n.offset), delete n.offset } return e }(n.styles), c = 0; return null != a && (i++, c = n.offset = a), o = o || c < 0 || c > 1, s = s || c < l, l = c, r.push(c), n }); o && e.errors.push("Please ensure that all keyframe offsets are between 0 and 1"), s && e.errors.push("Please ensure that all keyframe offsets are in order"); const c = t.steps.length; let u = 0; i > 0 && i < c ? e.errors.push("Not all style() steps within the declared keyframes() contain offsets") : 0 == i && (u = 1 / (c - 1)); const h = c - 1, d = e.currentTime, p = e.currentAnimateTimings, f = p.duration; return a.forEach((t, i) => { const s = u > 0 ? i == h ? 1 : u * i : r[i], o = s * f; e.currentTime = d + p.delay + o, p.duration = o, this._validateStyleAst(t, e), t.offset = s, n.styles.push(t) }), n } visitReference(t, e) { return { type: 8, animation: sm(this, Kf(t.animation), e), options: gm(t.options) } } visitAnimateChild(t, e) { return e.depCount++, { type: 9, options: gm(t.options) } } visitAnimateRef(t, e) { return { type: 10, animation: this.visitReference(t.animation, e), options: gm(t.options) } } visitQuery(t, e) { const n = e.currentQuerySelector, i = t.options || {}; e.queryCount++, e.currentQuery = t; const [r, s] = function (t) { const e = !!t.split(/\s*,\s*/).find(t => ":self" == t); return e && (t = t.replace(hm, "")), [t = t.replace(/@\*/g, ".ng-trigger").replace(/@\w+/g, t => ".ng-trigger-" + t.substr(1)).replace(/:animating/g, ".ng-animating"), e] }(t.selector); e.currentQuerySelector = n.length ? n + " " + r : r, Tf(e.collectedStyles, e.currentQuerySelector, {}); const o = sm(this, Kf(t.animation), e); return e.currentQuery = null, e.currentQuerySelector = n, { type: 11, selector: r, limit: i.limit || 0, optional: !!i.optional, includeSelf: s, animation: o, originalSelector: t.selector, options: gm(t.options) } } visitStagger(t, e) { e.currentQuery || e.errors.push("stagger() can only be used inside of query()"); const n = "full" === t.timings ? { duration: 0, delay: 0, easing: "full" } : Bf(t.timings, e.errors, !0); return { type: 12, animation: sm(this, Kf(t.animation), e), timings: n, options: null } } } class fm { constructor(t) { this.errors = t, this.queryCount = 0, this.depCount = 0, this.currentTransition = null, this.currentQuery = null, this.currentQuerySelector = null, this.currentAnimateTimings = null, this.currentTime = 0, this.collectedStyles = {}, this.options = null } } function mm(t) { return !Array.isArray(t) && "object" == typeof t } function gm(t) { var e; return t ? (t = $f(t)).params && (t.params = (e = t.params) ? $f(e) : null) : t = {}, t } function _m(t, e, n) { return { duration: t, delay: e, easing: n } } function ym(t, e, n, i, r, s, o = null, l = !1) { return { type: 1, element: t, keyframes: e, preStyleProps: n, postStyleProps: i, duration: r, delay: s, totalTime: r + s, easing: o, subTimeline: l } } class vm { constructor() { this._map = new Map } consume(t) { let e = this._map.get(t); return e ? this._map.delete(t) : e = [], e } append(t, e) { let n = this._map.get(t); n || this._map.set(t, n = []), n.push(...e) } has(t) { return this._map.has(t) } clear() { this._map.clear() } } const bm = new RegExp(":enter", "g"), wm = new RegExp(":leave", "g"); function Cm(t, e, n, i, r, s = {}, o = {}, l, a, c = []) { return (new Sm).buildKeyframes(t, e, n, i, r, s, o, l, a, c) } class Sm { buildKeyframes(t, e, n, i, r, s, o, l, a, c = []) { a = a || new vm; const u = new xm(t, e, a, i, r, c, []); u.options = l, u.currentTimeline.setStyles([s], null, u.errors, l), sm(this, n, u); const h = u.timelines.filter(t => t.containsAnimation()); if (h.length && Object.keys(o).length) { const t = h[h.length - 1]; t.allowOnlyTimelineStyles() || t.setStyles([o], null, u.errors, l) } return h.length ? h.map(t => t.buildKeyframes()) : [ym(e, [], [], [], 0, 0, "", !1)] } visitTrigger(t, e) { } visitState(t, e) { } visitTransition(t, e) { } visitAnimateChild(t, e) { const n = e.subInstructions.consume(e.element); if (n) { const i = e.createSubContext(t.options), r = e.currentTimeline.currentTime, s = this._visitSubInstructions(n, i, i.options); r != s && e.transformIntoNewTimeline(s) } e.previousNode = t } visitAnimateRef(t, e) { const n = e.createSubContext(t.options); n.transformIntoNewTimeline(), this.visitReference(t.animation, n), e.transformIntoNewTimeline(n.currentTimeline.currentTime), e.previousNode = t } _visitSubInstructions(t, e, n) { let i = e.currentTimeline.currentTime; const r = null != n.duration ? Uf(n.duration) : null, s = null != n.delay ? Uf(n.delay) : null; return 0 !== r && t.forEach(t => { const n = e.appendInstructionToTimeline(t, r, s); i = Math.max(i, n.duration + n.delay) }), i } visitReference(t, e) { e.updateOptions(t.options, !0), sm(this, t.animation, e), e.previousNode = t } visitSequence(t, e) { const n = e.subContextCount; let i = e; const r = t.options; if (r && (r.params || r.delay) && (i = e.createSubContext(r), i.transformIntoNewTimeline(), null != r.delay)) { 6 == i.previousNode.type && (i.currentTimeline.snapshotCurrentStyles(), i.previousNode = Em); const t = Uf(r.delay); i.delayNextStep(t) } t.steps.length && (t.steps.forEach(t => sm(this, t, i)), i.currentTimeline.applyStylesToKeyframe(), i.subContextCount > n && i.transformIntoNewTimeline()), e.previousNode = t } visitGroup(t, e) { const n = []; let i = e.currentTimeline.currentTime; const r = t.options && t.options.delay ? Uf(t.options.delay) : 0; t.steps.forEach(s => { const o = e.createSubContext(t.options); r && o.delayNextStep(r), sm(this, s, o), i = Math.max(i, o.currentTimeline.currentTime), n.push(o.currentTimeline) }), n.forEach(t => e.currentTimeline.mergeTimelineCollectedStyles(t)), e.transformIntoNewTimeline(i), e.previousNode = t } _visitTiming(t, e) { if (t.dynamic) { const n = t.strValue; return Bf(e.params ? Jf(n, e.params, e.errors) : n, e.errors) } return { duration: t.duration, delay: t.delay, easing: t.easing } } visitAnimate(t, e) { const n = e.currentAnimateTimings = this._visitTiming(t.timings, e), i = e.currentTimeline; n.delay && (e.incrementTime(n.delay), i.snapshotCurrentStyles()); const r = t.style; 5 == r.type ? this.visitKeyframes(r, e) : (e.incrementTime(n.duration), this.visitStyle(r, e), i.applyStylesToKeyframe()), e.currentAnimateTimings = null, e.previousNode = t } visitStyle(t, e) { const n = e.currentTimeline, i = e.currentAnimateTimings; !i && n.getCurrentStyleProperties().length && n.forwardFrame(); const r = i && i.easing || t.easing; t.isEmptyStep ? n.applyEmptyStep(r) : n.setStyles(t.styles, r, e.errors, e.options), e.previousNode = t } visitKeyframes(t, e) { const n = e.currentAnimateTimings, i = e.currentTimeline.duration, r = n.duration, s = e.createSubContext().currentTimeline; s.easing = n.easing, t.styles.forEach(t => { s.forwardTime((t.offset || 0) * r), s.setStyles(t.styles, t.easing, e.errors, e.options), s.applyStylesToKeyframe() }), e.currentTimeline.mergeTimelineCollectedStyles(s), e.transformIntoNewTimeline(i + r), e.previousNode = t } visitQuery(t, e) { const n = e.currentTimeline.currentTime, i = t.options || {}, r = i.delay ? Uf(i.delay) : 0; r && (6 === e.previousNode.type || 0 == n && e.currentTimeline.getCurrentStyleProperties().length) && (e.currentTimeline.snapshotCurrentStyles(), e.previousNode = Em); let s = n; const o = e.invokeQuery(t.selector, t.originalSelector, t.limit, t.includeSelf, !!i.optional, e.errors); e.currentQueryTotal = o.length; let l = null; o.forEach((n, i) => { e.currentQueryIndex = i; const o = e.createSubContext(t.options, n); r && o.delayNextStep(r), n === e.element && (l = o.currentTimeline), sm(this, t.animation, o), o.currentTimeline.applyStylesToKeyframe(), s = Math.max(s, o.currentTimeline.currentTime) }), e.currentQueryIndex = 0, e.currentQueryTotal = 0, e.transformIntoNewTimeline(s), l && (e.currentTimeline.mergeTimelineCollectedStyles(l), e.currentTimeline.snapshotCurrentStyles()), e.previousNode = t } visitStagger(t, e) { const n = e.parentContext, i = e.currentTimeline, r = t.timings, s = Math.abs(r.duration), o = s * (e.currentQueryTotal - 1); let l = s * e.currentQueryIndex; switch (r.duration < 0 ? "reverse" : r.easing) { case "reverse": l = o - l; break; case "full": l = n.currentStaggerTime }const a = e.currentTimeline; l && a.delayNextStep(l); const c = a.currentTime; sm(this, t.animation, e), e.previousNode = t, n.currentStaggerTime = i.currentTime - c + (i.startTime - n.currentTimeline.startTime) } } const Em = {}; class xm { constructor(t, e, n, i, r, s, o, l) { this._driver = t, this.element = e, this.subInstructions = n, this._enterClassName = i, this._leaveClassName = r, this.errors = s, this.timelines = o, this.parentContext = null, this.currentAnimateTimings = null, this.previousNode = Em, this.subContextCount = 0, this.options = {}, this.currentQueryIndex = 0, this.currentQueryTotal = 0, this.currentStaggerTime = 0, this.currentTimeline = l || new Tm(this._driver, e, 0), o.push(this.currentTimeline) } get params() { return this.options.params } updateOptions(t, e) { if (!t) return; const n = t; let i = this.options; null != n.duration && (i.duration = Uf(n.duration)), null != n.delay && (i.delay = Uf(n.delay)); const r = n.params; if (r) { let t = i.params; t || (t = this.options.params = {}), Object.keys(r).forEach(n => { e && t.hasOwnProperty(n) || (t[n] = Jf(r[n], t, this.errors)) }) } } _copyOptions() { const t = {}; if (this.options) { const e = this.options.params; if (e) { const n = t.params = {}; Object.keys(e).forEach(t => { n[t] = e[t] }) } } return t } createSubContext(t = null, e, n) { const i = e || this.element, r = new xm(this._driver, i, this.subInstructions, this._enterClassName, this._leaveClassName, this.errors, this.timelines, this.currentTimeline.fork(i, n || 0)); return r.previousNode = this.previousNode, r.currentAnimateTimings = this.currentAnimateTimings, r.options = this._copyOptions(), r.updateOptions(t), r.currentQueryIndex = this.currentQueryIndex, r.currentQueryTotal = this.currentQueryTotal, r.parentContext = this, this.subContextCount++, r } transformIntoNewTimeline(t) { return this.previousNode = Em, this.currentTimeline = this.currentTimeline.fork(this.element, t), this.timelines.push(this.currentTimeline), this.currentTimeline } appendInstructionToTimeline(t, e, n) { const i = { duration: null != e ? e : t.duration, delay: this.currentTimeline.currentTime + (null != n ? n : 0) + t.delay, easing: "" }, r = new km(this._driver, t.element, t.keyframes, t.preStyleProps, t.postStyleProps, i, t.stretchStartingKeyframe); return this.timelines.push(r), i } incrementTime(t) { this.currentTimeline.forwardTime(this.currentTimeline.duration + t) } delayNextStep(t) { t > 0 && this.currentTimeline.delayNextStep(t) } invokeQuery(t, e, n, i, r, s) { let o = []; if (i && o.push(this.element), t.length > 0) { t = (t = t.replace(bm, "." + this._enterClassName)).replace(wm, "." + this._leaveClassName); let e = this._driver.query(this.element, t, 1 != n); 0 !== n && (e = n < 0 ? e.slice(e.length + n, e.length) : e.slice(0, n)), o.push(...e) } return r || 0 != o.length || s.push(`\`query("${e}")\` returned zero elements. (Use \`query("${e}", { optional: true })\` if you wish to allow this.)`), o } } class Tm { constructor(t, e, n, i) { this._driver = t, this.element = e, this.startTime = n, this._elementTimelineStylesLookup = i, this.duration = 0, this._previousKeyframe = {}, this._currentKeyframe = {}, this._keyframes = new Map, this._styleSummary = {}, this._pendingStyles = {}, this._backFill = {}, this._currentEmptyStepKeyframe = null, this._elementTimelineStylesLookup || (this._elementTimelineStylesLookup = new Map), this._localTimelineStyles = Object.create(this._backFill, {}), this._globalTimelineStyles = this._elementTimelineStylesLookup.get(e), this._globalTimelineStyles || (this._globalTimelineStyles = this._localTimelineStyles, this._elementTimelineStylesLookup.set(e, this._localTimelineStyles)), this._loadKeyframe() } containsAnimation() { switch (this._keyframes.size) { case 0: return !1; case 1: return this.getCurrentStyleProperties().length > 0; default: return !0 } } getCurrentStyleProperties() { return Object.keys(this._currentKeyframe) } get currentTime() { return this.startTime + this.duration } delayNextStep(t) { const e = 1 == this._keyframes.size && Object.keys(this._pendingStyles).length; this.duration || e ? (this.forwardTime(this.currentTime + t), e && this.snapshotCurrentStyles()) : this.startTime += t } fork(t, e) { return this.applyStylesToKeyframe(), new Tm(this._driver, t, e || this.currentTime, this._elementTimelineStylesLookup) } _loadKeyframe() { this._currentKeyframe && (this._previousKeyframe = this._currentKeyframe), this._currentKeyframe = this._keyframes.get(this.duration), this._currentKeyframe || (this._currentKeyframe = Object.create(this._backFill, {}), this._keyframes.set(this.duration, this._currentKeyframe)) } forwardFrame() { this.duration += 1, this._loadKeyframe() } forwardTime(t) { this.applyStylesToKeyframe(), this.duration = t, this._loadKeyframe() } _updateStyle(t, e) { this._localTimelineStyles[t] = e, this._globalTimelineStyles[t] = e, this._styleSummary[t] = { time: this.currentTime, value: e } } allowOnlyTimelineStyles() { return this._currentEmptyStepKeyframe !== this._currentKeyframe } applyEmptyStep(t) { t && (this._previousKeyframe.easing = t), Object.keys(this._globalTimelineStyles).forEach(t => { this._backFill[t] = this._globalTimelineStyles[t] || "*", this._currentKeyframe[t] = "*" }), this._currentEmptyStepKeyframe = this._currentKeyframe } setStyles(t, e, n, i) { e && (this._previousKeyframe.easing = e); const r = i && i.params || {}, s = function (t, e) { const n = {}; let i; return t.forEach(t => { "*" === t ? (i = i || Object.keys(e), i.forEach(t => { n[t] = "*" })) : Wf(t, !1, n) }), n }(t, this._globalTimelineStyles); Object.keys(s).forEach(t => { const e = Jf(s[t], r, n); this._pendingStyles[t] = e, this._localTimelineStyles.hasOwnProperty(t) || (this._backFill[t] = this._globalTimelineStyles.hasOwnProperty(t) ? this._globalTimelineStyles[t] : "*"), this._updateStyle(t, e) }) } applyStylesToKeyframe() { const t = this._pendingStyles, e = Object.keys(t); 0 != e.length && (this._pendingStyles = {}, e.forEach(e => { this._currentKeyframe[e] = t[e] }), Object.keys(this._localTimelineStyles).forEach(t => { this._currentKeyframe.hasOwnProperty(t) || (this._currentKeyframe[t] = this._localTimelineStyles[t]) })) } snapshotCurrentStyles() { Object.keys(this._localTimelineStyles).forEach(t => { const e = this._localTimelineStyles[t]; this._pendingStyles[t] = e, this._updateStyle(t, e) }) } getFinalKeyframe() { return this._keyframes.get(this.duration) } get properties() { const t = []; for (let e in this._currentKeyframe) t.push(e); return t } mergeTimelineCollectedStyles(t) { Object.keys(t._styleSummary).forEach(e => { const n = this._styleSummary[e], i = t._styleSummary[e]; (!n || i.time > n.time) && this._updateStyle(e, i.value) }) } buildKeyframes() { this.applyStylesToKeyframe(); const t = new Set, e = new Set, n = 1 === this._keyframes.size && 0 === this.duration; let i = []; this._keyframes.forEach((r, s) => { const o = Wf(r, !0); Object.keys(o).forEach(n => { const i = o[n]; "!" == i ? t.add(n) : "*" == i && e.add(n) }), n || (o.offset = s / this.duration), i.push(o) }); const r = t.size ? tm(t.values()) : [], s = e.size ? tm(e.values()) : []; if (n) { const t = i[0], e = $f(t); t.offset = 0, e.offset = 1, i = [t, e] } return ym(this.element, i, r, s, this.duration, this.startTime, this.easing, !1) } } class km extends Tm { constructor(t, e, n, i, r, s, o = !1) { super(t, e, s.delay), this.element = e, this.keyframes = n, this.preStyleProps = i, this.postStyleProps = r, this._stretchStartingKeyframe = o, this.timings = { duration: s.duration, delay: s.delay, easing: s.easing } } containsAnimation() { return this.keyframes.length > 1 } buildKeyframes() { let t = this.keyframes, { delay: e, duration: n, easing: i } = this.timings; if (this._stretchStartingKeyframe && e) { const r = [], s = n + e, o = e / s, l = Wf(t[0], !1); l.offset = 0, r.push(l); const a = Wf(t[0], !1); a.offset = Pm(o), r.push(a); const c = t.length - 1; for (let i = 1; i <= c; i++) { let o = Wf(t[i], !1); o.offset = Pm((e + o.offset * n) / s), r.push(o) } n = s, e = 0, i = "", t = r } return ym(this.element, t, this.preStyleProps, this.postStyleProps, n, e, i, !0) } } function Pm(t, e = 3) { const n = Math.pow(10, e - 1); return Math.round(t * n) / n } class Om { } class Im extends Om { normalizePropertyName(t, e) { return nm(t) } normalizeStyleValue(t, e, n, i) { let r = ""; const s = n.toString().trim(); if (Am[e] && 0 !== n && "0" !== n) if ("number" == typeof n) r = "px"; else { const e = n.match(/^[+-]?[\d\.]+([a-z]*)$/); e && 0 == e[1].length && i.push(`Please provide a CSS unit value for ${t}:${n}`) } return s + r } } const Am = (() => function (t) { const e = {}; return t.forEach(t => e[t] = !0), e }("width,height,minWidth,minHeight,maxWidth,maxHeight,left,top,bottom,right,fontSize,outlineWidth,outlineOffset,paddingTop,paddingLeft,paddingBottom,paddingRight,marginTop,marginLeft,marginBottom,marginRight,borderRadius,borderWidth,borderTopWidth,borderLeftWidth,borderRightWidth,borderBottomWidth,textIndent,perspective".split(",")))(); function Rm(t, e, n, i, r, s, o, l, a, c, u, h, d) { return { type: 0, element: t, triggerName: e, isRemovalTransition: r, fromState: n, fromStyles: s, toState: i, toStyles: o, timelines: l, queriedElements: a, preStyleProps: c, postStyleProps: u, totalTime: h, errors: d } } const Nm = {}; class Mm { constructor(t, e, n) { this._triggerName = t, this.ast = e, this._stateStyles = n } match(t, e, n, i) { return function (t, e, n, i, r) { return t.some(t => t(e, n, i, r)) }(this.ast.matchers, t, e, n, i) } buildStyles(t, e, n) { const i = this._stateStyles["*"], r = this._stateStyles[t], s = i ? i.buildStyles(e, n) : {}; return r ? r.buildStyles(e, n) : s } build(t, e, n, i, r, s, o, l, a, c) { const u = [], h = this.ast.options && this.ast.options.params || Nm, d = this.buildStyles(n, o && o.params || Nm, u), p = l && l.params || Nm, f = this.buildStyles(i, p, u), m = new Set, g = new Map, _ = new Map, y = "void" === i, v = { params: Object.assign({}, h, p) }, b = c ? [] : Cm(t, e, this.ast.animation, r, s, d, f, v, a, u); let w = 0; if (b.forEach(t => { w = Math.max(t.duration + t.delay, w) }), u.length) return Rm(e, this._triggerName, n, i, y, d, f, [], [], g, _, w, u); b.forEach(t => { const n = t.element, i = Tf(g, n, {}); t.preStyleProps.forEach(t => i[t] = !0); const r = Tf(_, n, {}); t.postStyleProps.forEach(t => r[t] = !0), n !== e && m.add(n) }); const C = tm(m.values()); return Rm(e, this._triggerName, n, i, y, d, f, b, C, g, _, w) } } class Dm { constructor(t, e) { this.styles = t, this.defaultParams = e } buildStyles(t, e) { const n = {}, i = $f(this.defaultParams); return Object.keys(t).forEach(e => { const n = t[e]; null != n && (i[e] = n) }), this.styles.styles.forEach(t => { if ("string" != typeof t) { const r = t; Object.keys(r).forEach(t => { let s = r[t]; s.length > 1 && (s = Jf(s, i, e)), n[t] = s }) } }), n } } class Fm { constructor(t, e) { this.name = t, this.ast = e, this.transitionFactories = [], this.states = {}, e.states.forEach(t => { this.states[t.name] = new Dm(t.style, t.options && t.options.params || {}) }), Lm(this.states, "true", "1"), Lm(this.states, "false", "0"), e.transitions.forEach(e => { this.transitionFactories.push(new Mm(t, e, this.states)) }), this.fallbackTransition = new Mm(t, { type: 1, animation: { type: 2, steps: [], options: null }, matchers: [(t, e) => !0], options: null, queryCount: 0, depCount: 0 }, this.states) } get containsQueries() { return this.ast.queryCount > 0 } matchTransition(t, e, n, i) { return this.transitionFactories.find(r => r.match(t, e, n, i)) || null } matchStyles(t, e, n) { return this.fallbackTransition.buildStyles(t, e, n) } } function Lm(t, e, n) { t.hasOwnProperty(e) ? t.hasOwnProperty(n) || (t[n] = t[e]) : t.hasOwnProperty(n) && (t[e] = t[n]) } const Vm = new vm; class zm { constructor(t, e, n) { this.bodyNode = t, this._driver = e, this._normalizer = n, this._animations = {}, this._playersById = {}, this.players = [] } register(t, e) { const n = [], i = dm(this._driver, e, n); if (n.length) throw new Error("Unable to build the animation due to the following errors: " + n.join("\n")); this._animations[t] = i } _buildPlayer(t, e, n) { const i = t.element, r = Cf(0, this._normalizer, 0, t.keyframes, e, n); return this._driver.animate(i, r, t.duration, t.delay, t.easing, [], !0) } create(t, e, n = {}) { const i = [], r = this._animations[t]; let s; const o = new Map; if (r ? (s = Cm(this._driver, e, r, "ng-enter", "ng-leave", {}, {}, n, Vm, i), s.forEach(t => { const e = Tf(o, t.element, {}); t.postStyleProps.forEach(t => e[t] = null) })) : (i.push("The requested animation doesn't exist or has already been destroyed"), s = []), i.length) throw new Error("Unable to create the animation due to the following errors: " + i.join("\n")); o.forEach((t, e) => { Object.keys(t).forEach(n => { t[n] = this._driver.computeStyle(e, n, "*") }) }); const l = wf(s.map(t => { const e = o.get(t.element); return this._buildPlayer(t, {}, e) })); return this._playersById[t] = l, l.onDestroy(() => this.destroy(t)), this.players.push(l), l } destroy(t) { const e = this._getPlayer(t); e.destroy(), delete this._playersById[t]; const n = this.players.indexOf(e); n >= 0 && this.players.splice(n, 1) } _getPlayer(t) { const e = this._playersById[t]; if (!e) throw new Error("Unable to find the timeline player referenced by " + t); return e } listen(t, e, n, i) { const r = xf(e, "", "", ""); return Sf(this._getPlayer(t), n, r, i), () => { } } command(t, e, n, i) { if ("register" == n) return void this.register(t, i[0]); if ("create" == n) return void this.create(t, e, i[0] || {}); const r = this._getPlayer(t); switch (n) { case "play": r.play(); break; case "pause": r.pause(); break; case "reset": r.reset(); break; case "restart": r.restart(); break; case "finish": r.finish(); break; case "init": r.init(); break; case "setPosition": r.setPosition(parseFloat(i[0])); break; case "destroy": this.destroy(t) } } } const jm = [], Um = { namespaceId: "", setForRemoval: !1, setForMove: !1, hasAnimation: !1, removedBeforeQueried: !1 }, Hm = { namespaceId: "", setForMove: !1, setForRemoval: !1, hasAnimation: !1, removedBeforeQueried: !0 }; class Bm { constructor(t, e = "") { this.namespaceId = e; const n = t && t.hasOwnProperty("value"); if (this.value = null != (i = n ? t.value : t) ? i : null, n) { const e = $f(t); delete e.value, this.options = e } else this.options = {}; var i; this.options.params || (this.options.params = {}) } get params() { return this.options.params } absorbOptions(t) { const e = t.params; if (e) { const t = this.options.params; Object.keys(e).forEach(n => { null == t[n] && (t[n] = e[n]) }) } } } const $m = new Bm("void"); class Wm { constructor(t, e, n) { this.id = t, this.hostElement = e, this._engine = n, this.players = [], this._triggers = {}, this._queue = [], this._elementListeners = new Map, this._hostClassName = "ng-tns-" + t, Xm(e, this._hostClassName) } listen(t, e, n, i) { if (!this._triggers.hasOwnProperty(e)) throw new Error(`Unable to listen on the animation trigger event "${n}" because the animation trigger "${e}" doesn't exist!`); if (null == n || 0 == n.length) throw new Error(`Unable to listen on the animation trigger "${e}" because the provided event is undefined!`); if ("start" != (r = n) && "done" != r) throw new Error(`The provided animation trigger event "${n}" for the animation trigger "${e}" is not supported!`); var r; const s = Tf(this._elementListeners, t, []), o = { name: e, phase: n, callback: i }; s.push(o); const l = Tf(this._engine.statesByElement, t, {}); return l.hasOwnProperty(e) || (Xm(t, "ng-trigger"), Xm(t, "ng-trigger-" + e), l[e] = $m), () => { this._engine.afterFlush(() => { const t = s.indexOf(o); t >= 0 && s.splice(t, 1), this._triggers[e] || delete l[e] }) } } register(t, e) { return !this._triggers[t] && (this._triggers[t] = e, !0) } _getTrigger(t) { const e = this._triggers[t]; if (!e) throw new Error(`The provided animation trigger "${t}" has not been registered!`); return e } trigger(t, e, n, i = !0) { const r = this._getTrigger(e), s = new Gm(this.id, e, t); let o = this._engine.statesByElement.get(t); o || (Xm(t, "ng-trigger"), Xm(t, "ng-trigger-" + e), this._engine.statesByElement.set(t, o = {})); let l = o[e]; const a = new Bm(n, this.id); if (!(n && n.hasOwnProperty("value")) && l && a.absorbOptions(l.options), o[e] = a, l || (l = $m), "void" !== a.value && l.value === a.value) { if (!function (t, e) { const n = Object.keys(t), i = Object.keys(e); if (n.length != i.length) return !1; for (let r = 0; r < n.length; r++) { const i = n[r]; if (!e.hasOwnProperty(i) || t[i] !== e[i]) return !1 } return !0 }(l.params, a.params)) { const e = [], n = r.matchStyles(l.value, l.params, e), i = r.matchStyles(a.value, a.params, e); e.length ? this._engine.reportError(e) : this._engine.afterFlush(() => { Qf(t, n), Zf(t, i) }) } return } const c = Tf(this._engine.playersByElement, t, []); c.forEach(t => { t.namespaceId == this.id && t.triggerName == e && t.queued && t.destroy() }); let u = r.matchTransition(l.value, a.value, t, a.params), h = !1; if (!u) { if (!i) return; u = r.fallbackTransition, h = !0 } return this._engine.totalQueuedPlayers++, this._queue.push({ element: t, triggerName: e, transition: u, fromState: l, toState: a, player: s, isFallbackTransition: h }), h || (Xm(t, "ng-animate-queued"), s.onStart(() => { Jm(t, "ng-animate-queued") })), s.onDone(() => { let e = this.players.indexOf(s); e >= 0 && this.players.splice(e, 1); const n = this._engine.playersByElement.get(t); if (n) { let t = n.indexOf(s); t >= 0 && n.splice(t, 1) } }), this.players.push(s), c.push(s), s } deregister(t) { delete this._triggers[t], this._engine.statesByElement.forEach((e, n) => { delete e[t] }), this._elementListeners.forEach((e, n) => { this._elementListeners.set(n, e.filter(e => e.name != t)) }) } clearElementCache(t) { this._engine.statesByElement.delete(t), this._elementListeners.delete(t); const e = this._engine.playersByElement.get(t); e && (e.forEach(t => t.destroy()), this._engine.playersByElement.delete(t)) } _signalRemovalForInnerTriggers(t, e, n = !1) { this._engine.driver.query(t, ".ng-trigger", !0).forEach(t => { if (t.__ng_removed) return; const n = this._engine.fetchNamespacesByElement(t); n.size ? n.forEach(n => n.triggerLeaveAnimation(t, e, !1, !0)) : this.clearElementCache(t) }) } triggerLeaveAnimation(t, e, n, i) { const r = this._engine.statesByElement.get(t); if (r) { const s = []; if (Object.keys(r).forEach(e => { if (this._triggers[e]) { const n = this.trigger(t, e, "void", i); n && s.push(n) } }), s.length) return this._engine.markElementAsRemoved(this.id, t, !0, e), n && wf(s).onDone(() => this._engine.processLeaveNode(t)), !0 } return !1 } prepareLeaveAnimationListeners(t) { const e = this._elementListeners.get(t); if (e) { const n = new Set; e.forEach(e => { const i = e.name; if (n.has(i)) return; n.add(i); const r = this._triggers[i].fallbackTransition, s = this._engine.statesByElement.get(t)[i] || $m, o = new Bm("void"), l = new Gm(this.id, i, t); this._engine.totalQueuedPlayers++, this._queue.push({ element: t, triggerName: i, transition: r, fromState: s, toState: o, player: l, isFallbackTransition: !0 }) }) } } removeNode(t, e) { const n = this._engine; if (t.childElementCount && this._signalRemovalForInnerTriggers(t, e, !0), this.triggerLeaveAnimation(t, e, !0)) return; let i = !1; if (n.totalAnimations) { const e = n.players.length ? n.playersByQueriedElement.get(t) : []; if (e && e.length) i = !0; else { let e = t; for (; e = e.parentNode;)if (n.statesByElement.get(e)) { i = !0; break } } } this.prepareLeaveAnimationListeners(t), i ? n.markElementAsRemoved(this.id, t, !1, e) : (n.afterFlush(() => this.clearElementCache(t)), n.destroyInnerAnimations(t), n._onRemovalComplete(t, e)) } insertNode(t, e) { Xm(t, this._hostClassName) } drainQueuedTransitions(t) { const e = []; return this._queue.forEach(n => { const i = n.player; if (i.destroyed) return; const r = n.element, s = this._elementListeners.get(r); s && s.forEach(e => { if (e.name == n.triggerName) { const i = xf(r, n.triggerName, n.fromState.value, n.toState.value); i._data = t, Sf(n.player, e.phase, i, e.callback) } }), i.markedForDestroy ? this._engine.afterFlush(() => { i.destroy() }) : e.push(n) }), this._queue = [], e.sort((t, e) => { const n = t.transition.ast.depCount, i = e.transition.ast.depCount; return 0 == n || 0 == i ? n - i : this._engine.driver.containsElement(t.element, e.element) ? 1 : -1 }) } destroy(t) { this.players.forEach(t => t.destroy()), this._signalRemovalForInnerTriggers(this.hostElement, t) } elementContainsData(t) { let e = !1; return this._elementListeners.has(t) && (e = !0), e = !!this._queue.find(e => e.element === t) || e, e } } class qm { constructor(t, e, n) { this.bodyNode = t, this.driver = e, this._normalizer = n, this.players = [], this.newHostElements = new Map, this.playersByElement = new Map, this.playersByQueriedElement = new Map, this.statesByElement = new Map, this.disabledNodes = new Set, this.totalAnimations = 0, this.totalQueuedPlayers = 0, this._namespaceLookup = {}, this._namespaceList = [], this._flushFns = [], this._whenQuietFns = [], this.namespacesByHostElement = new Map, this.collectedEnterElements = [], this.collectedLeaveElements = [], this.onRemovalComplete = (t, e) => { } } _onRemovalComplete(t, e) { this.onRemovalComplete(t, e) } get queuedPlayers() { const t = []; return this._namespaceList.forEach(e => { e.players.forEach(e => { e.queued && t.push(e) }) }), t } createNamespace(t, e) { const n = new Wm(t, e, this); return e.parentNode ? this._balanceNamespaceList(n, e) : (this.newHostElements.set(e, n), this.collectEnterElement(e)), this._namespaceLookup[t] = n } _balanceNamespaceList(t, e) { const n = this._namespaceList.length - 1; if (n >= 0) { let i = !1; for (let r = n; r >= 0; r--)if (this.driver.containsElement(this._namespaceList[r].hostElement, e)) { this._namespaceList.splice(r + 1, 0, t), i = !0; break } i || this._namespaceList.splice(0, 0, t) } else this._namespaceList.push(t); return this.namespacesByHostElement.set(e, t), t } register(t, e) { let n = this._namespaceLookup[t]; return n || (n = this.createNamespace(t, e)), n } registerTrigger(t, e, n) { let i = this._namespaceLookup[t]; i && i.register(e, n) && this.totalAnimations++ } destroy(t, e) { if (!t) return; const n = this._fetchNamespace(t); this.afterFlush(() => { this.namespacesByHostElement.delete(n.hostElement), delete this._namespaceLookup[t]; const e = this._namespaceList.indexOf(n); e >= 0 && this._namespaceList.splice(e, 1) }), this.afterFlushAnimationsDone(() => n.destroy(e)) } _fetchNamespace(t) { return this._namespaceLookup[t] } fetchNamespacesByElement(t) { const e = new Set, n = this.statesByElement.get(t); if (n) { const t = Object.keys(n); for (let i = 0; i < t.length; i++) { const r = n[t[i]].namespaceId; if (r) { const t = this._fetchNamespace(r); t && e.add(t) } } } return e } trigger(t, e, n, i) { if (Zm(e)) { const r = this._fetchNamespace(t); if (r) return r.trigger(e, n, i), !0 } return !1 } insertNode(t, e, n, i) { if (!Zm(e)) return; const r = e.__ng_removed; if (r && r.setForRemoval) { r.setForRemoval = !1, r.setForMove = !0; const t = this.collectedLeaveElements.indexOf(e); t >= 0 && this.collectedLeaveElements.splice(t, 1) } if (t) { const i = this._fetchNamespace(t); i && i.insertNode(e, n) } i && this.collectEnterElement(e) } collectEnterElement(t) { this.collectedEnterElements.push(t) } markElementAsDisabled(t, e) { e ? this.disabledNodes.has(t) || (this.disabledNodes.add(t), Xm(t, "ng-animate-disabled")) : this.disabledNodes.has(t) && (this.disabledNodes.delete(t), Jm(t, "ng-animate-disabled")) } removeNode(t, e, n, i) { if (Zm(e)) { const r = t ? this._fetchNamespace(t) : null; if (r ? r.removeNode(e, i) : this.markElementAsRemoved(t, e, !1, i), n) { const n = this.namespacesByHostElement.get(e); n && n.id !== t && n.removeNode(e, i) } } else this._onRemovalComplete(e, i) } markElementAsRemoved(t, e, n, i) { this.collectedLeaveElements.push(e), e.__ng_removed = { namespaceId: t, setForRemoval: i, hasAnimation: n, removedBeforeQueried: !1 } } listen(t, e, n, i, r) { return Zm(e) ? this._fetchNamespace(t).listen(e, n, i, r) : () => { } } _buildInstruction(t, e, n, i, r) { return t.transition.build(this.driver, t.element, t.fromState.value, t.toState.value, n, i, t.fromState.options, t.toState.options, e, r) } destroyInnerAnimations(t) { let e = this.driver.query(t, ".ng-trigger", !0); e.forEach(t => this.destroyActiveAnimationsForElement(t)), 0 != this.playersByQueriedElement.size && (e = this.driver.query(t, ".ng-animating", !0), e.forEach(t => this.finishActiveQueriedAnimationOnElement(t))) } destroyActiveAnimationsForElement(t) { const e = this.playersByElement.get(t); e && e.forEach(t => { t.queued ? t.markedForDestroy = !0 : t.destroy() }) } finishActiveQueriedAnimationOnElement(t) { const e = this.playersByQueriedElement.get(t); e && e.forEach(t => t.finish()) } whenRenderingDone() { return new Promise(t => { if (this.players.length) return wf(this.players).onDone(() => t()); t() }) } processLeaveNode(t) { const e = t.__ng_removed; if (e && e.setForRemoval) { if (t.__ng_removed = Um, e.namespaceId) { this.destroyInnerAnimations(t); const n = this._fetchNamespace(e.namespaceId); n && n.clearElementCache(t) } this._onRemovalComplete(t, e.setForRemoval) } this.driver.matchesElement(t, ".ng-animate-disabled") && this.markElementAsDisabled(t, !1), this.driver.query(t, ".ng-animate-disabled", !0).forEach(t => { this.markElementAsDisabled(t, !1) }) } flush(t = -1) { let e = []; if (this.newHostElements.size && (this.newHostElements.forEach((t, e) => this._balanceNamespaceList(t, e)), this.newHostElements.clear()), this.totalAnimations && this.collectedEnterElements.length) for (let n = 0; n < this.collectedEnterElements.length; n++)Xm(this.collectedEnterElements[n], "ng-star-inserted"); if (this._namespaceList.length && (this.totalQueuedPlayers || this.collectedLeaveElements.length)) { const n = []; try { e = this._flushAnimations(n, t) } finally { for (let t = 0; t < n.length; t++)n[t]() } } else for (let n = 0; n < this.collectedLeaveElements.length; n++)this.processLeaveNode(this.collectedLeaveElements[n]); if (this.totalQueuedPlayers = 0, this.collectedEnterElements.length = 0, this.collectedLeaveElements.length = 0, this._flushFns.forEach(t => t()), this._flushFns = [], this._whenQuietFns.length) { const t = this._whenQuietFns; this._whenQuietFns = [], e.length ? wf(e).onDone(() => { t.forEach(t => t()) }) : t.forEach(t => t()) } } reportError(t) { throw new Error("Unable to process animations due to the following failed trigger transitions\n " + t.join("\n")) } _flushAnimations(t, e) { const n = new vm, i = [], r = new Map, s = [], o = new Map, l = new Map, a = new Map, c = new Set; this.disabledNodes.forEach(t => { c.add(t); const e = this.driver.query(t, ".ng-animate-queued", !0); for (let n = 0; n < e.length; n++)c.add(e[n]) }); const u = this.bodyNode, h = Array.from(this.statesByElement.keys()), d = Ym(h, this.collectedEnterElements), p = new Map; let f = 0; d.forEach((t, e) => { const n = "ng-enter" + f++; p.set(e, n), t.forEach(t => Xm(t, n)) }); const m = [], g = new Set, _ = new Set; for (let I = 0; I < this.collectedLeaveElements.length; I++) { const t = this.collectedLeaveElements[I], e = t.__ng_removed; e && e.setForRemoval && (m.push(t), g.add(t), e.hasAnimation ? this.driver.query(t, ".ng-star-inserted", !0).forEach(t => g.add(t)) : _.add(t)) } const y = new Map, v = Ym(h, Array.from(g)); v.forEach((t, e) => { const n = "ng-leave" + f++; y.set(e, n), t.forEach(t => Xm(t, n)) }), t.push(() => { d.forEach((t, e) => { const n = p.get(e); t.forEach(t => Jm(t, n)) }), v.forEach((t, e) => { const n = y.get(e); t.forEach(t => Jm(t, n)) }), m.forEach(t => { this.processLeaveNode(t) }) }); const b = [], w = []; for (let I = this._namespaceList.length - 1; I >= 0; I--)this._namespaceList[I].drainQueuedTransitions(e).forEach(t => { const e = t.player, r = t.element; if (b.push(e), this.collectedEnterElements.length) { const t = r.__ng_removed; if (t && t.setForMove) return void e.destroy() } const c = !u || !this.driver.containsElement(u, r), h = y.get(r), d = p.get(r), f = this._buildInstruction(t, n, d, h, c); if (f.errors && f.errors.length) w.push(f); else { if (c) return e.onStart(() => Qf(r, f.fromStyles)), e.onDestroy(() => Zf(r, f.toStyles)), void i.push(e); if (t.isFallbackTransition) return e.onStart(() => Qf(r, f.fromStyles)), e.onDestroy(() => Zf(r, f.toStyles)), void i.push(e); f.timelines.forEach(t => t.stretchStartingKeyframe = !0), n.append(r, f.timelines), s.push({ instruction: f, player: e, element: r }), f.queriedElements.forEach(t => Tf(o, t, []).push(e)), f.preStyleProps.forEach((t, e) => { const n = Object.keys(t); if (n.length) { let t = l.get(e); t || l.set(e, t = new Set), n.forEach(e => t.add(e)) } }), f.postStyleProps.forEach((t, e) => { const n = Object.keys(t); let i = a.get(e); i || a.set(e, i = new Set), n.forEach(t => i.add(t)) }) } }); if (w.length) { const t = []; w.forEach(e => { t.push(`@${e.triggerName} has failed due to:\n`), e.errors.forEach(e => t.push(`- ${e}\n`)) }), b.forEach(t => t.destroy()), this.reportError(t) } const C = new Map, S = new Map; s.forEach(t => { const e = t.element; n.has(e) && (S.set(e, e), this._beforeAnimationBuild(t.player.namespaceId, t.instruction, C)) }), i.forEach(t => { const e = t.element; this._getPreviousPlayers(e, !1, t.namespaceId, t.triggerName, null).forEach(t => { Tf(C, e, []).push(t), t.destroy() }) }); const E = m.filter(t => eg(t, l, a)), x = new Map; Km(x, this.driver, _, a, "*").forEach(t => { eg(t, l, a) && E.push(t) }); const T = new Map; d.forEach((t, e) => { Km(T, this.driver, new Set(t), l, "!") }), E.forEach(t => { const e = x.get(t), n = T.get(t); x.set(t, Object.assign({}, e, n)) }); const k = [], P = [], O = {}; s.forEach(t => { const { element: e, player: s, instruction: o } = t; if (n.has(e)) { if (c.has(e)) return s.onDestroy(() => Zf(e, o.toStyles)), s.disabled = !0, s.overrideTotalTime(o.totalTime), void i.push(s); let t = O; if (S.size > 1) { let n = e; const i = []; for (; n = n.parentNode;) { const e = S.get(n); if (e) { t = e; break } i.push(n) } i.forEach(e => S.set(e, t)) } const n = this._buildAnimation(s.namespaceId, o, C, r, T, x); if (s.setRealPlayer(n), t === O) k.push(s); else { const e = this.playersByElement.get(t); e && e.length && (s.parentPlayer = wf(e)), i.push(s) } } else Qf(e, o.fromStyles), s.onDestroy(() => Zf(e, o.toStyles)), P.push(s), c.has(e) && i.push(s) }), P.forEach(t => { const e = r.get(t.element); if (e && e.length) { const n = wf(e); t.setRealPlayer(n) } }), i.forEach(t => { t.parentPlayer ? t.syncPlayerEvents(t.parentPlayer) : t.destroy() }); for (let I = 0; I < m.length; I++) { const t = m[I], e = t.__ng_removed; if (Jm(t, "ng-leave"), e && e.hasAnimation) continue; let n = []; if (o.size) { let e = o.get(t); e && e.length && n.push(...e); let i = this.driver.query(t, ".ng-animating", !0); for (let t = 0; t < i.length; t++) { let e = o.get(i[t]); e && e.length && n.push(...e) } } const i = n.filter(t => !t.destroyed); i.length ? tg(this, t, i) : this.processLeaveNode(t) } return m.length = 0, k.forEach(t => { this.players.push(t), t.onDone(() => { t.destroy(); const e = this.players.indexOf(t); this.players.splice(e, 1) }), t.play() }), k } elementContainsData(t, e) { let n = !1; const i = e.__ng_removed; return i && i.setForRemoval && (n = !0), this.playersByElement.has(e) && (n = !0), this.playersByQueriedElement.has(e) && (n = !0), this.statesByElement.has(e) && (n = !0), this._fetchNamespace(t).elementContainsData(e) || n } afterFlush(t) { this._flushFns.push(t) } afterFlushAnimationsDone(t) { this._whenQuietFns.push(t) } _getPreviousPlayers(t, e, n, i, r) { let s = []; if (e) { const e = this.playersByQueriedElement.get(t); e && (s = e) } else { const e = this.playersByElement.get(t); if (e) { const t = !r || "void" == r; e.forEach(e => { e.queued || (t || e.triggerName == i) && s.push(e) }) } } return (n || i) && (s = s.filter(t => !(n && n != t.namespaceId || i && i != t.triggerName))), s } _beforeAnimationBuild(t, e, n) { const i = e.element, r = e.isRemovalTransition ? void 0 : t, s = e.isRemovalTransition ? void 0 : e.triggerName; for (const o of e.timelines) { const t = o.element, l = t !== i, a = Tf(n, t, []); this._getPreviousPlayers(t, l, r, s, e.toState).forEach(t => { const e = t.getRealPlayer(); e.beforeDestroy && e.beforeDestroy(), t.destroy(), a.push(t) }) } Qf(i, e.fromStyles) } _buildAnimation(t, e, n, i, r, s) { const o = e.triggerName, l = e.element, a = [], c = new Set, u = new Set, h = e.timelines.map(e => { const h = e.element; c.add(h); const d = h.__ng_removed; if (d && d.removedBeforeQueried) return new ep(e.duration, e.delay); const p = h !== l, f = function (t) { const e = []; return function t(e, n) { for (let i = 0; i < e.length; i++) { const r = e[i]; r instanceof np ? t(r.players, n) : n.push(r) } }(t, e), e }((n.get(h) || jm).map(t => t.getRealPlayer())).filter(t => !!t.element && t.element === h), m = r.get(h), g = s.get(h), _ = Cf(0, this._normalizer, 0, e.keyframes, m, g), y = this._buildPlayer(e, _, f); if (e.subTimeline && i && u.add(h), p) { const e = new Gm(t, o, h); e.setRealPlayer(y), a.push(e) } return y }); a.forEach(t => { Tf(this.playersByQueriedElement, t.element, []).push(t), t.onDone(() => function (t, e, n) { let i; if (t instanceof Map) { if (i = t.get(e), i) { if (i.length) { const t = i.indexOf(n); i.splice(t, 1) } 0 == i.length && t.delete(e) } } else if (i = t[e], i) { if (i.length) { const t = i.indexOf(n); i.splice(t, 1) } 0 == i.length && delete t[e] } return i }(this.playersByQueriedElement, t.element, t)) }), c.forEach(t => Xm(t, "ng-animating")); const d = wf(h); return d.onDestroy(() => { c.forEach(t => Jm(t, "ng-animating")), Zf(l, e.toStyles) }), u.forEach(t => { Tf(i, t, []).push(d) }), d } _buildPlayer(t, e, n) { return e.length > 0 ? this.driver.animate(t.element, e, t.duration, t.delay, t.easing, n) : new ep(t.duration, t.delay) } } class Gm { constructor(t, e, n) { this.namespaceId = t, this.triggerName = e, this.element = n, this._player = new ep, this._containsRealPlayer = !1, this._queuedCallbacks = {}, this.destroyed = !1, this.markedForDestroy = !1, this.disabled = !1, this.queued = !0, this.totalTime = 0 } setRealPlayer(t) { this._containsRealPlayer || (this._player = t, Object.keys(this._queuedCallbacks).forEach(e => { this._queuedCallbacks[e].forEach(n => Sf(t, e, void 0, n)) }), this._queuedCallbacks = {}, this._containsRealPlayer = !0, this.overrideTotalTime(t.totalTime), this.queued = !1) } getRealPlayer() { return this._player } overrideTotalTime(t) { this.totalTime = t } syncPlayerEvents(t) { const e = this._player; e.triggerCallback && t.onStart(() => e.triggerCallback("start")), t.onDone(() => this.finish()), t.onDestroy(() => this.destroy()) } _queueEvent(t, e) { Tf(this._queuedCallbacks, t, []).push(e) } onDone(t) { this.queued && this._queueEvent("done", t), this._player.onDone(t) } onStart(t) { this.queued && this._queueEvent("start", t), this._player.onStart(t) } onDestroy(t) { this.queued && this._queueEvent("destroy", t), this._player.onDestroy(t) } init() { this._player.init() } hasStarted() { return !this.queued && this._player.hasStarted() } play() { !this.queued && this._player.play() } pause() { !this.queued && this._player.pause() } restart() { !this.queued && this._player.restart() } finish() { this._player.finish() } destroy() { this.destroyed = !0, this._player.destroy() } reset() { !this.queued && this._player.reset() } setPosition(t) { this.queued || this._player.setPosition(t) } getPosition() { return this.queued ? 0 : this._player.getPosition() } triggerCallback(t) { const e = this._player; e.triggerCallback && e.triggerCallback(t) } } function Zm(t) { return t && 1 === t.nodeType } function Qm(t, e) { const n = t.style.display; return t.style.display = null != e ? e : "none", n } function Km(t, e, n, i, r) { const s = []; n.forEach(t => s.push(Qm(t))); const o = []; i.forEach((n, i) => { const s = {}; n.forEach(t => { const n = s[t] = e.computeStyle(i, t, r); n && 0 != n.length || (i.__ng_removed = Hm, o.push(i)) }), t.set(i, s) }); let l = 0; return n.forEach(t => Qm(t, s[l++])), o } function Ym(t, e) { const n = new Map; if (t.forEach(t => n.set(t, [])), 0 == e.length) return n; const i = new Set(e), r = new Map; return e.forEach(t => { const e = function t(e) { if (!e) return 1; let s = r.get(e); if (s) return s; const o = e.parentNode; return s = n.has(o) ? o : i.has(o) ? 1 : t(o), r.set(e, s), s }(t); 1 !== e && n.get(e).push(t) }), n } function Xm(t, e) { if (t.classList) t.classList.add(e); else { let n = t.$$classes; n || (n = t.$$classes = {}), n[e] = !0 } } function Jm(t, e) { if (t.classList) t.classList.remove(e); else { let n = t.$$classes; n && delete n[e] } } function tg(t, e, n) { wf(n).onDone(() => t.processLeaveNode(e)) } function eg(t, e, n) { const i = n.get(t); if (!i) return !1; let r = e.get(t); return r ? i.forEach(t => r.add(t)) : e.set(t, i), n.delete(t), !0 } class ng { constructor(t, e, n) { this.bodyNode = t, this._driver = e, this._triggerCache = {}, this.onRemovalComplete = (t, e) => { }, this._transitionEngine = new qm(t, e, n), this._timelineEngine = new zm(t, e, n), this._transitionEngine.onRemovalComplete = (t, e) => this.onRemovalComplete(t, e) } registerTrigger(t, e, n, i, r) { const s = t + "-" + i; let o = this._triggerCache[s]; if (!o) { const t = [], e = dm(this._driver, r, t); if (t.length) throw new Error(`The animation trigger "${i}" has failed to build due to the following errors:\n - ${t.join("\n - ")}`); o = function (t, e) { return new Fm(t, e) }(i, e), this._triggerCache[s] = o } this._transitionEngine.registerTrigger(e, i, o) } register(t, e) { this._transitionEngine.register(t, e) } destroy(t, e) { this._transitionEngine.destroy(t, e) } onInsert(t, e, n, i) { this._transitionEngine.insertNode(t, e, n, i) } onRemove(t, e, n, i) { this._transitionEngine.removeNode(t, e, i || !1, n) } disableAnimations(t, e) { this._transitionEngine.markElementAsDisabled(t, e) } process(t, e, n, i) { if ("@" == n.charAt(0)) { const [t, r] = kf(n); this._timelineEngine.command(t, e, r, i) } else this._transitionEngine.trigger(t, e, n, i) } listen(t, e, n, i, r) { if ("@" == n.charAt(0)) { const [t, i] = kf(n); return this._timelineEngine.listen(t, e, i, r) } return this._transitionEngine.listen(t, e, n, i, r) } flush(t = -1) { this._transitionEngine.flush(t) } get players() { return this._transitionEngine.players.concat(this._timelineEngine.players) } whenRenderingDone() { return this._transitionEngine.whenRenderingDone() } } function ig(t, e) { let n = null, i = null; return Array.isArray(e) && e.length ? (n = sg(e[0]), e.length > 1 && (i = sg(e[e.length - 1]))) : e && (n = sg(e)), n || i ? new rg(t, n, i) : null } let rg = (() => { class t { constructor(e, n, i) { this._element = e, this._startStyles = n, this._endStyles = i, this._state = 0; let r = t.initialStylesByElement.get(e); r || t.initialStylesByElement.set(e, r = {}), this._initialStyles = r } start() { this._state < 1 && (this._startStyles && Zf(this._element, this._startStyles, this._initialStyles), this._state = 1) } finish() { this.start(), this._state < 2 && (Zf(this._element, this._initialStyles), this._endStyles && (Zf(this._element, this._endStyles), this._endStyles = null), this._state = 1) } destroy() { this.finish(), this._state < 3 && (t.initialStylesByElement.delete(this._element), this._startStyles && (Qf(this._element, this._startStyles), this._endStyles = null), this._endStyles && (Qf(this._element, this._endStyles), this._endStyles = null), Zf(this._element, this._initialStyles), this._state = 3) } } return t.initialStylesByElement = new WeakMap, t })(); function sg(t) { let e = null; const n = Object.keys(t); for (let i = 0; i < n.length; i++) { const r = n[i]; og(r) && (e = e || {}, e[r] = t[r]) } return e } function og(t) { return "display" === t || "position" === t } class lg { constructor(t, e, n, i, r, s, o) { this._element = t, this._name = e, this._duration = n, this._delay = i, this._easing = r, this._fillMode = s, this._onDoneFn = o, this._finished = !1, this._destroyed = !1, this._startTime = 0, this._position = 0, this._eventFn = t => this._handleCallback(t) } apply() { !function (t, e) { const n = pg(t, "").trim(); n.length && (function (t, e) { let n = 0; for (let i = 0; i < t.length; i++)"," === t.charAt(i) && n++ }(n), e = `${n}, ${e}`), dg(t, "", e) }(this._element, `${this._duration}ms ${this._easing} ${this._delay}ms 1 normal ${this._fillMode} ${this._name}`), hg(this._element, this._eventFn, !1), this._startTime = Date.now() } pause() { ag(this._element, this._name, "paused") } resume() { ag(this._element, this._name, "running") } setPosition(t) { const e = cg(this._element, this._name); this._position = t * this._duration, dg(this._element, "Delay", `-${this._position}ms`, e) } getPosition() { return this._position } _handleCallback(t) { const e = t._ngTestManualTimestamp || Date.now(), n = 1e3 * parseFloat(t.elapsedTime.toFixed(3)); t.animationName == this._name && Math.max(e - this._startTime, 0) >= this._delay && n >= this._duration && this.finish() } finish() { this._finished || (this._finished = !0, this._onDoneFn(), hg(this._element, this._eventFn, !0)) } destroy() { this._destroyed || (this._destroyed = !0, this.finish(), function (t, e) { const n = pg(t, "").split(","), i = ug(n, e); i >= 0 && (n.splice(i, 1), dg(t, "", n.join(","))) }(this._element, this._name)) } } function ag(t, e, n) { dg(t, "PlayState", n, cg(t, e)) } function cg(t, e) { const n = pg(t, ""); return n.indexOf(",") > 0 ? ug(n.split(","), e) : ug([n], e) } function ug(t, e) { for (let n = 0; n < t.length; n++)if (t[n].indexOf(e) >= 0) return n; return -1 } function hg(t, e, n) { n ? t.removeEventListener("animationend", e) : t.addEventListener("animationend", e) } function dg(t, e, n, i) { const r = "animation" + e; if (null != i) { const e = t.style[r]; if (e.length) { const t = e.split(","); t[i] = n, n = t.join(",") } } t.style[r] = n } function pg(t, e) { return t.style["animation" + e] } class fg { constructor(t, e, n, i, r, s, o, l) { this.element = t, this.keyframes = e, this.animationName = n, this._duration = i, this._delay = r, this._finalStyles = o, this._specialStyles = l, this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._started = !1, this.currentSnapshot = {}, this._state = 0, this.easing = s || "linear", this.totalTime = i + r, this._buildStyler() } onStart(t) { this._onStartFns.push(t) } onDone(t) { this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } destroy() { this.init(), this._state >= 4 || (this._state = 4, this._styler.destroy(), this._flushStartFns(), this._flushDoneFns(), this._specialStyles && this._specialStyles.destroy(), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } _flushDoneFns() { this._onDoneFns.forEach(t => t()), this._onDoneFns = [] } _flushStartFns() { this._onStartFns.forEach(t => t()), this._onStartFns = [] } finish() { this.init(), this._state >= 3 || (this._state = 3, this._styler.finish(), this._flushStartFns(), this._specialStyles && this._specialStyles.finish(), this._flushDoneFns()) } setPosition(t) { this._styler.setPosition(t) } getPosition() { return this._styler.getPosition() } hasStarted() { return this._state >= 2 } init() { this._state >= 1 || (this._state = 1, this._styler.apply(), this._delay && this._styler.pause()) } play() { this.init(), this.hasStarted() || (this._flushStartFns(), this._state = 2, this._specialStyles && this._specialStyles.start()), this._styler.resume() } pause() { this.init(), this._styler.pause() } restart() { this.reset(), this.play() } reset() { this._styler.destroy(), this._buildStyler(), this._styler.apply() } _buildStyler() { this._styler = new lg(this.element, this.animationName, this._duration, this._delay, this.easing, "forwards", () => this.finish()) } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns; e.forEach(t => t()), e.length = 0 } beforeDestroy() { this.init(); const t = {}; if (this.hasStarted()) { const e = this._state >= 3; Object.keys(this._finalStyles).forEach(n => { "offset" != n && (t[n] = e ? this._finalStyles[n] : om(this.element, n)) }) } this.currentSnapshot = t } } class mg extends ep { constructor(t, e) { super(), this.element = t, this._startingStyles = {}, this.__initialized = !1, this._styles = Vf(e) } init() { !this.__initialized && this._startingStyles && (this.__initialized = !0, Object.keys(this._styles).forEach(t => { this._startingStyles[t] = this.element.style[t] }), super.init()) } play() { this._startingStyles && (this.init(), Object.keys(this._styles).forEach(t => this.element.style.setProperty(t, this._styles[t])), super.play()) } destroy() { this._startingStyles && (Object.keys(this._startingStyles).forEach(t => { const e = this._startingStyles[t]; e ? this.element.style.setProperty(t, e) : this.element.style.removeProperty(t) }), this._startingStyles = null, super.destroy()) } } class gg { constructor() { this._count = 0, this._head = document.querySelector("head"), this._warningIssued = !1 } validateStyleProperty(t) { return Mf(t) } matchesElement(t, e) { return Df(t, e) } containsElement(t, e) { return Ff(t, e) } query(t, e, n) { return Lf(t, e, n) } computeStyle(t, e, n) { return window.getComputedStyle(t)[e] } buildKeyframeElement(t, e, n) { n = n.map(t => Vf(t)); let i = `@keyframes ${e} {\n`, r = ""; n.forEach(t => { r = " "; const e = parseFloat(t.offset); i += `${r}${100 * e}% {\n`, r += " ", Object.keys(t).forEach(e => { const n = t[e]; switch (e) { case "offset": return; case "easing": return void (n && (i += `${r}animation-timing-function: ${n};\n`)); default: return void (i += `${r}${e}: ${n};\n`) } }), i += r + "}\n" }), i += "}\n"; const s = document.createElement("style"); return s.innerHTML = i, s } animate(t, e, n, i, r, s = [], o) { o && this._notifyFaultyScrubber(); const l = s.filter(t => t instanceof fg), a = {}; im(n, i) && l.forEach(t => { let e = t.currentSnapshot; Object.keys(e).forEach(t => a[t] = e[t]) }); const c = function (t) { let e = {}; return t && (Array.isArray(t) ? t : [t]).forEach(t => { Object.keys(t).forEach(n => { "offset" != n && "easing" != n && (e[n] = t[n]) }) }), e }(e = rm(t, e, a)); if (0 == n) return new mg(t, c); const u = "gen_css_kf_" + this._count++, h = this.buildKeyframeElement(t, u, e); document.querySelector("head").appendChild(h); const d = ig(t, e), p = new fg(t, e, u, n, i, r, c, d); return p.onDestroy(() => { var t; (t = h).parentNode.removeChild(t) }), p } _notifyFaultyScrubber() { this._warningIssued || (console.warn("@angular/animations: please load the web-animations.js polyfill to allow programmatic access...\n", "  visit http://bit.ly/IWukam to learn more about using the web-animation-js polyfill."), this._warningIssued = !0) } } class _g { constructor(t, e, n, i) { this.element = t, this.keyframes = e, this.options = n, this._specialStyles = i, this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._initialized = !1, this._finished = !1, this._started = !1, this._destroyed = !1, this.time = 0, this.parentPlayer = null, this.currentSnapshot = {}, this._duration = n.duration, this._delay = n.delay || 0, this.time = this._duration + this._delay } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(t => t()), this._onDoneFns = []) } init() { this._buildPlayer(), this._preparePlayerBeforeStart() } _buildPlayer() { if (this._initialized) return; this._initialized = !0; const t = this.keyframes; this.domPlayer = this._triggerWebAnimation(this.element, t, this.options), this._finalKeyframe = t.length ? t[t.length - 1] : {}, this.domPlayer.addEventListener("finish", () => this._onFinish()) } _preparePlayerBeforeStart() { this._delay ? this._resetDomPlayerState() : this.domPlayer.pause() } _triggerWebAnimation(t, e, n) { return t.animate(e, n) } onStart(t) { this._onStartFns.push(t) } onDone(t) { this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } play() { this._buildPlayer(), this.hasStarted() || (this._onStartFns.forEach(t => t()), this._onStartFns = [], this._started = !0, this._specialStyles && this._specialStyles.start()), this.domPlayer.play() } pause() { this.init(), this.domPlayer.pause() } finish() { this.init(), this._specialStyles && this._specialStyles.finish(), this._onFinish(), this.domPlayer.finish() } reset() { this._resetDomPlayerState(), this._destroyed = !1, this._finished = !1, this._started = !1 } _resetDomPlayerState() { this.domPlayer && this.domPlayer.cancel() } restart() { this.reset(), this.play() } hasStarted() { return this._started } destroy() { this._destroyed || (this._destroyed = !0, this._resetDomPlayerState(), this._onFinish(), this._specialStyles && this._specialStyles.destroy(), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } setPosition(t) { this.domPlayer.currentTime = t * this.time } getPosition() { return this.domPlayer.currentTime / this.time } get totalTime() { return this._delay + this._duration } beforeDestroy() { const t = {}; this.hasStarted() && Object.keys(this._finalKeyframe).forEach(e => { "offset" != e && (t[e] = this._finished ? this._finalKeyframe[e] : om(this.element, e)) }), this.currentSnapshot = t } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns; e.forEach(t => t()), e.length = 0 } } class yg { constructor() { this._isNativeImpl = /\{\s*\[native\s+code\]\s*\}/.test(vg().toString()), this._cssKeyframesDriver = new gg } validateStyleProperty(t) { return Mf(t) } matchesElement(t, e) { return Df(t, e) } containsElement(t, e) { return Ff(t, e) } query(t, e, n) { return Lf(t, e, n) } computeStyle(t, e, n) { return window.getComputedStyle(t)[e] } overrideWebAnimationsSupport(t) { this._isNativeImpl = t } animate(t, e, n, i, r, s = [], o) { if (!o && !this._isNativeImpl) return this._cssKeyframesDriver.animate(t, e, n, i, r, s); const l = { duration: n, delay: i, fill: 0 == i ? "both" : "forwards" }; r && (l.easing = r); const a = {}, c = s.filter(t => t instanceof _g); im(n, i) && c.forEach(t => { let e = t.currentSnapshot; Object.keys(e).forEach(t => a[t] = e[t]) }); const u = ig(t, e = rm(t, e = e.map(t => Wf(t, !1)), a)); return new _g(t, e, l, u) } } function vg() { return "undefined" != typeof window && void 0 !== window.document && Element.prototype.animate || {} } let bg = (() => class extends Yd { constructor(t, e) { super(), this._nextAnimationId = 0, this._renderer = t.createRenderer(e.body, { id: "0", encapsulation: Zt.None, styles: [], data: { animation: [] } }) } build(t) { const e = this._nextAnimationId.toString(); this._nextAnimationId++; const n = Array.isArray(t) ? Xd(t) : t; return Sg(this._renderer, null, e, "register", [n]), new wg(e, this._renderer) } })(); class wg extends class { }{ constructor(t, e) { super(), this._id = t, this._renderer = e } create(t, e) { return new Cg(this._id, t, e || {}, this._renderer) } } class Cg { constructor(t, e, n, i) { this.id = t, this.element = e, this._renderer = i, this.parentPlayer = null, this._started = !1, this.totalTime = 0, this._command("create", n) } _listen(t, e) { return this._renderer.listen(this.element, `@@${this.id}:${t}`, e) } _command(t, ...e) { return Sg(this._renderer, this.element, this.id, t, e) } onDone(t) { this._listen("done", t) } onStart(t) { this._listen("start", t) } onDestroy(t) { this._listen("destroy", t) } init() { this._command("init") } hasStarted() { return this._started } play() { this._command("play"), this._started = !0 } pause() { this._command("pause") } restart() { this._command("restart") } finish() { this._command("finish") } destroy() { this._command("destroy") } reset() { this._command("reset") } setPosition(t) { this._command("setPosition", t) } getPosition() { return 0 } } function Sg(t, e, n, i, r) { return t.setProperty(e, `@@${n}:${i}`, r) } let Eg = (() => class { constructor(t, e, n) { this.delegate = t, this.engine = e, this._zone = n, this._currentId = 0, this._microtaskId = 1, this._animationCallbacksBuffer = [], this._rendererCache = new Map, this._cdRecurDepth = 0, this.promise = Promise.resolve(0), e.onRemovalComplete = (t, e) => { e && e.parentNode(t) && e.removeChild(t.parentNode, t) } } createRenderer(t, e) { const n = this.delegate.createRenderer(t, e); if (!(t && e && e.data && e.data.animation)) { let t = this._rendererCache.get(n); return t || (t = new xg("", n, this.engine), this._rendererCache.set(n, t)), t } const i = e.id, r = e.id + "-" + this._currentId; return this._currentId++, this.engine.register(r, t), e.data.animation.forEach(e => this.engine.registerTrigger(i, r, t, e.name, e)), new Tg(this, r, n, this.engine) } begin() { this._cdRecurDepth++, this.delegate.begin && this.delegate.begin() } _scheduleCountTask() { this.promise.then(() => { this._microtaskId++ }) } scheduleListenerCallback(t, e, n) { t >= 0 && t < this._microtaskId ? this._zone.run(() => e(n)) : (0 == this._animationCallbacksBuffer.length && Promise.resolve(null).then(() => { this._zone.run(() => { this._animationCallbacksBuffer.forEach(t => { const [e, n] = t; e(n) }), this._animationCallbacksBuffer = [] }) }), this._animationCallbacksBuffer.push([e, n])) } end() { this._cdRecurDepth--, 0 == this._cdRecurDepth && this._zone.runOutsideAngular(() => { this._scheduleCountTask(), this.engine.flush(this._microtaskId) }), this.delegate.end && this.delegate.end() } whenRenderingDone() { return this.engine.whenRenderingDone() } })(); class xg { constructor(t, e, n) { this.namespaceId = t, this.delegate = e, this.engine = n, this.destroyNode = this.delegate.destroyNode ? t => e.destroyNode(t) : null } get data() { return this.delegate.data } destroy() { this.engine.destroy(this.namespaceId, this.delegate), this.delegate.destroy() } createElement(t, e) { return this.delegate.createElement(t, e) } createComment(t) { return this.delegate.createComment(t) } createText(t) { return this.delegate.createText(t) } appendChild(t, e) { this.delegate.appendChild(t, e), this.engine.onInsert(this.namespaceId, e, t, !1) } insertBefore(t, e, n) { this.delegate.insertBefore(t, e, n), this.engine.onInsert(this.namespaceId, e, t, !0) } removeChild(t, e, n) { this.engine.onRemove(this.namespaceId, e, this.delegate, n) } selectRootElement(t, e) { return this.delegate.selectRootElement(t, e) } parentNode(t) { return this.delegate.parentNode(t) } nextSibling(t) { return this.delegate.nextSibling(t) } setAttribute(t, e, n, i) { this.delegate.setAttribute(t, e, n, i) } removeAttribute(t, e, n) { this.delegate.removeAttribute(t, e, n) } addClass(t, e) { this.delegate.addClass(t, e) } removeClass(t, e) { this.delegate.removeClass(t, e) } setStyle(t, e, n, i) { this.delegate.setStyle(t, e, n, i) } removeStyle(t, e, n) { this.delegate.removeStyle(t, e, n) } setProperty(t, e, n) { "@" == e.charAt(0) && "@.disabled" == e ? this.disableAnimations(t, !!n) : this.delegate.setProperty(t, e, n) } setValue(t, e) { this.delegate.setValue(t, e) } listen(t, e, n) { return this.delegate.listen(t, e, n) } disableAnimations(t, e) { this.engine.disableAnimations(t, e) } } class Tg extends xg { constructor(t, e, n, i) { super(e, n, i), this.factory = t, this.namespaceId = e } setProperty(t, e, n) { "@" == e.charAt(0) ? "." == e.charAt(1) && "@.disabled" == e ? this.disableAnimations(t, n = void 0 === n || !!n) : this.engine.process(this.namespaceId, t, e.substr(1), n) : this.delegate.setProperty(t, e, n) } listen(t, e, n) { if ("@" == e.charAt(0)) { const i = function (t) { switch (t) { case "body": return document.body; case "document": return document; case "window": return window; default: return t } }(t); let r = e.substr(1), s = ""; return "@" != r.charAt(0) && ([r, s] = function (t) { const e = t.indexOf("."); return [t.substring(0, e), t.substr(e + 1)] }(r)), this.engine.listen(this.namespaceId, i, r, s, t => { this.factory.scheduleListenerCallback(t._data || -1, n, t) }) } return this.delegate.listen(t, e, n) } } let kg = (() => class extends ng { constructor(t, e, n) { super(t.body, e, n) } })(); function Pg() { return "function" == typeof vg() ? new yg : new gg } function Og() { return new Im } function Ig(t, e, n) { return new Eg(t, e, n) } const Ag = new Tt("AnimationModuleType"); let Rg = (() => class { })(); var Ng = jn({ encapsulation: 2, styles: [".mat-form-field{display:inline-block;position:relative;text-align:left}[dir=rtl] .mat-form-field{text-align:right}.mat-form-field-wrapper{position:relative}.mat-form-field-flex{display:inline-flex;align-items:baseline;box-sizing:border-box;width:100%}.mat-form-field-prefix,.mat-form-field-suffix{white-space:nowrap;flex:none;position:relative}.mat-form-field-infix{display:block;position:relative;flex:auto;min-width:0;width:180px}@media (-ms-high-contrast:active){.mat-form-field-infix{border-image:linear-gradient(transparent,transparent)}}.mat-form-field-label-wrapper{position:absolute;left:0;box-sizing:content-box;width:100%;height:100%;overflow:hidden;pointer-events:none}[dir=rtl] .mat-form-field-label-wrapper{left:auto;right:0}.mat-form-field-label{position:absolute;left:0;font:inherit;pointer-events:none;width:100%;white-space:nowrap;text-overflow:ellipsis;overflow:hidden;transform-origin:0 0;transition:transform .4s cubic-bezier(.25,.8,.25,1),color .4s cubic-bezier(.25,.8,.25,1),width .4s cubic-bezier(.25,.8,.25,1);display:none}[dir=rtl] .mat-form-field-label{transform-origin:100% 0;left:auto;right:0}.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label,.mat-form-field-empty.mat-form-field-label{display:block}.mat-form-field-autofill-control:-webkit-autofill+.mat-form-field-label-wrapper .mat-form-field-label{display:none}.mat-form-field-can-float .mat-form-field-autofill-control:-webkit-autofill+.mat-form-field-label-wrapper .mat-form-field-label{display:block;transition:none}.mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label,.mat-input-server[placeholder]:not(:placeholder-shown)+.mat-form-field-label-wrapper .mat-form-field-label{display:none}.mat-form-field-can-float .mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label,.mat-form-field-can-float .mat-input-server[placeholder]:not(:placeholder-shown)+.mat-form-field-label-wrapper .mat-form-field-label{display:block}.mat-form-field-label:not(.mat-form-field-empty){transition:none}.mat-form-field-underline{position:absolute;width:100%;pointer-events:none;transform:scaleY(1.0001)}.mat-form-field-ripple{position:absolute;left:0;width:100%;transform-origin:50%;transform:scaleX(.5);opacity:0;transition:background-color .3s cubic-bezier(.55,0,.55,.2)}.mat-form-field.mat-focused .mat-form-field-ripple,.mat-form-field.mat-form-field-invalid .mat-form-field-ripple{opacity:1;transform:scaleX(1);transition:transform .3s cubic-bezier(.25,.8,.25,1),opacity .1s cubic-bezier(.25,.8,.25,1),background-color .3s cubic-bezier(.25,.8,.25,1)}.mat-form-field-subscript-wrapper{position:absolute;box-sizing:border-box;width:100%;overflow:hidden}.mat-form-field-label-wrapper .mat-icon,.mat-form-field-subscript-wrapper .mat-icon{width:1em;height:1em;font-size:inherit;vertical-align:baseline}.mat-form-field-hint-wrapper{display:flex}.mat-form-field-hint-spacer{flex:1 0 1em}.mat-error{display:block}.mat-form-field-control-wrapper{position:relative}.mat-form-field._mat-animation-noopable .mat-form-field-label,.mat-form-field._mat-animation-noopable .mat-form-field-ripple{transition:none}", ".mat-form-field-appearance-fill .mat-form-field-flex{border-radius:4px 4px 0 0;padding:.75em .75em 0 .75em}@media (-ms-high-contrast:active){.mat-form-field-appearance-fill .mat-form-field-flex{outline:solid 1px}}.mat-form-field-appearance-fill .mat-form-field-underline::before{content:'';display:block;position:absolute;bottom:0;height:1px;width:100%}.mat-form-field-appearance-fill .mat-form-field-ripple{bottom:0;height:2px}@media (-ms-high-contrast:active){.mat-form-field-appearance-fill .mat-form-field-ripple{height:0;border-top:solid 2px}}.mat-form-field-appearance-fill:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{opacity:1;transform:none;transition:opacity .6s cubic-bezier(.25,.8,.25,1)}.mat-form-field-appearance-fill._mat-animation-noopable:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{transition:none}.mat-form-field-appearance-fill .mat-form-field-subscript-wrapper{padding:0 1em}", ".mat-input-element{font:inherit;background:0 0;color:currentColor;border:none;outline:0;padding:0;margin:0;width:100%;max-width:100%;vertical-align:bottom;text-align:inherit}.mat-input-element:-moz-ui-invalid{box-shadow:none}.mat-input-element::-ms-clear,.mat-input-element::-ms-reveal{display:none}.mat-input-element,.mat-input-element::-webkit-search-cancel-button,.mat-input-element::-webkit-search-decoration,.mat-input-element::-webkit-search-results-button,.mat-input-element::-webkit-search-results-decoration{-webkit-appearance:none}.mat-input-element::-webkit-caps-lock-indicator,.mat-input-element::-webkit-contacts-auto-fill-button,.mat-input-element::-webkit-credentials-auto-fill-button{visibility:hidden}.mat-input-element[type=date]::after,.mat-input-element[type=datetime-local]::after,.mat-input-element[type=datetime]::after,.mat-input-element[type=month]::after,.mat-input-element[type=time]::after,.mat-input-element[type=week]::after{content:' ';white-space:pre;width:1px}.mat-input-element::-webkit-calendar-picker-indicator,.mat-input-element::-webkit-clear-button,.mat-input-element::-webkit-inner-spin-button{font-size:.75em}.mat-input-element::placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color .4s .133s cubic-bezier(.25,.8,.25,1)}.mat-input-element::placeholder:-ms-input-placeholder{-ms-user-select:text}.mat-input-element::-moz-placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color .4s .133s cubic-bezier(.25,.8,.25,1)}.mat-input-element::-moz-placeholder:-ms-input-placeholder{-ms-user-select:text}.mat-input-element::-webkit-input-placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color .4s .133s cubic-bezier(.25,.8,.25,1)}.mat-input-element::-webkit-input-placeholder:-ms-input-placeholder{-ms-user-select:text}.mat-input-element:-ms-input-placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color .4s .133s cubic-bezier(.25,.8,.25,1)}.mat-input-element:-ms-input-placeholder:-ms-input-placeholder{-ms-user-select:text}.mat-form-field-hide-placeholder .mat-input-element::placeholder{color:transparent!important;-webkit-text-fill-color:transparent;transition:none}.mat-form-field-hide-placeholder .mat-input-element::-moz-placeholder{color:transparent!important;-webkit-text-fill-color:transparent;transition:none}.mat-form-field-hide-placeholder .mat-input-element::-webkit-input-placeholder{color:transparent!important;-webkit-text-fill-color:transparent;transition:none}.mat-form-field-hide-placeholder .mat-input-element:-ms-input-placeholder{color:transparent!important;-webkit-text-fill-color:transparent;transition:none}textarea.mat-input-element{resize:vertical;overflow:auto}textarea.mat-input-element.cdk-textarea-autosize{resize:none}textarea.mat-input-element{padding:2px 0;margin:-2px 0}select.mat-input-element{-moz-appearance:none;-webkit-appearance:none;position:relative;background-color:transparent;display:inline-flex;box-sizing:border-box;padding-top:1em;top:-1em;margin-bottom:-1em}select.mat-input-element::-ms-expand{display:none}select.mat-input-element::-moz-focus-inner{border:0}select.mat-input-element:not(:disabled){cursor:pointer}select.mat-input-element::-ms-value{color:inherit;background:0 0}@media (-ms-high-contrast:active){.mat-focused select.mat-input-element::-ms-value{color:inherit}}.mat-form-field-type-mat-native-select .mat-form-field-infix::after{content:'';width:0;height:0;border-left:5px solid transparent;border-right:5px solid transparent;border-top:5px solid;position:absolute;top:50%;right:0;margin-top:-2.5px;pointer-events:none}[dir=rtl] .mat-form-field-type-mat-native-select .mat-form-field-infix::after{right:auto;left:0}.mat-form-field-type-mat-native-select .mat-input-element{padding-right:15px}[dir=rtl] .mat-form-field-type-mat-native-select .mat-input-element{padding-right:0;padding-left:15px}.mat-form-field-type-mat-native-select .mat-form-field-label-wrapper{max-width:calc(100% - 10px)}.mat-form-field-type-mat-native-select.mat-form-field-appearance-outline .mat-form-field-infix::after{margin-top:-5px}.mat-form-field-type-mat-native-select.mat-form-field-appearance-fill .mat-form-field-infix::after{margin-top:-10px}", ".mat-form-field-appearance-legacy .mat-form-field-label{transform:perspective(100px);-ms-transform:none}.mat-form-field-appearance-legacy .mat-form-field-prefix .mat-icon,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-icon{width:1em}.mat-form-field-appearance-legacy .mat-form-field-prefix .mat-icon-button,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-icon-button{font:inherit;vertical-align:baseline}.mat-form-field-appearance-legacy .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-icon-button .mat-icon{font-size:inherit}.mat-form-field-appearance-legacy .mat-form-field-underline{height:1px}@media (-ms-high-contrast:active){.mat-form-field-appearance-legacy .mat-form-field-underline{height:0;border-top:solid 1px}}.mat-form-field-appearance-legacy .mat-form-field-ripple{top:0;height:2px;overflow:hidden}@media (-ms-high-contrast:active){.mat-form-field-appearance-legacy .mat-form-field-ripple{height:0;border-top:solid 2px}}.mat-form-field-appearance-legacy.mat-form-field-disabled .mat-form-field-underline{background-position:0;background-color:transparent}@media (-ms-high-contrast:active){.mat-form-field-appearance-legacy.mat-form-field-disabled .mat-form-field-underline{border-top-style:dotted;border-top-width:2px}}.mat-form-field-appearance-legacy.mat-form-field-invalid:not(.mat-focused) .mat-form-field-ripple{height:1px}", ".mat-form-field-appearance-outline .mat-form-field-wrapper{margin:.25em 0}.mat-form-field-appearance-outline .mat-form-field-flex{padding:0 .75em 0 .75em;margin-top:-.25em;position:relative}.mat-form-field-appearance-outline .mat-form-field-prefix,.mat-form-field-appearance-outline .mat-form-field-suffix{top:.25em}.mat-form-field-appearance-outline .mat-form-field-outline{display:flex;position:absolute;top:.25em;left:0;right:0;bottom:0;pointer-events:none}.mat-form-field-appearance-outline .mat-form-field-outline-end,.mat-form-field-appearance-outline .mat-form-field-outline-start{border:1px solid currentColor;min-width:5px}.mat-form-field-appearance-outline .mat-form-field-outline-start{border-radius:5px 0 0 5px;border-right-style:none}[dir=rtl] .mat-form-field-appearance-outline .mat-form-field-outline-start{border-right-style:solid;border-left-style:none;border-radius:0 5px 5px 0}.mat-form-field-appearance-outline .mat-form-field-outline-end{border-radius:0 5px 5px 0;border-left-style:none;flex-grow:1}[dir=rtl] .mat-form-field-appearance-outline .mat-form-field-outline-end{border-left-style:solid;border-right-style:none;border-radius:5px 0 0 5px}.mat-form-field-appearance-outline .mat-form-field-outline-gap{border-radius:.000001px;border:1px solid currentColor;border-left-style:none;border-right-style:none}.mat-form-field-appearance-outline.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-outline-gap{border-top-color:transparent}.mat-form-field-appearance-outline .mat-form-field-outline-thick{opacity:0}.mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-end,.mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-gap,.mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-start{border-width:2px;transition:border-color .3s cubic-bezier(.25,.8,.25,1)}.mat-form-field-appearance-outline.mat-focused .mat-form-field-outline,.mat-form-field-appearance-outline.mat-form-field-invalid .mat-form-field-outline{opacity:0;transition:opacity .1s cubic-bezier(.25,.8,.25,1)}.mat-form-field-appearance-outline.mat-focused .mat-form-field-outline-thick,.mat-form-field-appearance-outline.mat-form-field-invalid .mat-form-field-outline-thick{opacity:1}.mat-form-field-appearance-outline:not(.mat-form-field-disabled) .mat-form-field-flex:hover .mat-form-field-outline{opacity:0;transition:opacity .6s cubic-bezier(.25,.8,.25,1)}.mat-form-field-appearance-outline:not(.mat-form-field-disabled) .mat-form-field-flex:hover .mat-form-field-outline-thick{opacity:1}.mat-form-field-appearance-outline .mat-form-field-subscript-wrapper{padding:0 1em}.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline-end,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline-gap,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline-start,.mat-form-field-appearance-outline._mat-animation-noopable:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-outline{transition:none}", ".mat-form-field-appearance-standard .mat-form-field-flex{padding-top:.75em}.mat-form-field-appearance-standard .mat-form-field-underline{height:1px}@media (-ms-high-contrast:active){.mat-form-field-appearance-standard .mat-form-field-underline{height:0;border-top:solid 1px}}.mat-form-field-appearance-standard .mat-form-field-ripple{bottom:0;height:2px}@media (-ms-high-contrast:active){.mat-form-field-appearance-standard .mat-form-field-ripple{height:0;border-top:2px}}.mat-form-field-appearance-standard.mat-form-field-disabled .mat-form-field-underline{background-position:0;background-color:transparent}@media (-ms-high-contrast:active){.mat-form-field-appearance-standard.mat-form-field-disabled .mat-form-field-underline{border-top-style:dotted;border-top-width:2px}}.mat-form-field-appearance-standard:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{opacity:1;transform:none;transition:opacity .6s cubic-bezier(.25,.8,.25,1)}.mat-form-field-appearance-standard._mat-animation-noopable:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{transition:none}"], data: { animation: [{ type: 7, name: "transitionMessages", definitions: [{ type: 0, name: "enter", styles: { type: 6, styles: { opacity: 1, transform: "translateY(0%)" }, offset: null }, options: void 0 }, { type: 1, expr: "void => enter", animation: [{ type: 6, styles: { opacity: 0, transform: "translateY(-100%)" }, offset: null }, { type: 4, styles: null, timings: "300ms cubic-bezier(0.55, 0, 0.55, 0.2)" }], options: null }], options: {} }] } }); function Mg(t) { return Zs(0, [(t()(), Rs(0, 0, null, null, 8, null, null, null, null, null, null, null)), (t()(), Rs(1, 0, null, null, 3, "div", [["class", "mat-form-field-outline"]], null, null, null, null, null)), (t()(), Rs(2, 0, null, null, 0, "div", [["class", "mat-form-field-outline-start"]], null, null, null, null, null)), (t()(), Rs(3, 0, null, null, 0, "div", [["class", "mat-form-field-outline-gap"]], null, null, null, null, null)), (t()(), Rs(4, 0, null, null, 0, "div", [["class", "mat-form-field-outline-end"]], null, null, null, null, null)), (t()(), Rs(5, 0, null, null, 3, "div", [["class", "mat-form-field-outline mat-form-field-outline-thick"]], null, null, null, null, null)), (t()(), Rs(6, 0, null, null, 0, "div", [["class", "mat-form-field-outline-start"]], null, null, null, null, null)), (t()(), Rs(7, 0, null, null, 0, "div", [["class", "mat-form-field-outline-gap"]], null, null, null, null, null)), (t()(), Rs(8, 0, null, null, 0, "div", [["class", "mat-form-field-outline-end"]], null, null, null, null, null))], null, null) } function Dg(t) { return Zs(0, [(t()(), Rs(0, 0, null, null, 1, "div", [["class", "mat-form-field-prefix"]], null, null, null, null, null)), Hs(null, 0)], null, null) } function Fg(t) { return Zs(0, [(t()(), Rs(0, 0, null, null, 3, null, null, null, null, null, null, null)), Hs(null, 2), (t()(), Rs(2, 0, null, null, 1, "span", [], null, null, null, null, null)), (t()(), Ws(3, null, ["", ""]))], null, (function (t, e) { t(e, 3, 0, e.component._control.placeholder) })) } function Lg(t) { return Zs(0, [Hs(null, 3), (t()(), As(0, null, null, 0))], null, null) } function Vg(t) { return Zs(0, [(t()(), Rs(0, 0, null, null, 1, "span", [["aria-hidden", "true"], ["class", "mat-placeholder-required mat-form-field-required-marker"]], null, null, null, null, null)), (t()(), Ws(-1, null, [" *"]))], null, null) } function zg(t) { return Zs(0, [(t()(), Rs(0, 0, [[4, 0], ["label", 1]], null, 8, "label", [["class", "mat-form-field-label"]], [[8, "id", 0], [1, "for", 0], [1, "aria-owns", 0], [2, "mat-empty", null], [2, "mat-form-field-empty", null], [2, "mat-accent", null], [2, "mat-warn", null]], [[null, "cdkObserveContent"]], (function (t, e, n) { var i = !0; return "cdkObserveContent" === e && (i = !1 !== t.component.updateOutlineGap() && i), i }), null, null)), Ki(1, 16384, null, 0, Kl, [], { ngSwitch: [0, "ngSwitch"] }, null), Ki(2, 1196032, null, 0, mf, [ff, Qe, Zr], { disabled: [0, "disabled"] }, { event: "cdkObserveContent" }), (t()(), As(16777216, null, null, 1, null, Fg)), Ki(4, 278528, null, 0, Yl, [En, Cn, Kl], { ngSwitchCase: [0, "ngSwitchCase"] }, null), (t()(), As(16777216, null, null, 1, null, Lg)), Ki(6, 278528, null, 0, Yl, [En, Cn, Kl], { ngSwitchCase: [0, "ngSwitchCase"] }, null), (t()(), As(16777216, null, null, 1, null, Vg)), Ki(8, 16384, null, 0, ql, [En, Cn], { ngIf: [0, "ngIf"] }, null)], (function (t, e) { var n = e.component; t(e, 1, 0, n._hasLabel()), t(e, 2, 0, "outline" != n.appearance), t(e, 4, 0, !1), t(e, 6, 0, !0), t(e, 8, 0, !n.hideRequiredMarker && n._control.required && !n._control.disabled) }), (function (t, e) { var n = e.component; t(e, 0, 0, n._labelId, n._control.id, n._control.id, n._control.empty && !n._shouldAlwaysFloat, n._control.empty && !n._shouldAlwaysFloat, "accent" == n.color, "warn" == n.color) })) } function jg(t) { return Zs(0, [(t()(), Rs(0, 0, null, null, 1, "div", [["class", "mat-form-field-suffix"]], null, null, null, null, null)), Hs(null, 4)], null, null) } function Ug(t) { return Zs(0, [(t()(), Rs(0, 0, [[1, 0], ["underline", 1]], null, 1, "div", [["class", "mat-form-field-underline"]], null, null, null, null, null)), (t()(), Rs(1, 0, null, null, 0, "span", [["class", "mat-form-field-ripple"]], [[2, "mat-accent", null], [2, "mat-warn", null]], null, null, null, null))], null, (function (t, e) { var n = e.component; t(e, 1, 0, "accent" == n.color, "warn" == n.color) })) } function Hg(t) { return Zs(0, [(t()(), Rs(0, 0, null, null, 1, "div", [], [[24, "@transitionMessages", 0]], null, null, null, null)), Hs(null, 5)], null, (function (t, e) { t(e, 0, 0, e.component._subscriptAnimationState) })) } function Bg(t) { return Zs(0, [(t()(), Rs(0, 0, null, null, 1, "div", [["class", "mat-hint"]], [[8, "id", 0]], null, null, null, null)), (t()(), Ws(1, null, ["", ""]))], null, (function (t, e) { var n = e.component; t(e, 0, 0, n._hintLabelId), t(e, 1, 0, n.hintLabel) })) } function $g(t) { return Zs(0, [(t()(), Rs(0, 0, null, null, 5, "div", [["class", "mat-form-field-hint-wrapper"]], [[24, "@transitionMessages", 0]], null, null, null, null)), (t()(), As(16777216, null, null, 1, null, Bg)), Ki(2, 16384, null, 0, ql, [En, Cn], { ngIf: [0, "ngIf"] }, null), Hs(null, 6), (t()(), Rs(4, 0, null, null, 0, "div", [["class", "mat-form-field-hint-spacer"]], null, null, null, null, null)), Hs(null, 7)], (function (t, e) { t(e, 2, 0, e.component.hintLabel) }), (function (t, e) { t(e, 0, 0, e.component._subscriptAnimationState) })) } function Wg(t) { return Zs(2, [Ls(671088640, 1, { underlineRef: 0 }), Ls(402653184, 2, { _connectionContainerRef: 0 }), Ls(671088640, 3, { _inputContainerRef: 0 }), Ls(671088640, 4, { _label: 0 }), (t()(), Rs(4, 0, null, null, 20, "div", [["class", "mat-form-field-wrapper"]], null, null, null, null, null)), (t()(), Rs(5, 0, [[2, 0], ["connectionContainer", 1]], null, 11, "div", [["class", "mat-form-field-flex"]], null, [[null, "click"]], (function (t, e, n) { var i = !0, r = t.component; return "click" === e && (i = !1 !== (r._control.onContainerClick && r._control.onContainerClick(n)) && i), i }), null, null)), (t()(), As(16777216, null, null, 1, null, Mg)), Ki(7, 16384, null, 0, ql, [En, Cn], { ngIf: [0, "ngIf"] }, null), (t()(), As(16777216, null, null, 1, null, Dg)), Ki(9, 16384, null, 0, ql, [En, Cn], { ngIf: [0, "ngIf"] }, null), (t()(), Rs(10, 0, [[3, 0], ["inputContainer", 1]], null, 4, "div", [["class", "mat-form-field-infix"]], null, null, null, null, null)), Hs(null, 1), (t()(), Rs(12, 0, null, null, 2, "span", [["class", "mat-form-field-label-wrapper"]], null, null, null, null, null)), (t()(), As(16777216, null, null, 1, null, zg)), Ki(14, 16384, null, 0, ql, [En, Cn], { ngIf: [0, "ngIf"] }, null), (t()(), As(16777216, null, null, 1, null, jg)), Ki(16, 16384, null, 0, ql, [En, Cn], { ngIf: [0, "ngIf"] }, null), (t()(), As(16777216, null, null, 1, null, Ug)), Ki(18, 16384, null, 0, ql, [En, Cn], { ngIf: [0, "ngIf"] }, null), (t()(), Rs(19, 0, null, null, 5, "div", [["class", "mat-form-field-subscript-wrapper"]], null, null, null, null, null)), Ki(20, 16384, null, 0, Kl, [], { ngSwitch: [0, "ngSwitch"] }, null), (t()(), As(16777216, null, null, 1, null, Hg)), Ki(22, 278528, null, 0, Yl, [En, Cn, Kl], { ngSwitchCase: [0, "ngSwitchCase"] }, null), (t()(), As(16777216, null, null, 1, null, $g)), Ki(24, 278528, null, 0, Yl, [En, Cn, Kl], { ngSwitchCase: [0, "ngSwitchCase"] }, null)], (function (t, e) { var n = e.component; t(e, 7, 0, "outline" == n.appearance), t(e, 9, 0, n._prefixChildren.length), t(e, 14, 0, n._hasFloatingLabel()), t(e, 16, 0, n._suffixChildren.length), t(e, 18, 0, "outline" != n.appearance), t(e, 20, 0, n._getDisplayedMessages()), t(e, 22, 0, "error"), t(e, 24, 0, "hint") }), null) } function qg(...t) { let e; return "function" == typeof t[t.length - 1] && (e = t.pop()), 1 === t.length && a(t[0]) && (t = t[0]), 0 === t.length ? ia : e ? qg(t).pipe(H(t => e(...t))) : new w(e => new Gg(e, t)) } class Gg extends U { constructor(t, e) { super(t), this.sources = e, this.completed = 0, this.haveValues = 0; const n = e.length; this.values = new Array(n); for (let i = 0; i < n; i++) { const t = j(this, e[i], null, i); t && this.add(t) } } notifyNext(t, e, n, i, r) { this.values[n] = e, r._hasValue || (r._hasValue = !0, this.haveValues++) } notifyComplete(t) { const { destination: e, haveValues: n, values: i } = this, r = i.length; t._hasValue ? (this.completed++, this.completed === r && (n === r && e.next(i), e.complete())) : e.complete() } } const Zg = new Tt("NgValueAccessor"); let Qg = (() => class { constructor(t, e) { this._renderer = t, this._elementRef = e, this.onChange = t => { }, this.onTouched = () => { } } writeValue(t) { this._renderer.setProperty(this._elementRef.nativeElement, "checked", t) } registerOnChange(t) { this.onChange = t } registerOnTouched(t) { this.onTouched = t } setDisabledState(t) { this._renderer.setProperty(this._elementRef.nativeElement, "disabled", t) } })(); const Kg = new Tt("CompositionEventMode"); let Yg = (() => class { constructor(t, e, n) { this._renderer = t, this._elementRef = e, this._compositionMode = n, this.onChange = t => { }, this.onTouched = () => { }, this._composing = !1, null == this._compositionMode && (this._compositionMode = !function () { const t = Ja() ? Ja().getUserAgent() : ""; return /android (\d+)/.test(t.toLowerCase()) }()) } writeValue(t) { this._renderer.setProperty(this._elementRef.nativeElement, "value", null == t ? "" : t) } registerOnChange(t) { this.onChange = t } registerOnTouched(t) { this.onTouched = t } setDisabledState(t) { this._renderer.setProperty(this._elementRef.nativeElement, "disabled", t) } _handleInput(t) { (!this._compositionMode || this._compositionMode && !this._composing) && this.onChange(t) } _compositionStart() { this._composing = !0 } _compositionEnd(t) { this._composing = !1, this._compositionMode && this.onChange(t) } })(); class Xg { get value() { return this.control ? this.control.value : null } get valid() { return this.control ? this.control.valid : null } get invalid() { return this.control ? this.control.invalid : null } get pending() { return this.control ? this.control.pending : null } get disabled() { return this.control ? this.control.disabled : null } get enabled() { return this.control ? this.control.enabled : null } get errors() { return this.control ? this.control.errors : null } get pristine() { return this.control ? this.control.pristine : null } get dirty() { return this.control ? this.control.dirty : null } get touched() { return this.control ? this.control.touched : null } get status() { return this.control ? this.control.status : null } get untouched() { return this.control ? this.control.untouched : null } get statusChanges() { return this.control ? this.control.statusChanges : null } get valueChanges() { return this.control ? this.control.valueChanges : null } get path() { return null } reset(t) { this.control && this.control.reset(t) } hasError(t, e) { return !!this.control && this.control.hasError(t, e) } getError(t, e) { return this.control ? this.control.getError(t, e) : null } } class Jg extends Xg { get formDirective() { return null } get path() { return null } } function t_() { throw new Error("unimplemented") } class e_ extends Xg { constructor() { super(...arguments), this._parent = null, this.name = null, this.valueAccessor = null, this._rawValidators = [], this._rawAsyncValidators = [] } get validator() { return t_() } get asyncValidator() { return t_() } } let n_ = (() => class extends class { constructor(t) { this._cd = t } get ngClassUntouched() { return !!this._cd.control && this._cd.control.untouched } get ngClassTouched() { return !!this._cd.control && this._cd.control.touched } get ngClassPristine() { return !!this._cd.control && this._cd.control.pristine } get ngClassDirty() { return !!this._cd.control && this._cd.control.dirty } get ngClassValid() { return !!this._cd.control && this._cd.control.valid } get ngClassInvalid() { return !!this._cd.control && this._cd.control.invalid } get ngClassPending() { return !!this._cd.control && this._cd.control.pending } }{ constructor(t) { super(t) } })(); function i_(t) { return null == t || 0 === t.length } const r_ = /^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+(\.[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/; class s_ { static min(t) { return e => { if (i_(e.value) || i_(t)) return null; const n = parseFloat(e.value); return !isNaN(n) && n < t ? { min: { min: t, actual: e.value } } : null } } static max(t) { return e => { if (i_(e.value) || i_(t)) return null; const n = parseFloat(e.value); return !isNaN(n) && n > t ? { max: { max: t, actual: e.value } } : null } } static required(t) { return i_(t.value) ? { required: !0 } : null } static requiredTrue(t) { return !0 === t.value ? null : { required: !0 } } static email(t) { return i_(t.value) || r_.test(t.value) ? null : { email: !0 } } static minLength(t) { return e => { if (i_(e.value)) return null; const n = e.value ? e.value.length : 0; return n < t ? { minlength: { requiredLength: t, actualLength: n } } : null } } static maxLength(t) { return e => { const n = e.value ? e.value.length : 0; return n > t ? { maxlength: { requiredLength: t, actualLength: n } } : null } } static pattern(t) { if (!t) return s_.nullValidator; let e, n; return "string" == typeof t ? (n = "", "^" !== t.charAt(0) && (n += "^"), n += t, "$" !== t.charAt(t.length - 1) && (n += "$"), e = new RegExp(n)) : (n = t.toString(), e = t), t => { if (i_(t.value)) return null; const i = t.value; return e.test(i) ? null : { pattern: { requiredPattern: n, actualValue: i } } } } static nullValidator(t) { return null } static compose(t) { if (!t) return null; const e = t.filter(o_); return 0 == e.length ? null : function (t) { return a_(function (t, e) { return e.map(e => e(t)) }(t, e)) } } static composeAsync(t) { if (!t) return null; const e = t.filter(o_); return 0 == e.length ? null : function (t) { return qg(function (t, e) { return e.map(e => e(t)) }(t, e).map(l_)).pipe(H(a_)) } } } function o_(t) { return null != t } function l_(t) { const e = Fe(t) ? q(t) : t; if (!Le(e)) throw new Error("Expected validator to return Promise or Observable."); return e } function a_(t) { const e = t.reduce((t, e) => null != e ? Object.assign({}, t, e) : t, {}); return 0 === Object.keys(e).length ? null : e } function c_(t) { return t.validate ? e => t.validate(e) : t } function u_(t) { return t.validate ? e => t.validate(e) : t } let h_ = (() => class { constructor(t, e) { this._renderer = t, this._elementRef = e, this.onChange = t => { }, this.onTouched = () => { } } writeValue(t) { this._renderer.setProperty(this._elementRef.nativeElement, "value", null == t ? "" : t) } registerOnChange(t) { this.onChange = e => { t("" == e ? null : parseFloat(e)) } } registerOnTouched(t) { this.onTouched = t } setDisabledState(t) { this._renderer.setProperty(this._elementRef.nativeElement, "disabled", t) } })(), d_ = (() => class { constructor() { this._accessors = [] } add(t, e) { this._accessors.push([t, e]) } remove(t) { for (let e = this._accessors.length - 1; e >= 0; --e)if (this._accessors[e][1] === t) return void this._accessors.splice(e, 1) } select(t) { this._accessors.forEach(e => { this._isSameGroup(e, t) && e[1] !== t && e[1].fireUncheck(t.value) }) } _isSameGroup(t, e) { return !!t[0].control && t[0]._parent === e._control._parent && t[1].name === e.name } })(), p_ = (() => class { constructor(t, e, n, i) { this._renderer = t, this._elementRef = e, this._registry = n, this._injector = i, this.onChange = () => { }, this.onTouched = () => { } } ngOnInit() { this._control = this._injector.get(e_), this._checkName(), this._registry.add(this._control, this) } ngOnDestroy() { this._registry.remove(this) } writeValue(t) { this._state = t === this.value, this._renderer.setProperty(this._elementRef.nativeElement, "checked", this._state) } registerOnChange(t) { this._fn = t, this.onChange = () => { t(this.value), this._registry.select(this) } } fireUncheck(t) { this.writeValue(t) } registerOnTouched(t) { this.onTouched = t } setDisabledState(t) { this._renderer.setProperty(this._elementRef.nativeElement, "disabled", t) } _checkName() { this.name && this.formControlName && this.name !== this.formControlName && this._throwNameError(), !this.name && this.formControlName && (this.name = this.formControlName) } _throwNameError() { throw new Error('\n      If you define both a name and a formControlName attribute on your radio button, their values\n      must match. Ex: <input type="radio" formControlName="food" name="food">\n    ') } })(), f_ = (() => class { constructor(t, e) { this._renderer = t, this._elementRef = e, this.onChange = t => { }, this.onTouched = () => { } } writeValue(t) { this._renderer.setProperty(this._elementRef.nativeElement, "value", parseFloat(t)) } registerOnChange(t) { this.onChange = e => { t("" == e ? null : parseFloat(e)) } } registerOnTouched(t) { this.onTouched = t } setDisabledState(t) { this._renderer.setProperty(this._elementRef.nativeElement, "disabled", t) } })(); const m_ = '\n    <div [formGroup]="myGroup">\n      <input formControlName="firstName">\n    </div>\n\n    In your class:\n\n    this.myGroup = new FormGroup({\n       firstName: new FormControl()\n    });', g_ = '\n    <div [formGroup]="myGroup">\n       <div formGroupName="person">\n          <input formControlName="firstName">\n       </div>\n    </div>\n\n    In your class:\n\n    this.myGroup = new FormGroup({\n       person: new FormGroup({ firstName: new FormControl() })\n    });', __ = '\n    <form>\n       <div ngModelGroup="person">\n          <input [(ngModel)]="person.name" name="firstName">\n       </div>\n    </form>'; class y_ { static controlParentException() { throw new Error("formControlName must be used with a parent formGroup directive.  You'll want to add a formGroup\n       directive and pass it an existing FormGroup instance (you can create one in your class).\n\n      Example:\n\n      " + m_) } static ngModelGroupException() { throw new Error(`formControlName cannot be used with an ngModelGroup parent. It is only compatible with parents\n       that also have a "form" prefix: formGroupName, formArrayName, or formGroup.\n\n       Option 1:  Update the parent to be formGroupName (reactive form strategy)\n\n        ${g_}\n\n        Option 2: Use ngModel instead of formControlName (template-driven strategy)\n\n        ${__}`) } static missingFormException() { throw new Error("formGroup expects a FormGroup instance. Please pass one in.\n\n       Example:\n\n       " + m_) } static groupParentException() { throw new Error("formGroupName must be used with a parent formGroup directive.  You'll want to add a formGroup\n      directive and pass it an existing FormGroup instance (you can create one in your class).\n\n      Example:\n\n      " + g_) } static arrayParentException() { throw new Error('formArrayName must be used with a parent formGroup directive.  You\'ll want to add a formGroup\n       directive and pass it an existing FormGroup instance (you can create one in your class).\n\n        Example:\n\n        \n    <div [formGroup]="myGroup">\n      <div formArrayName="cities">\n        <div *ngFor="let city of cityArray.controls; index as i">\n          <input [formControlName]="i">\n        </div>\n      </div>\n    </div>\n\n    In your class:\n\n    this.cityArray = new FormArray([new FormControl(\'SF\')]);\n    this.myGroup = new FormGroup({\n      cities: this.cityArray\n    });') } static disabledAttrWarning() { console.warn("\n      It looks like you're using the disabled attribute with a reactive form directive. If you set disabled to true\n      when you set up this control in your component class, the disabled attribute will actually be set in the DOM for\n      you. We recommend using this approach to avoid 'changed after checked' errors.\n       \n      Example: \n      form = new FormGroup({\n        first: new FormControl({value: 'Nancy', disabled: true}, Validators.required),\n        last: new FormControl('Drew', Validators.required)\n      });\n    ") } static ngModelWarning(t) { console.warn(`\n    It looks like you're using ngModel on the same form field as ${t}. \n    Support for using the ngModel input property and ngModelChange event with \n    reactive form directives has been deprecated in Angular v6 and will be removed \n    in Angular v7.\n    \n    For more information on this, see our API docs here:\n    https://angular.io/api/forms/${"formControl" === t ? "FormControlDirective" : "FormControlName"}#use-with-ngmodel\n    `) } } function v_(t, e) { return [...e.path, t] } function b_(t, e) { t || E_(e, "Cannot find control with"), e.valueAccessor || E_(e, "No value accessor for form control with"), t.validator = s_.compose([t.validator, e.validator]), t.asyncValidator = s_.composeAsync([t.asyncValidator, e.asyncValidator]), e.valueAccessor.writeValue(t.value), function (t, e) { e.valueAccessor.registerOnChange(n => { t._pendingValue = n, t._pendingChange = !0, t._pendingDirty = !0, "change" === t.updateOn && w_(t, e) }) }(t, e), function (t, e) { t.registerOnChange((t, n) => { e.valueAccessor.writeValue(t), n && e.viewToModelUpdate(t) }) }(t, e), function (t, e) { e.valueAccessor.registerOnTouched(() => { t._pendingTouched = !0, "blur" === t.updateOn && t._pendingChange && w_(t, e), "submit" !== t.updateOn && t.markAsTouched() }) }(t, e), e.valueAccessor.setDisabledState && t.registerOnDisabledChange(t => { e.valueAccessor.setDisabledState(t) }), e._rawValidators.forEach(e => { e.registerOnValidatorChange && e.registerOnValidatorChange(() => t.updateValueAndValidity()) }), e._rawAsyncValidators.forEach(e => { e.registerOnValidatorChange && e.registerOnValidatorChange(() => t.updateValueAndValidity()) }) } function w_(t, e) { t._pendingDirty && t.markAsDirty(), t.setValue(t._pendingValue, { emitModelToViewChange: !1 }), e.viewToModelUpdate(t._pendingValue), t._pendingChange = !1 } function C_(t, e) { null == t && E_(e, "Cannot find control with"), t.validator = s_.compose([t.validator, e.validator]), t.asyncValidator = s_.composeAsync([t.asyncValidator, e.asyncValidator]) } function S_(t) { return E_(t, "There is no FormControl instance attached to form control element with") } function E_(t, e) { let n; throw n = t.path.length > 1 ? `path: '${t.path.join(" -> ")}'` : t.path[0] ? `name: '${t.path}'` : "unspecified name attribute", new Error(`${e} ${n}`) } function x_(t) { return null != t ? s_.compose(t.map(c_)) : null } function T_(t) { return null != t ? s_.composeAsync(t.map(u_)) : null } function k_(t, e) { if (!t.hasOwnProperty("model")) return !1; const n = t.model; return !!n.isFirstChange() || !Ae(e, n.currentValue) } const P_ = [Qg, f_, h_, (() => class { constructor(t, e) { this._renderer = t, this._elementRef = e, this._optionMap = new Map, this._idCounter = 0, this.onChange = t => { }, this.onTouched = () => { }, this._compareWith = Ae } set compareWith(t) { if ("function" != typeof t) throw new Error("compareWith must be a function, but received " + JSON.stringify(t)); this._compareWith = t } writeValue(t) { this.value = t; const e = this._getOptionId(t); null == e && this._renderer.setProperty(this._elementRef.nativeElement, "selectedIndex", -1); const n = function (t, e) { return null == t ? "" + e : (e && "object" == typeof e && (e = "Object"), `${t}: ${e}`.slice(0, 50)) }(e, t); this._renderer.setProperty(this._elementRef.nativeElement, "value", n) } registerOnChange(t) { this.onChange = e => { this.value = this._getOptionValue(e), t(this.value) } } registerOnTouched(t) { this.onTouched = t } setDisabledState(t) { this._renderer.setProperty(this._elementRef.nativeElement, "disabled", t) } _registerOption() { return (this._idCounter++).toString() } _getOptionId(t) { for (const e of Array.from(this._optionMap.keys())) if (this._compareWith(this._optionMap.get(e), t)) return e; return null } _getOptionValue(t) { const e = function (t) { return t.split(":")[0] }(t); return this._optionMap.has(e) ? this._optionMap.get(e) : t } })(), (() => class { constructor(t, e) { this._renderer = t, this._elementRef = e, this._optionMap = new Map, this._idCounter = 0, this.onChange = t => { }, this.onTouched = () => { }, this._compareWith = Ae } set compareWith(t) { if ("function" != typeof t) throw new Error("compareWith must be a function, but received " + JSON.stringify(t)); this._compareWith = t } writeValue(t) { let e; if (this.value = t, Array.isArray(t)) { const n = t.map(t => this._getOptionId(t)); e = (t, e) => { t._setSelected(n.indexOf(e.toString()) > -1) } } else e = (t, e) => { t._setSelected(!1) }; this._optionMap.forEach(e) } registerOnChange(t) { this.onChange = e => { const n = []; if (e.hasOwnProperty("selectedOptions")) { const t = e.selectedOptions; for (let e = 0; e < t.length; e++) { const i = t.item(e), r = this._getOptionValue(i.value); n.push(r) } } else { const t = e.options; for (let e = 0; e < t.length; e++) { const i = t.item(e); if (i.selected) { const t = this._getOptionValue(i.value); n.push(t) } } } this.value = n, t(n) } } registerOnTouched(t) { this.onTouched = t } setDisabledState(t) { this._renderer.setProperty(this._elementRef.nativeElement, "disabled", t) } _registerOption(t) { const e = (this._idCounter++).toString(); return this._optionMap.set(e, t), e } _getOptionId(t) { for (const e of Array.from(this._optionMap.keys())) if (this._compareWith(this._optionMap.get(e)._value, t)) return e; return null } _getOptionValue(t) { const e = function (t) { return t.split(":")[0] }(t); return this._optionMap.has(e) ? this._optionMap.get(e)._value : t } })(), p_]; function O_(t, e) { t._syncPendingControls(), e.forEach(t => { const e = t.control; "submit" === e.updateOn && e._pendingChange && (t.viewToModelUpdate(e._pendingValue), e._pendingChange = !1) }) } function I_(t, e) { if (!e) return null; Array.isArray(e) || E_(t, "Value accessor was not provided as an array for form control with"); let n = void 0, i = void 0, r = void 0; return e.forEach(e => { var s; e.constructor === Yg ? n = e : (s = e, P_.some(t => s.constructor === t) ? (i && E_(t, "More than one built-in value accessor matches form control with"), i = e) : (r && E_(t, "More than one custom value accessor matches form control with"), r = e)) }), r || i || n || (E_(t, "No valid value accessor for form control with"), null) } function A_(t, e) { const n = t.indexOf(e); n > -1 && t.splice(n, 1) } function R_(t) { const e = M_(t) ? t.validators : t; return Array.isArray(e) ? x_(e) : e || null } function N_(t, e) { const n = M_(e) ? e.asyncValidators : t; return Array.isArray(n) ? T_(n) : n || null } function M_(t) { return null != t && !Array.isArray(t) && "object" == typeof t } class D_ { constructor(t, e) { this.validator = t, this.asyncValidator = e, this._onCollectionChange = () => { }, this.pristine = !0, this.touched = !1, this._onDisabledChange = [] } get parent() { return this._parent } get valid() { return "VALID" === this.status } get invalid() { return "INVALID" === this.status } get pending() { return "PENDING" == this.status } get disabled() { return "DISABLED" === this.status } get enabled() { return "DISABLED" !== this.status } get dirty() { return !this.pristine } get untouched() { return !this.touched } get updateOn() { return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : "change" } setValidators(t) { this.validator = R_(t) } setAsyncValidators(t) { this.asyncValidator = N_(t) } clearValidators() { this.validator = null } clearAsyncValidators() { this.asyncValidator = null } markAsTouched(t = {}) { this.touched = !0, this._parent && !t.onlySelf && this._parent.markAsTouched(t) } markAllAsTouched() { this.markAsTouched({ onlySelf: !0 }), this._forEachChild(t => t.markAllAsTouched()) } markAsUntouched(t = {}) { this.touched = !1, this._pendingTouched = !1, this._forEachChild(t => { t.markAsUntouched({ onlySelf: !0 }) }), this._parent && !t.onlySelf && this._parent._updateTouched(t) } markAsDirty(t = {}) { this.pristine = !1, this._parent && !t.onlySelf && this._parent.markAsDirty(t) } markAsPristine(t = {}) { this.pristine = !0, this._pendingDirty = !1, this._forEachChild(t => { t.markAsPristine({ onlySelf: !0 }) }), this._parent && !t.onlySelf && this._parent._updatePristine(t) } markAsPending(t = {}) { this.status = "PENDING", !1 !== t.emitEvent && this.statusChanges.emit(this.status), this._parent && !t.onlySelf && this._parent.markAsPending(t) } disable(t = {}) { const e = this._parentMarkedDirty(t.onlySelf); this.status = "DISABLED", this.errors = null, this._forEachChild(e => { e.disable(Object.assign({}, t, { onlySelf: !0 })) }), this._updateValue(), !1 !== t.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._updateAncestors(Object.assign({}, t, { skipPristineCheck: e })), this._onDisabledChange.forEach(t => t(!0)) } enable(t = {}) { const e = this._parentMarkedDirty(t.onlySelf); this.status = "VALID", this._forEachChild(e => { e.enable(Object.assign({}, t, { onlySelf: !0 })) }), this.updateValueAndValidity({ onlySelf: !0, emitEvent: t.emitEvent }), this._updateAncestors(Object.assign({}, t, { skipPristineCheck: e })), this._onDisabledChange.forEach(t => t(!1)) } _updateAncestors(t) { this._parent && !t.onlySelf && (this._parent.updateValueAndValidity(t), t.skipPristineCheck || this._parent._updatePristine(), this._parent._updateTouched()) } setParent(t) { this._parent = t } updateValueAndValidity(t = {}) { this._setInitialStatus(), this._updateValue(), this.enabled && (this._cancelExistingSubscription(), this.errors = this._runValidator(), this.status = this._calculateStatus(), "VALID" !== this.status && "PENDING" !== this.status || this._runAsyncValidator(t.emitEvent)), !1 !== t.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._parent && !t.onlySelf && this._parent.updateValueAndValidity(t) } _updateTreeValidity(t = { emitEvent: !0 }) { this._forEachChild(e => e._updateTreeValidity(t)), this.updateValueAndValidity({ onlySelf: !0, emitEvent: t.emitEvent }) } _setInitialStatus() { this.status = this._allControlsDisabled() ? "DISABLED" : "VALID" } _runValidator() { return this.validator ? this.validator(this) : null } _runAsyncValidator(t) { if (this.asyncValidator) { this.status = "PENDING"; const e = l_(this.asyncValidator(this)); this._asyncValidationSubscription = e.subscribe(e => this.setErrors(e, { emitEvent: t })) } } _cancelExistingSubscription() { this._asyncValidationSubscription && this._asyncValidationSubscription.unsubscribe() } setErrors(t, e = {}) { this.errors = t, this._updateControlsErrors(!1 !== e.emitEvent) } get(t) { return function (t, e, n) { return null == e ? null : (e instanceof Array || (e = e.split(".")), e instanceof Array && 0 === e.length ? null : e.reduce((t, e) => t instanceof L_ ? t.controls.hasOwnProperty(e) ? t.controls[e] : null : t instanceof V_ && t.at(e) || null, t)) }(this, t) } getError(t, e) { const n = e ? this.get(e) : this; return n && n.errors ? n.errors[t] : null } hasError(t, e) { return !!this.getError(t, e) } get root() { let t = this; for (; t._parent;)t = t._parent; return t } _updateControlsErrors(t) { this.status = this._calculateStatus(), t && this.statusChanges.emit(this.status), this._parent && this._parent._updateControlsErrors(t) } _initObservables() { this.valueChanges = new vr, this.statusChanges = new vr } _calculateStatus() { return this._allControlsDisabled() ? "DISABLED" : this.errors ? "INVALID" : this._anyControlsHaveStatus("PENDING") ? "PENDING" : this._anyControlsHaveStatus("INVALID") ? "INVALID" : "VALID" } _anyControlsHaveStatus(t) { return this._anyControls(e => e.status === t) } _anyControlsDirty() { return this._anyControls(t => t.dirty) } _anyControlsTouched() { return this._anyControls(t => t.touched) } _updatePristine(t = {}) { this.pristine = !this._anyControlsDirty(), this._parent && !t.onlySelf && this._parent._updatePristine(t) } _updateTouched(t = {}) { this.touched = this._anyControlsTouched(), this._parent && !t.onlySelf && this._parent._updateTouched(t) } _isBoxedValue(t) { return "object" == typeof t && null !== t && 2 === Object.keys(t).length && "value" in t && "disabled" in t } _registerOnCollectionChange(t) { this._onCollectionChange = t } _setUpdateStrategy(t) { M_(t) && null != t.updateOn && (this._updateOn = t.updateOn) } _parentMarkedDirty(t) { return !t && this._parent && this._parent.dirty && !this._parent._anyControlsDirty() } } class F_ extends D_ { constructor(t = null, e, n) { super(R_(e), N_(n, e)), this._onChange = [], this._applyFormState(t), this._setUpdateStrategy(e), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !1 }), this._initObservables() } setValue(t, e = {}) { this.value = this._pendingValue = t, this._onChange.length && !1 !== e.emitModelToViewChange && this._onChange.forEach(t => t(this.value, !1 !== e.emitViewToModelChange)), this.updateValueAndValidity(e) } patchValue(t, e = {}) { this.setValue(t, e) } reset(t = null, e = {}) { this._applyFormState(t), this.markAsPristine(e), this.markAsUntouched(e), this.setValue(this.value, e), this._pendingChange = !1 } _updateValue() { } _anyControls(t) { return !1 } _allControlsDisabled() { return this.disabled } registerOnChange(t) { this._onChange.push(t) } _clearChangeFns() { this._onChange = [], this._onDisabledChange = [], this._onCollectionChange = () => { } } registerOnDisabledChange(t) { this._onDisabledChange.push(t) } _forEachChild(t) { } _syncPendingControls() { return !("submit" !== this.updateOn || (this._pendingDirty && this.markAsDirty(), this._pendingTouched && this.markAsTouched(), !this._pendingChange) || (this.setValue(this._pendingValue, { onlySelf: !0, emitModelToViewChange: !1 }), 0)) } _applyFormState(t) { this._isBoxedValue(t) ? (this.value = this._pendingValue = t.value, t.disabled ? this.disable({ onlySelf: !0, emitEvent: !1 }) : this.enable({ onlySelf: !0, emitEvent: !1 })) : this.value = this._pendingValue = t } } class L_ extends D_ { constructor(t, e, n) { super(R_(e), N_(n, e)), this.controls = t, this._initObservables(), this._setUpdateStrategy(e), this._setUpControls(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !1 }) } registerControl(t, e) { return this.controls[t] ? this.controls[t] : (this.controls[t] = e, e.setParent(this), e._registerOnCollectionChange(this._onCollectionChange), e) } addControl(t, e) { this.registerControl(t, e), this.updateValueAndValidity(), this._onCollectionChange() } removeControl(t) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => { }), delete this.controls[t], this.updateValueAndValidity(), this._onCollectionChange() } setControl(t, e) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => { }), delete this.controls[t], e && this.registerControl(t, e), this.updateValueAndValidity(), this._onCollectionChange() } contains(t) { return this.controls.hasOwnProperty(t) && this.controls[t].enabled } setValue(t, e = {}) { this._checkAllValuesPresent(t), Object.keys(t).forEach(n => { this._throwIfControlMissing(n), this.controls[n].setValue(t[n], { onlySelf: !0, emitEvent: e.emitEvent }) }), this.updateValueAndValidity(e) } patchValue(t, e = {}) { Object.keys(t).forEach(n => { this.controls[n] && this.controls[n].patchValue(t[n], { onlySelf: !0, emitEvent: e.emitEvent }) }), this.updateValueAndValidity(e) } reset(t = {}, e = {}) { this._forEachChild((n, i) => { n.reset(t[i], { onlySelf: !0, emitEvent: e.emitEvent }) }), this._updatePristine(e), this._updateTouched(e), this.updateValueAndValidity(e) } getRawValue() { return this._reduceChildren({}, (t, e, n) => (t[n] = e instanceof F_ ? e.value : e.getRawValue(), t)) } _syncPendingControls() { let t = this._reduceChildren(!1, (t, e) => !!e._syncPendingControls() || t); return t && this.updateValueAndValidity({ onlySelf: !0 }), t } _throwIfControlMissing(t) { if (!Object.keys(this.controls).length) throw new Error("\n        There are no form controls registered with this group yet.  If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      "); if (!this.controls[t]) throw new Error(`Cannot find form control with name: ${t}.`) } _forEachChild(t) { Object.keys(this.controls).forEach(e => t(this.controls[e], e)) } _setUpControls() { this._forEachChild(t => { t.setParent(this), t._registerOnCollectionChange(this._onCollectionChange) }) } _updateValue() { this.value = this._reduceValue() } _anyControls(t) { let e = !1; return this._forEachChild((n, i) => { e = e || this.contains(i) && t(n) }), e } _reduceValue() { return this._reduceChildren({}, (t, e, n) => ((e.enabled || this.disabled) && (t[n] = e.value), t)) } _reduceChildren(t, e) { let n = t; return this._forEachChild((t, i) => { n = e(n, t, i) }), n } _allControlsDisabled() { for (const t of Object.keys(this.controls)) if (this.controls[t].enabled) return !1; return Object.keys(this.controls).length > 0 || this.disabled } _checkAllValuesPresent(t) { this._forEachChild((e, n) => { if (void 0 === t[n]) throw new Error(`Must supply a value for form control with name: '${n}'.`) }) } } class V_ extends D_ { constructor(t, e, n) { super(R_(e), N_(n, e)), this.controls = t, this._initObservables(), this._setUpdateStrategy(e), this._setUpControls(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !1 }) } at(t) { return this.controls[t] } push(t) { this.controls.push(t), this._registerControl(t), this.updateValueAndValidity(), this._onCollectionChange() } insert(t, e) { this.controls.splice(t, 0, e), this._registerControl(e), this.updateValueAndValidity() } removeAt(t) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => { }), this.controls.splice(t, 1), this.updateValueAndValidity() } setControl(t, e) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => { }), this.controls.splice(t, 1), e && (this.controls.splice(t, 0, e), this._registerControl(e)), this.updateValueAndValidity(), this._onCollectionChange() } get length() { return this.controls.length } setValue(t, e = {}) { this._checkAllValuesPresent(t), t.forEach((t, n) => { this._throwIfControlMissing(n), this.at(n).setValue(t, { onlySelf: !0, emitEvent: e.emitEvent }) }), this.updateValueAndValidity(e) } patchValue(t, e = {}) { t.forEach((t, n) => { this.at(n) && this.at(n).patchValue(t, { onlySelf: !0, emitEvent: e.emitEvent }) }), this.updateValueAndValidity(e) } reset(t = [], e = {}) { this._forEachChild((n, i) => { n.reset(t[i], { onlySelf: !0, emitEvent: e.emitEvent }) }), this._updatePristine(e), this._updateTouched(e), this.updateValueAndValidity(e) } getRawValue() { return this.controls.map(t => t instanceof F_ ? t.value : t.getRawValue()) } clear() { this.controls.length < 1 || (this._forEachChild(t => t._registerOnCollectionChange(() => { })), this.controls.splice(0), this.updateValueAndValidity()) } _syncPendingControls() { let t = this.controls.reduce((t, e) => !!e._syncPendingControls() || t, !1); return t && this.updateValueAndValidity({ onlySelf: !0 }), t } _throwIfControlMissing(t) { if (!this.controls.length) throw new Error("\n        There are no form controls registered with this array yet.  If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      "); if (!this.at(t)) throw new Error("Cannot find form control at index " + t) } _forEachChild(t) { this.controls.forEach((e, n) => { t(e, n) }) } _updateValue() { this.value = this.controls.filter(t => t.enabled || this.disabled).map(t => t.value) } _anyControls(t) { return this.controls.some(e => e.enabled && t(e)) } _setUpControls() { this._forEachChild(t => this._registerControl(t)) } _checkAllValuesPresent(t) { this._forEachChild((e, n) => { if (void 0 === t[n]) throw new Error(`Must supply a value for form control at index: ${n}.`) }) } _allControlsDisabled() { for (const t of this.controls) if (t.enabled) return !1; return this.controls.length > 0 || this.disabled } _registerControl(t) { t.setParent(this), t._registerOnCollectionChange(this._onCollectionChange) } } const z_ = (() => Promise.resolve(null))(); let j_ = (() => class extends Jg { constructor(t, e) { super(), this.submitted = !1, this._directives = [], this.ngSubmit = new vr, this.form = new L_({}, x_(t), T_(e)) } ngAfterViewInit() { this._setUpdateStrategy() } get formDirective() { return this } get control() { return this.form } get path() { return [] } get controls() { return this.form.controls } addControl(t) { z_.then(() => { const e = this._findContainer(t.path); t.control = e.registerControl(t.name, t.control), b_(t.control, t), t.control.updateValueAndValidity({ emitEvent: !1 }), this._directives.push(t) }) } getControl(t) { return this.form.get(t.path) } removeControl(t) { z_.then(() => { const e = this._findContainer(t.path); e && e.removeControl(t.name), A_(this._directives, t) }) } addFormGroup(t) { z_.then(() => { const e = this._findContainer(t.path), n = new L_({}); C_(n, t), e.registerControl(t.name, n), n.updateValueAndValidity({ emitEvent: !1 }) }) } removeFormGroup(t) { z_.then(() => { const e = this._findContainer(t.path); e && e.removeControl(t.name) }) } getFormGroup(t) { return this.form.get(t.path) } updateModel(t, e) { z_.then(() => { this.form.get(t.path).setValue(e) }) } setValue(t) { this.control.setValue(t) } onSubmit(t) { return this.submitted = !0, O_(this.form, this._directives), this.ngSubmit.emit(t), !1 } onReset() { this.resetForm() } resetForm(t) { this.form.reset(t), this.submitted = !1 } _setUpdateStrategy() { this.options && null != this.options.updateOn && (this.form._updateOn = this.options.updateOn) } _findContainer(t) { return t.pop(), t.length ? this.form.get(t) : this.form } })(); class U_ { static modelParentException() { throw new Error(`\n      ngModel cannot be used to register form controls with a parent formGroup directive.  Try using\n      formGroup's partner directive "formControlName" instead.  Example:\n\n      ${m_}\n\n      Or, if you'd like to avoid registering this form control, indicate that it's standalone in ngModelOptions:\n\n      Example:\n\n      \n    <div [formGroup]="myGroup">\n       <input formControlName="firstName">\n       <input [(ngModel)]="showMoreControls" [ngModelOptions]="{standalone: true}">\n    </div>\n  `) } static formGroupNameException() { throw new Error(`\n      ngModel cannot be used to register form controls with a parent formGroupName or formArrayName directive.\n\n      Option 1: Use formControlName instead of ngModel (reactive strategy):\n\n      ${g_}\n\n      Option 2:  Update ngModel's parent be ngModelGroup (template-driven strategy):\n\n      ${__}`) } static missingNameException() { throw new Error('If ngModel is used within a form tag, either the name attribute must be set or the form\n      control must be defined as \'standalone\' in ngModelOptions.\n\n      Example 1: <input [(ngModel)]="person.firstName" name="first">\n      Example 2: <input [(ngModel)]="person.firstName" [ngModelOptions]="{standalone: true}">') } static modelGroupParentException() { throw new Error(`\n      ngModelGroup cannot be used with a parent formGroup directive.\n\n      Option 1: Use formGroupName instead of ngModelGroup (reactive strategy):\n\n      ${g_}\n\n      Option 2:  Use a regular form tag instead of the formGroup directive (template-driven strategy):\n\n      ${__}`) } static ngFormWarning() { console.warn("\n    It looks like you're using 'ngForm'.\n\n    Support for using the 'ngForm' element selector has been deprecated in Angular v6 and will be removed\n    in Angular v9.\n\n    Use 'ng-form' instead.\n\n    Before:\n    <ngForm #myForm=\"ngForm\">\n\n    After:\n    <ng-form #myForm=\"ngForm\">\n    ") } } const H_ = new Tt("NgFormSelectorWarning"); class B_ extends Jg { ngOnInit() { this._checkParentType(), this.formDirective.addFormGroup(this) } ngOnDestroy() { this.formDirective && this.formDirective.removeFormGroup(this) } get control() { return this.formDirective.getFormGroup(this) } get path() { return v_(this.name, this._parent) } get formDirective() { return this._parent ? this._parent.formDirective : null } get validator() { return x_(this._validators) } get asyncValidator() { return T_(this._asyncValidators) } _checkParentType() { } } let $_ = (() => { class t extends B_ { constructor(t, e, n) { super(), this._parent = t, this._validators = e, this._asyncValidators = n } _checkParentType() { this._parent instanceof t || this._parent instanceof j_ || U_.modelGroupParentException() } } return t })(); const W_ = (() => Promise.resolve(null))(); let q_ = (() => class extends e_ { constructor(t, e, n, i) { super(), this.control = new F_, this._registered = !1, this.update = new vr, this._parent = t, this._rawValidators = e || [], this._rawAsyncValidators = n || [], this.valueAccessor = I_(this, i) } ngOnChanges(t) { this._checkForErrors(), this._registered || this._setUpControl(), "isDisabled" in t && this._updateDisabled(t), k_(t, this.viewModel) && (this._updateValue(this.model), this.viewModel = this.model) } ngOnDestroy() { this.formDirective && this.formDirective.removeControl(this) } get path() { return this._parent ? v_(this.name, this._parent) : [this.name] } get formDirective() { return this._parent ? this._parent.formDirective : null } get validator() { return x_(this._rawValidators) } get asyncValidator() { return T_(this._rawAsyncValidators) } viewToModelUpdate(t) { this.viewModel = t, this.update.emit(t) } _setUpControl() { this._setUpdateStrategy(), this._isStandalone() ? this._setUpStandalone() : this.formDirective.addControl(this), this._registered = !0 } _setUpdateStrategy() { this.options && null != this.options.updateOn && (this.control._updateOn = this.options.updateOn) } _isStandalone() { return !this._parent || !(!this.options || !this.options.standalone) } _setUpStandalone() { b_(this.control, this), this.control.updateValueAndValidity({ emitEvent: !1 }) } _checkForErrors() { this._isStandalone() || this._checkParentType(), this._checkName() } _checkParentType() { !(this._parent instanceof $_) && this._parent instanceof B_ ? U_.formGroupNameException() : this._parent instanceof $_ || this._parent instanceof j_ || U_.modelParentException() } _checkName() { this.options && this.options.name && (this.name = this.options.name), this._isStandalone() || this.name || U_.missingNameException() } _updateValue(t) { W_.then(() => { this.control.setValue(t, { emitViewToModelChange: !1 }) }) } _updateDisabled(t) { const e = t.isDisabled.currentValue, n = "" === e || e && "false" !== e; W_.then(() => { n && !this.control.disabled ? this.control.disable() : !n && this.control.disabled && this.control.enable() }) } })(); const G_ = new Tt("NgModelWithFormControlWarning"); let Z_ = (() => { class t extends e_ { constructor(t, e, n, i) { super(), this._ngModelWarningConfig = i, this.update = new vr, this._ngModelWarningSent = !1, this._rawValidators = t || [], this._rawAsyncValidators = e || [], this.valueAccessor = I_(this, n) } set isDisabled(t) { y_.disabledAttrWarning() } ngOnChanges(e) { var n, i; this._isControlChanged(e) && (b_(this.form, this), this.control.disabled && this.valueAccessor.setDisabledState && this.valueAccessor.setDisabledState(!0), this.form.updateValueAndValidity({ emitEvent: !1 })), k_(e, this.viewModel) && ("formControl", n = t, this, i = this._ngModelWarningConfig, Yt() && "never" !== i && ((null !== i && "once" !== i || n._ngModelWarningSentOnce) && ("always" !== i || this._ngModelWarningSent) || (y_.ngModelWarning("formControl"), n._ngModelWarningSentOnce = !0, this._ngModelWarningSent = !0)), this.form.setValue(this.model), this.viewModel = this.model) } get path() { return [] } get validator() { return x_(this._rawValidators) } get asyncValidator() { return T_(this._rawAsyncValidators) } get control() { return this.form } viewToModelUpdate(t) { this.viewModel = t, this.update.emit(t) } _isControlChanged(t) { return t.hasOwnProperty("form") } } return t._ngModelWarningSentOnce = !1, t })(), Q_ = (() => class extends Jg { constructor(t, e) { super(), this._validators = t, this._asyncValidators = e, this.submitted = !1, this.directives = [], this.form = null, this.ngSubmit = new vr } ngOnChanges(t) { this._checkFormPresent(), t.hasOwnProperty("form") && (this._updateValidators(), this._updateDomValue(), this._updateRegistrations()) } get formDirective() { return this } get control() { return this.form } get path() { return [] } addControl(t) { const e = this.form.get(t.path); return b_(e, t), e.updateValueAndValidity({ emitEvent: !1 }), this.directives.push(t), e } getControl(t) { return this.form.get(t.path) } removeControl(t) { A_(this.directives, t) } addFormGroup(t) { const e = this.form.get(t.path); C_(e, t), e.updateValueAndValidity({ emitEvent: !1 }) } removeFormGroup(t) { } getFormGroup(t) { return this.form.get(t.path) } addFormArray(t) { const e = this.form.get(t.path); C_(e, t), e.updateValueAndValidity({ emitEvent: !1 }) } removeFormArray(t) { } getFormArray(t) { return this.form.get(t.path) } updateModel(t, e) { this.form.get(t.path).setValue(e) } onSubmit(t) { return this.submitted = !0, O_(this.form, this.directives), this.ngSubmit.emit(t), !1 } onReset() { this.resetForm() } resetForm(t) { this.form.reset(t), this.submitted = !1 } _updateDomValue() { this.directives.forEach(t => { const e = this.form.get(t.path); t.control !== e && (function (t, e) { e.valueAccessor.registerOnChange(() => S_(e)), e.valueAccessor.registerOnTouched(() => S_(e)), e._rawValidators.forEach(t => { t.registerOnValidatorChange && t.registerOnValidatorChange(null) }), e._rawAsyncValidators.forEach(t => { t.registerOnValidatorChange && t.registerOnValidatorChange(null) }), t && t._clearChangeFns() }(t.control, t), e && b_(e, t), t.control = e) }), this.form._updateTreeValidity({ emitEvent: !1 }) } _updateRegistrations() { this.form._registerOnCollectionChange(() => this._updateDomValue()), this._oldForm && this._oldForm._registerOnCollectionChange(() => { }), this._oldForm = this.form } _updateValidators() { const t = x_(this._validators); this.form.validator = s_.compose([this.form.validator, t]); const e = T_(this._asyncValidators); this.form.asyncValidator = s_.composeAsync([this.form.asyncValidator, e]) } _checkFormPresent() { this.form || y_.missingFormException() } })(), K_ = (() => class { })(), Y_ = (() => class { group(t, e = null) { const n = this._reduceControls(t); let i = null, r = null, s = void 0; return null != e && (function (t) { return void 0 !== t.asyncValidators || void 0 !== t.validators || void 0 !== t.updateOn }(e) ? (i = null != e.validators ? e.validators : null, r = null != e.asyncValidators ? e.asyncValidators : null, s = null != e.updateOn ? e.updateOn : void 0) : (i = null != e.validator ? e.validator : null, r = null != e.asyncValidator ? e.asyncValidator : null)), new L_(n, { asyncValidators: r, updateOn: s, validators: i }) } control(t, e, n) { return new F_(t, e, n) } array(t, e, n) { const i = t.map(t => this._createControl(t)); return new V_(i, e, n) } _reduceControls(t) { const e = {}; return Object.keys(t).forEach(n => { e[n] = this._createControl(t[n]) }), e } _createControl(t) { return t instanceof F_ || t instanceof L_ || t instanceof V_ ? t : Array.isArray(t) ? this.control(t[0], t.length > 1 ? t[1] : null, t.length > 2 ? t[2] : null) : this.control(t) } })(), X_ = (() => { class t { static withConfig(e) { return { ngModule: t, providers: [{ provide: H_, useValue: e.warnOnDeprecatedNgFormSelector }] } } } return t })(), J_ = (() => { class t { static withConfig(e) { return { ngModule: t, providers: [{ provide: G_, useValue: e.warnOnNgModelWithFormControl }] } } } return t })(); class ty { constructor(t) { this.durationSelector = t } call(t, e) { return e.subscribe(new ey(t, this.durationSelector)) } } class ey extends U { constructor(t, e) { super(t), this.durationSelector = e, this.hasValue = !1 } _next(t) { if (this.value = t, this.hasValue = !0, !this.throttled) { let n; try { const { durationSelector: e } = this; n = e(t) } catch (e) { return this.destination.error(e) } const i = j(this, n); !i || i.closed ? this.clearThrottle() : this.add(this.throttled = i) } } clearThrottle() { const { value: t, hasValue: e, throttled: n } = this; n && (this.remove(n), this.throttled = null, n.unsubscribe()), e && (this.value = null, this.hasValue = !1, this.destination.next(t)) } notifyNext(t, e, n, i) { this.clearThrottle() } notifyComplete() { this.clearThrottle() } } function ny(t) { return !a(t) && t - parseFloat(t) + 1 >= 0 } function iy(t) { const { index: e, period: n, subscriber: i } = t; if (i.next(e), !i.closed) { if (-1 === n) return i.complete(); t.index = e + 1, this.schedule(t, n) } } function ry(t, e = bp) { return n = () => function (t = 0, e, n) { let i = -1; return ny(e) ? i = Number(e) < 1 ? 1 : Number(e) : O(e) && (n = e), O(n) || (n = bp), new w(e => { const r = ny(t) ? t : +t - n.now(); return n.schedule(iy, r, { index: 0, period: i, subscriber: e }) }) }(t, e), function (t) { return t.lift(new ty(n)) }; var n } const sy = mp({ passive: !0 }); let oy = (() => { class t { constructor(t, e) { this._platform = t, this._ngZone = e, this._monitoredElements = new Map } monitor(t) { if (!this._platform.isBrowser) return ia; const e = op(t), n = this._monitoredElements.get(e); if (n) return n.subject.asObservable(); const i = new k, r = "cdk-text-field-autofilled", s = t => { "cdk-text-field-autofill-start" !== t.animationName || e.classList.contains(r) ? "cdk-text-field-autofill-end" === t.animationName && e.classList.contains(r) && (e.classList.remove(r), this._ngZone.run(() => i.next({ target: t.target, isAutofilled: !1 }))) : (e.classList.add(r), this._ngZone.run(() => i.next({ target: t.target, isAutofilled: !0 }))) }; return this._ngZone.runOutsideAngular(() => { e.addEventListener("animationstart", s, sy), e.classList.add("cdk-text-field-autofill-monitored") }), this._monitoredElements.set(e, { subject: i, unlisten: () => { e.removeEventListener("animationstart", s, sy) } }), i.asObservable() } stopMonitoring(t) { const e = op(t), n = this._monitoredElements.get(e); n && (n.unlisten(), n.subject.complete(), e.classList.remove("cdk-text-field-autofill-monitored"), e.classList.remove("cdk-text-field-autofilled"), this._monitoredElements.delete(e)) } ngOnDestroy() { this._monitoredElements.forEach((t, e) => this.stopMonitoring(e)) } } return t.ngInjectableDef = ft({ factory: function () { return new t(Nt(up), Nt(Zr)) }, token: t, providedIn: "root" }), t })(), ly = (() => class { })(); const ay = ["button", "checkbox", "file", "hidden", "image", "radio", "range", "reset", "submit"]; let cy = 0; class uy { constructor(t, e, n, i) { this._defaultErrorStateMatcher = t, this._parentForm = e, this._parentFormGroup = n, this.ngControl = i } } const hy = zp(uy); let dy = (() => class extends hy { constructor(t, e, n, i, r, s, o, l, a) { super(s, i, r, n), this._elementRef = t, this._platform = e, this.ngControl = n, this._autofillMonitor = l, this._uid = "mat-input-" + cy++, this._isServer = !1, this._isNativeSelect = !1, this.focused = !1, this.stateChanges = new k, this.controlType = "mat-input", this.autofilled = !1, this._disabled = !1, this._required = !1, this._type = "text", this._readonly = !1, this._neverEmptyInputTypes = ["date", "datetime", "datetime-local", "month", "time", "week"].filter(t => pp().has(t)); const c = this._elementRef.nativeElement; this._inputValueAccessor = o || c, this._previousNativeValue = this.value, this.id = this.id, e.IOS && a.runOutsideAngular(() => { t.nativeElement.addEventListener("keyup", t => { let e = t.target; e.value || e.selectionStart || e.selectionEnd || (e.setSelectionRange(1, 1), e.setSelectionRange(0, 0)) }) }), this._isServer = !this._platform.isBrowser, this._isNativeSelect = "select" === c.nodeName.toLowerCase(), this._isNativeSelect && (this.controlType = c.multiple ? "mat-native-select-multiple" : "mat-native-select") } get disabled() { return this.ngControl && null !== this.ngControl.disabled ? this.ngControl.disabled : this._disabled } set disabled(t) { this._disabled = ip(t), this.focused && (this.focused = !1, this.stateChanges.next()) } get id() { return this._id } set id(t) { this._id = t || this._uid } get required() { return this._required } set required(t) { this._required = ip(t) } get type() { return this._type } set type(t) { this._type = t || "text", this._validateType(), !this._isTextarea() && pp().has(this._type) && (this._elementRef.nativeElement.type = this._type) } get value() { return this._inputValueAccessor.value } set value(t) { t !== this.value && (this._inputValueAccessor.value = t, this.stateChanges.next()) } get readonly() { return this._readonly } set readonly(t) { this._readonly = ip(t) } ngOnInit() { this._platform.isBrowser && this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe(t => { this.autofilled = t.isAutofilled, this.stateChanges.next() }) } ngOnChanges() { this.stateChanges.next() } ngOnDestroy() { this.stateChanges.complete(), this._platform.isBrowser && this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement) } ngDoCheck() { this.ngControl && this.updateErrorState(), this._dirtyCheckNativeValue() } focus(t) { this._elementRef.nativeElement.focus(t) } _focusChanged(t) { t === this.focused || this.readonly && t || (this.focused = t, this.stateChanges.next()) } _onInput() { } _dirtyCheckNativeValue() { const t = this._elementRef.nativeElement.value; this._previousNativeValue !== t && (this._previousNativeValue = t, this.stateChanges.next()) } _validateType() { if (ay.indexOf(this._type) > -1) throw Error(`Input type "${this._type}" isn't supported by matInput.`) } _isNeverEmpty() { return this._neverEmptyInputTypes.indexOf(this._type) > -1 } _isBadInput() { let t = this._elementRef.nativeElement.validity; return t && t.badInput } _isTextarea() { return "textarea" === this._elementRef.nativeElement.nodeName.toLowerCase() } get empty() { return !(this._isNeverEmpty() || this._elementRef.nativeElement.value || this._isBadInput() || this.autofilled) } get shouldLabelFloat() { if (this._isNativeSelect) { const t = this._elementRef.nativeElement, e = t.options[0]; return this.focused || t.multiple || !this.empty || !!(t.selectedIndex > -1 && e && e.label) } return this.focused || !this.empty } setDescribedByIds(t) { this._ariaDescribedby = t.join(" ") } onContainerClick() { this.focused || this.focus() } })(), py = (() => class { })(); class fy { } class my { } class gy { constructor(t) { this.normalizedNames = new Map, this.lazyUpdate = null, t ? this.lazyInit = "string" == typeof t ? () => { this.headers = new Map, t.split("\n").forEach(t => { const e = t.indexOf(":"); if (e > 0) { const n = t.slice(0, e), i = n.toLowerCase(), r = t.slice(e + 1).trim(); this.maybeSetNormalizedName(n, i), this.headers.has(i) ? this.headers.get(i).push(r) : this.headers.set(i, [r]) } }) } : () => { this.headers = new Map, Object.keys(t).forEach(e => { let n = t[e]; const i = e.toLowerCase(); "string" == typeof n && (n = [n]), n.length > 0 && (this.headers.set(i, n), this.maybeSetNormalizedName(e, i)) }) } : this.headers = new Map } has(t) { return this.init(), this.headers.has(t.toLowerCase()) } get(t) { this.init(); const e = this.headers.get(t.toLowerCase()); return e && e.length > 0 ? e[0] : null } keys() { return this.init(), Array.from(this.normalizedNames.values()) } getAll(t) { return this.init(), this.headers.get(t.toLowerCase()) || null } append(t, e) { return this.clone({ name: t, value: e, op: "a" }) } set(t, e) { return this.clone({ name: t, value: e, op: "s" }) } delete(t, e) { return this.clone({ name: t, value: e, op: "d" }) } maybeSetNormalizedName(t, e) { this.normalizedNames.has(e) || this.normalizedNames.set(e, t) } init() { this.lazyInit && (this.lazyInit instanceof gy ? this.copyFrom(this.lazyInit) : this.lazyInit(), this.lazyInit = null, this.lazyUpdate && (this.lazyUpdate.forEach(t => this.applyUpdate(t)), this.lazyUpdate = null)) } copyFrom(t) { t.init(), Array.from(t.headers.keys()).forEach(e => { this.headers.set(e, t.headers.get(e)), this.normalizedNames.set(e, t.normalizedNames.get(e)) }) } clone(t) { const e = new gy; return e.lazyInit = this.lazyInit && this.lazyInit instanceof gy ? this.lazyInit : this, e.lazyUpdate = (this.lazyUpdate || []).concat([t]), e } applyUpdate(t) { const e = t.name.toLowerCase(); switch (t.op) { case "a": case "s": let n = t.value; if ("string" == typeof n && (n = [n]), 0 === n.length) return; this.maybeSetNormalizedName(t.name, e); const i = ("a" === t.op ? this.headers.get(e) : void 0) || []; i.push(...n), this.headers.set(e, i); break; case "d": const r = t.value; if (r) { let t = this.headers.get(e); if (!t) return; t = t.filter(t => -1 === r.indexOf(t)), 0 === t.length ? (this.headers.delete(e), this.normalizedNames.delete(e)) : this.headers.set(e, t) } else this.headers.delete(e), this.normalizedNames.delete(e) } } forEach(t) { this.init(), Array.from(this.normalizedNames.keys()).forEach(e => t(this.normalizedNames.get(e), this.headers.get(e))) } } class _y { encodeKey(t) { return yy(t) } encodeValue(t) { return yy(t) } decodeKey(t) { return decodeURIComponent(t) } decodeValue(t) { return decodeURIComponent(t) } } function yy(t) { return encodeURIComponent(t).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/gi, "$").replace(/%2C/gi, ",").replace(/%3B/gi, ";").replace(/%2B/gi, "+").replace(/%3D/gi, "=").replace(/%3F/gi, "?").replace(/%2F/gi, "/") } class vy { constructor(t = {}) { if (this.updates = null, this.cloneFrom = null, this.encoder = t.encoder || new _y, t.fromString) { if (t.fromObject) throw new Error("Cannot specify both fromString and fromObject."); this.map = function (t, e) { const n = new Map; return t.length > 0 && t.split("&").forEach(t => { const i = t.indexOf("="), [r, s] = -1 == i ? [e.decodeKey(t), ""] : [e.decodeKey(t.slice(0, i)), e.decodeValue(t.slice(i + 1))], o = n.get(r) || []; o.push(s), n.set(r, o) }), n }(t.fromString, this.encoder) } else t.fromObject ? (this.map = new Map, Object.keys(t.fromObject).forEach(e => { const n = t.fromObject[e]; this.map.set(e, Array.isArray(n) ? n : [n]) })) : this.map = null } has(t) { return this.init(), this.map.has(t) } get(t) { this.init(); const e = this.map.get(t); return e ? e[0] : null } getAll(t) { return this.init(), this.map.get(t) || null } keys() { return this.init(), Array.from(this.map.keys()) } append(t, e) { return this.clone({ param: t, value: e, op: "a" }) } set(t, e) { return this.clone({ param: t, value: e, op: "s" }) } delete(t, e) { return this.clone({ param: t, value: e, op: "d" }) } toString() { return this.init(), this.keys().map(t => { const e = this.encoder.encodeKey(t); return this.map.get(t).map(t => e + "=" + this.encoder.encodeValue(t)).join("&") }).join("&") } clone(t) { const e = new vy({ encoder: this.encoder }); return e.cloneFrom = this.cloneFrom || this, e.updates = (this.updates || []).concat([t]), e } init() { null === this.map && (this.map = new Map), null !== this.cloneFrom && (this.cloneFrom.init(), this.cloneFrom.keys().forEach(t => this.map.set(t, this.cloneFrom.map.get(t))), this.updates.forEach(t => { switch (t.op) { case "a": case "s": const e = ("a" === t.op ? this.map.get(t.param) : void 0) || []; e.push(t.value), this.map.set(t.param, e); break; case "d": if (void 0 === t.value) { this.map.delete(t.param); break } { let e = this.map.get(t.param) || []; const n = e.indexOf(t.value); -1 !== n && e.splice(n, 1), e.length > 0 ? this.map.set(t.param, e) : this.map.delete(t.param) } } }), this.cloneFrom = this.updates = null) } } function by(t) { return "undefined" != typeof ArrayBuffer && t instanceof ArrayBuffer } function wy(t) { return "undefined" != typeof Blob && t instanceof Blob } function Cy(t) { return "undefined" != typeof FormData && t instanceof FormData } class Sy { constructor(t, e, n, i) { let r; if (this.url = e, this.body = null, this.reportProgress = !1, this.withCredentials = !1, this.responseType = "json", this.method = t.toUpperCase(), function (t) { switch (t) { case "DELETE": case "GET": case "HEAD": case "OPTIONS": case "JSONP": return !1; default: return !0 } }(this.method) || i ? (this.body = void 0 !== n ? n : null, r = i) : r = n, r && (this.reportProgress = !!r.reportProgress, this.withCredentials = !!r.withCredentials, r.responseType && (this.responseType = r.responseType), r.headers && (this.headers = r.headers), r.params && (this.params = r.params)), this.headers || (this.headers = new gy), this.params) { const t = this.params.toString(); if (0 === t.length) this.urlWithParams = e; else { const n = e.indexOf("?"); this.urlWithParams = e + (-1 === n ? "?" : n < e.length - 1 ? "&" : "") + t } } else this.params = new vy, this.urlWithParams = e } serializeBody() { return null === this.body ? null : by(this.body) || wy(this.body) || Cy(this.body) || "string" == typeof this.body ? this.body : this.body instanceof vy ? this.body.toString() : "object" == typeof this.body || "boolean" == typeof this.body || Array.isArray(this.body) ? JSON.stringify(this.body) : this.body.toString() } detectContentTypeHeader() { return null === this.body || Cy(this.body) ? null : wy(this.body) ? this.body.type || null : by(this.body) ? null : "string" == typeof this.body ? "text/plain" : this.body instanceof vy ? "application/x-www-form-urlencoded;charset=UTF-8" : "object" == typeof this.body || "number" == typeof this.body || Array.isArray(this.body) ? "application/json" : null } clone(t = {}) { const e = t.method || this.method, n = t.url || this.url, i = t.responseType || this.responseType, r = void 0 !== t.body ? t.body : this.body, s = void 0 !== t.withCredentials ? t.withCredentials : this.withCredentials, o = void 0 !== t.reportProgress ? t.reportProgress : this.reportProgress; let l = t.headers || this.headers, a = t.params || this.params; return void 0 !== t.setHeaders && (l = Object.keys(t.setHeaders).reduce((e, n) => e.set(n, t.setHeaders[n]), l)), t.setParams && (a = Object.keys(t.setParams).reduce((e, n) => e.set(n, t.setParams[n]), a)), new Sy(e, n, r, { params: a, headers: l, reportProgress: o, responseType: i, withCredentials: s }) } } const Ey = function () { var t = { Sent: 0, UploadProgress: 1, ResponseHeader: 2, DownloadProgress: 3, Response: 4, User: 5 }; return t[t.Sent] = "Sent", t[t.UploadProgress] = "UploadProgress", t[t.ResponseHeader] = "ResponseHeader", t[t.DownloadProgress] = "DownloadProgress", t[t.Response] = "Response", t[t.User] = "User", t }(); class xy { constructor(t, e = 200, n = "OK") { this.headers = t.headers || new gy, this.status = void 0 !== t.status ? t.status : e, this.statusText = t.statusText || n, this.url = t.url || null, this.ok = this.status >= 200 && this.status < 300 } } class Ty extends xy { constructor(t = {}) { super(t), this.type = Ey.ResponseHeader } clone(t = {}) { return new Ty({ headers: t.headers || this.headers, status: void 0 !== t.status ? t.status : this.status, statusText: t.statusText || this.statusText, url: t.url || this.url || void 0 }) } } class ky extends xy { constructor(t = {}) { super(t), this.type = Ey.Response, this.body = void 0 !== t.body ? t.body : null } clone(t = {}) { return new ky({ body: void 0 !== t.body ? t.body : this.body, headers: t.headers || this.headers, status: void 0 !== t.status ? t.status : this.status, statusText: t.statusText || this.statusText, url: t.url || this.url || void 0 }) } } class Py extends xy { constructor(t) { super(t, 0, "Unknown Error"), this.name = "HttpErrorResponse", this.ok = !1, this.message = this.status >= 200 && this.status < 300 ? "Http failure during parsing for " + (t.url || "(unknown url)") : `Http failure response for ${t.url || "(unknown url)"}: ${t.status} ${t.statusText}`, this.error = t.error || null } } function Oy(t, e) { return { body: e, headers: t.headers, observe: t.observe, params: t.params, reportProgress: t.reportProgress, responseType: t.responseType, withCredentials: t.withCredentials } } let Iy = (() => class { constructor(t) { this.handler = t } request(t, e, n = {}) { let i; if (t instanceof Sy) i = t; else { let r = void 0; r = n.headers instanceof gy ? n.headers : new gy(n.headers); let s = void 0; n.params && (s = n.params instanceof vy ? n.params : new vy({ fromObject: n.params })), i = new Sy(t, e, void 0 !== n.body ? n.body : null, { headers: r, params: s, reportProgress: n.reportProgress, responseType: n.responseType || "json", withCredentials: n.withCredentials }) } const r = oa(i).pipe(Za(t => this.handler.handle(t))); if (t instanceof Sy || "events" === n.observe) return r; const s = r.pipe(ma(t => t instanceof ky)); switch (n.observe || "body") { case "body": switch (i.responseType) { case "arraybuffer": return s.pipe(H(t => { if (null !== t.body && !(t.body instanceof ArrayBuffer)) throw new Error("Response is not an ArrayBuffer."); return t.body })); case "blob": return s.pipe(H(t => { if (null !== t.body && !(t.body instanceof Blob)) throw new Error("Response is not a Blob."); return t.body })); case "text": return s.pipe(H(t => { if (null !== t.body && "string" != typeof t.body) throw new Error("Response is not a string."); return t.body })); case "json": default: return s.pipe(H(t => t.body)) }case "response": return s; default: throw new Error(`Unreachable: unhandled observe type ${n.observe}}`) } } delete(t, e = {}) { return this.request("DELETE", t, e) } get(t, e = {}) { return this.request("GET", t, e) } head(t, e = {}) { return this.request("HEAD", t, e) } jsonp(t, e) { return this.request("JSONP", t, { params: (new vy).append(e, "JSONP_CALLBACK"), observe: "body", responseType: "json" }) } options(t, e = {}) { return this.request("OPTIONS", t, e) } patch(t, e, n = {}) { return this.request("PATCH", t, Oy(n, e)) } post(t, e, n = {}) { return this.request("POST", t, Oy(n, e)) } put(t, e, n = {}) { return this.request("PUT", t, Oy(n, e)) } })(); class Ay { constructor(t, e) { this.next = t, this.interceptor = e } handle(t) { return this.interceptor.intercept(t, this.next) } } const Ry = new Tt("HTTP_INTERCEPTORS"); let Ny = (() => class { intercept(t, e) { return e.handle(t) } })(); const My = /^\)\]\}',?\n/; class Dy { } let Fy = (() => class { constructor() { } build() { return new XMLHttpRequest } })(), Ly = (() => class { constructor(t) { this.xhrFactory = t } handle(t) { if ("JSONP" === t.method) throw new Error("Attempted to construct Jsonp request without JsonpClientModule installed."); return new w(e => { const n = this.xhrFactory.build(); if (n.open(t.method, t.urlWithParams), t.withCredentials && (n.withCredentials = !0), t.headers.forEach((t, e) => n.setRequestHeader(t, e.join(","))), t.headers.has("Accept") || n.setRequestHeader("Accept", "application/json, text/plain, */*"), !t.headers.has("Content-Type")) { const e = t.detectContentTypeHeader(); null !== e && n.setRequestHeader("Content-Type", e) } if (t.responseType) { const e = t.responseType.toLowerCase(); n.responseType = "json" !== e ? e : "text" } const i = t.serializeBody(); let r = null; const s = () => { if (null !== r) return r; const e = 1223 === n.status ? 204 : n.status, i = n.statusText || "OK", s = new gy(n.getAllResponseHeaders()), o = function (t) { return "responseURL" in t && t.responseURL ? t.responseURL : /^X-Request-URL:/m.test(t.getAllResponseHeaders()) ? t.getResponseHeader("X-Request-URL") : null }(n) || t.url; return r = new Ty({ headers: s, status: e, statusText: i, url: o }), r }, o = () => { let { headers: i, status: r, statusText: o, url: l } = s(), a = null; 204 !== r && (a = void 0 === n.response ? n.responseText : n.response), 0 === r && (r = a ? 200 : 0); let c = r >= 200 && r < 300; if ("json" === t.responseType && "string" == typeof a) { const t = a; a = a.replace(My, ""); try { a = "" !== a ? JSON.parse(a) : null } catch (u) { a = t, c && (c = !1, a = { error: u, text: a }) } } c ? (e.next(new ky({ body: a, headers: i, status: r, statusText: o, url: l || void 0 })), e.complete()) : e.error(new Py({ error: a, headers: i, status: r, statusText: o, url: l || void 0 })) }, l = t => { const { url: i } = s(), r = new Py({ error: t, status: n.status || 0, statusText: n.statusText || "Unknown Error", url: i || void 0 }); e.error(r) }; let a = !1; const c = i => { a || (e.next(s()), a = !0); let r = { type: Ey.DownloadProgress, loaded: i.loaded }; i.lengthComputable && (r.total = i.total), "text" === t.responseType && n.responseText && (r.partialText = n.responseText), e.next(r) }, u = t => { let n = { type: Ey.UploadProgress, loaded: t.loaded }; t.lengthComputable && (n.total = t.total), e.next(n) }; return n.addEventListener("load", o), n.addEventListener("error", l), t.reportProgress && (n.addEventListener("progress", c), null !== i && n.upload && n.upload.addEventListener("progress", u)), n.send(i), e.next({ type: Ey.Sent }), () => { n.removeEventListener("error", l), n.removeEventListener("load", o), t.reportProgress && (n.removeEventListener("progress", c), null !== i && n.upload && n.upload.removeEventListener("progress", u)), n.abort() } }) } })(); const Vy = new Tt("XSRF_COOKIE_NAME"), zy = new Tt("XSRF_HEADER_NAME"); class jy { } let Uy = (() => class { constructor(t, e, n) { this.doc = t, this.platform = e, this.cookieName = n, this.lastCookieString = "", this.lastToken = null, this.parseCount = 0 } getToken() { if ("server" === this.platform) return null; const t = this.doc.cookie || ""; return t !== this.lastCookieString && (this.parseCount++, this.lastToken = Hl(t, this.cookieName), this.lastCookieString = t), this.lastToken } })(), Hy = (() => class { constructor(t, e) { this.tokenService = t, this.headerName = e } intercept(t, e) { const n = t.url.toLowerCase(); if ("GET" === t.method || "HEAD" === t.method || n.startsWith("http://") || n.startsWith("https://")) return e.handle(t); const i = this.tokenService.getToken(); return null === i || t.headers.has(this.headerName) || (t = t.clone({ headers: t.headers.set(this.headerName, i) })), e.handle(t) } })(), By = (() => class { constructor(t, e) { this.backend = t, this.injector = e, this.chain = null } handle(t) { if (null === this.chain) { const t = this.injector.get(Ry, []); this.chain = t.reduceRight((t, e) => new Ay(t, e), this.backend) } return this.chain.handle(t) } })(), $y = (() => { class t { static disable() { return { ngModule: t, providers: [{ provide: Hy, useClass: Ny }] } } static withOptions(e = {}) { return { ngModule: t, providers: [e.cookieName ? { provide: Vy, useValue: e.cookieName } : [], e.headerName ? { provide: zy, useValue: e.headerName } : []] } } } return t })(), Wy = (() => class { })(); function qy(t, e) { return new w(e ? n => e.schedule(Gy, 0, { error: t, subscriber: n }) : e => e.error(t)) } function Gy({ error: t, subscriber: e }) { e.error(t) } function Zy(t) { return Error(`Unable to find icon with the name "${t}"`) } function Qy(t) { return Error(`The URL provided to MatIconRegistry was not trusted as a resource URL via Angular's DomSanitizer. Attempted URL was "${t}".`) } function Ky(t) { return Error(`The literal provided to MatIconRegistry was not trusted as safe HTML by Angular's DomSanitizer. Attempted literal was "${t}".`) } class Yy { constructor(t, e) { this.options = e, t.nodeName ? this.svgElement = t : this.url = t } } let Xy = (() => { class t { constructor(t, e, n, i) { this._httpClient = t, this._sanitizer = e, this._errorHandler = i, this._svgIconConfigs = new Map, this._iconSetConfigs = new Map, this._cachedIconsByUrl = new Map, this._inProgressUrlFetches = new Map, this._fontCssClassesByAlias = new Map, this._defaultFontSetClass = "material-icons", this._document = n } addSvgIcon(t, e, n) { return this.addSvgIconInNamespace("", t, e, n) } addSvgIconLiteral(t, e, n) { return this.addSvgIconLiteralInNamespace("", t, e, n) } addSvgIconInNamespace(t, e, n, i) { return this._addSvgIconConfig(t, e, new Yy(n, i)) } addSvgIconLiteralInNamespace(t, e, n, i) { const r = this._sanitizer.sanitize(ve.HTML, n); if (!r) throw Ky(n); const s = this._createSvgElementForSingleIcon(r, i); return this._addSvgIconConfig(t, e, new Yy(s, i)) } addSvgIconSet(t, e) { return this.addSvgIconSetInNamespace("", t, e) } addSvgIconSetLiteral(t, e) { return this.addSvgIconSetLiteralInNamespace("", t, e) } addSvgIconSetInNamespace(t, e, n) { return this._addSvgIconSetConfig(t, new Yy(e, n)) } addSvgIconSetLiteralInNamespace(t, e, n) { const i = this._sanitizer.sanitize(ve.HTML, e); if (!i) throw Ky(e); const r = this._svgElementFromString(i); return this._addSvgIconSetConfig(t, new Yy(r, n)) } registerFontClassAlias(t, e = t) { return this._fontCssClassesByAlias.set(t, e), this } classNameForFontAlias(t) { return this._fontCssClassesByAlias.get(t) || t } setDefaultFontSetClass(t) { return this._defaultFontSetClass = t, this } getDefaultFontSetClass() { return this._defaultFontSetClass } getSvgIconFromUrl(t) { const e = this._sanitizer.sanitize(ve.RESOURCE_URL, t); if (!e) throw Qy(t); const n = this._cachedIconsByUrl.get(e); return n ? oa(Jy(n)) : this._loadSvgIconFromConfig(new Yy(t)).pipe(Sa(t => this._cachedIconsByUrl.set(e, t)), H(t => Jy(t))) } getNamedSvgIcon(t, e = "") { const n = tv(e, t), i = this._svgIconConfigs.get(n); if (i) return this._getSvgFromConfig(i); const r = this._iconSetConfigs.get(e); return r ? this._getSvgFromIconSetConfigs(t, r) : qy(Zy(n)) } ngOnDestroy() { this._svgIconConfigs.clear(), this._iconSetConfigs.clear(), this._cachedIconsByUrl.clear() } _getSvgFromConfig(t) { return t.svgElement ? oa(Jy(t.svgElement)) : this._loadSvgIconFromConfig(t).pipe(Sa(e => t.svgElement = e), H(t => Jy(t))) } _getSvgFromIconSetConfigs(t, e) { const n = this._extractIconWithNameFromAnySet(t, e); return n ? oa(n) : qg(e.filter(t => !t.svgElement).map(t => this._loadSvgIconSetFromConfig(t).pipe(Ra(e => { const n = `Loading icon set URL: ${this._sanitizer.sanitize(ve.RESOURCE_URL, t.url)} failed: ${e.message}`; return this._errorHandler ? this._errorHandler.handleError(new Error(n)) : console.error(n), oa(null) })))).pipe(H(() => { const n = this._extractIconWithNameFromAnySet(t, e); if (!n) throw Zy(t); return n })) } _extractIconWithNameFromAnySet(t, e) { for (let n = e.length - 1; n >= 0; n--) { const i = e[n]; if (i.svgElement) { const e = this._extractSvgIconFromSet(i.svgElement, t, i.options); if (e) return e } } return null } _loadSvgIconFromConfig(t) { return this._fetchUrl(t.url).pipe(H(e => this._createSvgElementForSingleIcon(e, t.options))) } _loadSvgIconSetFromConfig(t) { return t.svgElement ? oa(t.svgElement) : this._fetchUrl(t.url).pipe(H(e => (t.svgElement || (t.svgElement = this._svgElementFromString(e)), t.svgElement))) } _createSvgElementForSingleIcon(t, e) { const n = this._svgElementFromString(t); return this._setSvgAttributes(n, e), n } _extractSvgIconFromSet(t, e, n) { const i = t.querySelector(`[id="${e}"]`); if (!i) return null; const r = i.cloneNode(!0); if (r.removeAttribute("id"), "svg" === r.nodeName.toLowerCase()) return this._setSvgAttributes(r, n); if ("symbol" === r.nodeName.toLowerCase()) return this._setSvgAttributes(this._toSvgElement(r), n); const s = this._svgElementFromString("<svg></svg>"); return s.appendChild(r), this._setSvgAttributes(s, n) } _svgElementFromString(t) { const e = this._document.createElement("DIV"); e.innerHTML = t; const n = e.querySelector("svg"); if (!n) throw Error("<svg> tag not found"); return n } _toSvgElement(t) { const e = this._svgElementFromString("<svg></svg>"), n = t.attributes; for (let i = 0; i < n.length; i++) { const { name: t, value: r } = n[i]; "id" !== t && e.setAttribute(t, r) } for (let i = 0; i < t.childNodes.length; i++)t.childNodes[i].nodeType === this._document.ELEMENT_NODE && e.appendChild(t.childNodes[i].cloneNode(!0)); return e } _setSvgAttributes(t, e) { return t.setAttribute("fit", ""), t.setAttribute("height", "100%"), t.setAttribute("width", "100%"), t.setAttribute("preserveAspectRatio", "xMidYMid meet"), t.setAttribute("focusable", "false"), e && e.viewBox && t.setAttribute("viewBox", e.viewBox), t } _fetchUrl(t) { if (!this._httpClient) throw Error("Could not find HttpClient provider for use with Angular Material icons. Please include the HttpClientModule from @angular/common/http in your app imports."); if (null == t) throw Error(`Cannot fetch icon from URL "${t}".`); const e = this._sanitizer.sanitize(ve.RESOURCE_URL, t); if (!e) throw Qy(t); const n = this._inProgressUrlFetches.get(e); if (n) return n; const i = this._httpClient.get(e, { responseType: "text" }).pipe(Qa(() => this._inProgressUrlFetches.delete(e)), ot()); return this._inProgressUrlFetches.set(e, i), i } _addSvgIconConfig(t, e, n) { return this._svgIconConfigs.set(tv(t, e), n), this } _addSvgIconSetConfig(t, e) { const n = this._iconSetConfigs.get(t); return n ? n.push(e) : this._iconSetConfigs.set(t, [e]), this } } return t.ngInjectableDef = ft({ factory: function () { return new t(Nt(Iy, 8), Nt(Gc), Nt(ta, 8), Nt(Te, 8)) }, token: t, providedIn: "root" }), t })(); function Jy(t) { return t.cloneNode(!0) } function tv(t, e) { return t + ":" + e } class ev { constructor(t) { this._elementRef = t } } const nv = Lp(ev), iv = new Tt("mat-icon-location", { providedIn: "root", factory: function () { const t = Mt(ta), e = t ? t.location : null; return { getPathname: () => e ? e.pathname + e.search : "" } } }), rv = ["clip-path", "color-profile", "src", "cursor", "fill", "filter", "marker", "marker-start", "marker-mid", "marker-end", "mask", "stroke"], sv = rv.map(t => `[${t}]`).join(", "), ov = /^url\(['"]?#(.*?)['"]?\)$/; let lv = (() => class extends nv { constructor(t, e, n, i, r) { super(t), this._iconRegistry = e, this._location = i, this._errorHandler = r, this._inline = !1, n || t.nativeElement.setAttribute("aria-hidden", "true") } get inline() { return this._inline } set inline(t) { this._inline = ip(t) } get fontSet() { return this._fontSet } set fontSet(t) { this._fontSet = this._cleanupFontValue(t) } get fontIcon() { return this._fontIcon } set fontIcon(t) { this._fontIcon = this._cleanupFontValue(t) } _splitIconName(t) { if (!t) return ["", ""]; const e = t.split(":"); switch (e.length) { case 1: return ["", e[0]]; case 2: return e; default: throw Error(`Invalid icon name: "${t}"`) } } ngOnChanges(t) { const e = t.svgIcon; if (e) if (this.svgIcon) { const [t, e] = this._splitIconName(this.svgIcon); this._iconRegistry.getNamedSvgIcon(e, t).pipe(Da(1)).subscribe(t => this._setSvgElement(t), n => { const i = `Error retrieving icon ${t}:${e}! ${n.message}`; this._errorHandler ? this._errorHandler.handleError(new Error(i)) : console.error(i) }) } else e.previousValue && this._clearSvgElement(); this._usingFontIcon() && this._updateFontIconClasses() } ngOnInit() { this._usingFontIcon() && this._updateFontIconClasses() } ngAfterViewChecked() { const t = this._elementsWithExternalReferences; if (t && this._location && t.size) { const t = this._location.getPathname(); t !== this._previousPath && (this._previousPath = t, this._prependPathToReferences(t)) } } ngOnDestroy() { this._elementsWithExternalReferences && this._elementsWithExternalReferences.clear() } _usingFontIcon() { return !this.svgIcon } _setSvgElement(t) { this._clearSvgElement(); const e = t.querySelectorAll("style"); for (let n = 0; n < e.length; n++)e[n].textContent += " "; if (this._location) { const e = this._location.getPathname(); this._previousPath = e, this._cacheChildrenWithExternalReferences(t), this._prependPathToReferences(e) } this._elementRef.nativeElement.appendChild(t) } _clearSvgElement() { const t = this._elementRef.nativeElement; let e = t.childNodes.length; for (this._elementsWithExternalReferences && this._elementsWithExternalReferences.clear(); e--;) { const n = t.childNodes[e]; 1 === n.nodeType && "svg" !== n.nodeName.toLowerCase() || t.removeChild(n) } } _updateFontIconClasses() { if (!this._usingFontIcon()) return; const t = this._elementRef.nativeElement, e = this.fontSet ? this._iconRegistry.classNameForFontAlias(this.fontSet) : this._iconRegistry.getDefaultFontSetClass(); e != this._previousFontSetClass && (this._previousFontSetClass && t.classList.remove(this._previousFontSetClass), e && t.classList.add(e), this._previousFontSetClass = e), this.fontIcon != this._previousFontIconClass && (this._previousFontIconClass && t.classList.remove(this._previousFontIconClass), this.fontIcon && t.classList.add(this.fontIcon), this._previousFontIconClass = this.fontIcon) } _cleanupFontValue(t) { return "string" == typeof t ? t.trim().split(" ")[0] : t } _prependPathToReferences(t) { const e = this._elementsWithExternalReferences; e && e.forEach((e, n) => { e.forEach(e => { n.setAttribute(e.name, `url('${t}#${e.value}')`) }) }) } _cacheChildrenWithExternalReferences(t) { const e = t.querySelectorAll(sv), n = this._elementsWithExternalReferences = this._elementsWithExternalReferences || new Map; for (let i = 0; i < e.length; i++)rv.forEach(t => { const r = e[i], s = r.getAttribute(t), o = s ? s.match(ov) : null; if (o) { let e = n.get(r); e || (e = [], n.set(r, e)), e.push({ name: t, value: o[1] }) } }) } })(), av = (() => class { })(); var cv = jn({ encapsulation: 2, styles: [".mat-icon{background-repeat:no-repeat;display:inline-block;fill:currentColor;height:24px;width:24px}.mat-icon.mat-icon-inline{font-size:inherit;height:inherit;line-height:inherit;width:inherit}[dir=rtl] .mat-icon-rtl-mirror{transform:scale(-1,1)}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon{display:block}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-icon{margin:auto}"], data: {} }); function uv(t) { return Zs(2, [Hs(null, 0)], null, null) } const hv = ["mat-button", "mat-flat-button", "mat-icon-button", "mat-raised-button", "mat-stroked-button", "mat-mini-fab", "mat-fab"]; class dv { constructor(t) { this._elementRef = t } } const pv = Lp(Fp(Vp(dv))); let fv = (() => class extends pv { constructor(t, e, n) { super(t), this._focusMonitor = e, this._animationMode = n, this.isRoundButton = this._hasHostAttributes("mat-fab", "mat-mini-fab"), this.isIconButton = this._hasHostAttributes("mat-icon-button"); for (const i of hv) this._hasHostAttributes(i) && this._getHostElement().classList.add(i); t.nativeElement.classList.add("mat-button-base"), this._focusMonitor.monitor(this._elementRef, !0), this.isRoundButton && (this.color = "accent") } ngOnDestroy() { this._focusMonitor.stopMonitoring(this._elementRef) } focus(t = "program", e) { this._focusMonitor.focusVia(this._getHostElement(), t, e) } _getHostElement() { return this._elementRef.nativeElement } _isRippleDisabled() { return this.disableRipple || this.disabled } _hasHostAttributes(...t) { return t.some(t => this._getHostElement().hasAttribute(t)) } })(), mv = (() => class { })(); var gv = jn({ encapsulation: 2, styles: [".mat-button .mat-button-focus-overlay,.mat-icon-button .mat-button-focus-overlay{opacity:0}.mat-button:hover .mat-button-focus-overlay,.mat-stroked-button:hover .mat-button-focus-overlay{opacity:.04}@media (hover:none){.mat-button:hover .mat-button-focus-overlay,.mat-stroked-button:hover .mat-button-focus-overlay{opacity:0}}.mat-button,.mat-flat-button,.mat-icon-button,.mat-stroked-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible}.mat-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner{border:0}.mat-button[disabled],.mat-flat-button[disabled],.mat-icon-button[disabled],.mat-stroked-button[disabled]{cursor:default}.mat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-button.cdk-program-focused .mat-button-focus-overlay,.mat-flat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-flat-button.cdk-program-focused .mat-button-focus-overlay,.mat-icon-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-icon-button.cdk-program-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner{border:0}.mat-raised-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0,0,0);transition:background .4s cubic-bezier(.25,.8,.25,1),box-shadow 280ms cubic-bezier(.4,0,.2,1)}.mat-raised-button::-moz-focus-inner{border:0}.mat-raised-button[disabled]{cursor:default}.mat-raised-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-raised-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-raised-button::-moz-focus-inner{border:0}._mat-animation-noopable.mat-raised-button{transition:none;animation:none}.mat-stroked-button{border:1px solid currentColor;padding:0 15px;line-height:34px}.mat-stroked-button .mat-button-focus-overlay,.mat-stroked-button .mat-button-ripple.mat-ripple{top:-1px;left:-1px;right:-1px;bottom:-1px}.mat-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0,0,0);transition:background .4s cubic-bezier(.25,.8,.25,1),box-shadow 280ms cubic-bezier(.4,0,.2,1);min-width:0;border-radius:50%;width:56px;height:56px;padding:0;flex-shrink:0}.mat-fab::-moz-focus-inner{border:0}.mat-fab[disabled]{cursor:default}.mat-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-fab{transition:none;animation:none}.mat-fab .mat-button-wrapper{padding:16px 0;display:inline-block;line-height:24px}.mat-mini-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0,0,0);transition:background .4s cubic-bezier(.25,.8,.25,1),box-shadow 280ms cubic-bezier(.4,0,.2,1);min-width:0;border-radius:50%;width:40px;height:40px;padding:0;flex-shrink:0}.mat-mini-fab::-moz-focus-inner{border:0}.mat-mini-fab[disabled]{cursor:default}.mat-mini-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-mini-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-mini-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-mini-fab{transition:none;animation:none}.mat-mini-fab .mat-button-wrapper{padding:8px 0;display:inline-block;line-height:24px}.mat-icon-button{padding:0;min-width:0;width:40px;height:40px;flex-shrink:0;line-height:40px;border-radius:50%}.mat-icon-button .mat-icon,.mat-icon-button i{line-height:24px}.mat-button-focus-overlay,.mat-button-ripple.mat-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-button-ripple.mat-ripple:not(:empty){transform:translateZ(0)}.mat-button-focus-overlay{opacity:0;transition:opacity .2s cubic-bezier(.35,0,.25,1),background-color .2s cubic-bezier(.35,0,.25,1)}._mat-animation-noopable .mat-button-focus-overlay{transition:none}@media (-ms-high-contrast:active){.mat-button-focus-overlay{background-color:#fff}}@media (-ms-high-contrast:black-on-white){.mat-button-focus-overlay{background-color:#000}}.mat-button-ripple-round{border-radius:50%;z-index:1}.mat-button .mat-button-wrapper>*,.mat-fab .mat-button-wrapper>*,.mat-flat-button .mat-button-wrapper>*,.mat-icon-button .mat-button-wrapper>*,.mat-mini-fab .mat-button-wrapper>*,.mat-raised-button .mat-button-wrapper>*,.mat-stroked-button .mat-button-wrapper>*{vertical-align:middle}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button{display:block;font-size:inherit;width:2.5em;height:2.5em}@media (-ms-high-contrast:active){.mat-button,.mat-fab,.mat-flat-button,.mat-icon-button,.mat-mini-fab,.mat-raised-button{outline:solid 1px}}"], data: {} }); function _v(t) { return Zs(2, [Ls(671088640, 1, { ripple: 0 }), (t()(), Rs(1, 0, null, null, 1, "span", [["class", "mat-button-wrapper"]], null, null, null, null, null)), Hs(null, 0), (t()(), Rs(3, 0, null, null, 1, "div", [["class", "mat-button-ripple mat-ripple"], ["matRipple", ""]], [[2, "mat-button-ripple-round", null], [2, "mat-ripple-unbounded", null]], null, null, null, null)), Ki(4, 212992, [[1, 4]], 0, Gp, [Qe, Zr, up, [2, qp], [2, Ag]], { centered: [0, "centered"], disabled: [1, "disabled"], trigger: [2, "trigger"] }, null), (t()(), Rs(5, 0, null, null, 0, "div", [["class", "mat-button-focus-overlay"]], null, null, null, null, null))], (function (t, e) { var n = e.component; t(e, 4, 0, n.isIconButton, n._isRippleDisabled(), n._getHostElement()) }), (function (t, e) { var n = e.component; t(e, 3, 0, n.isRoundButton || n.isIconButton, Li(e, 4).unbounded) })) } function yv(t, e, n, i) { return new (n || (n = Promise))((function (r, s) { function o(t) { try { a(i.next(t)) } catch (e) { s(e) } } function l(t) { try { a(i.throw(t)) } catch (e) { s(e) } } function a(t) { var e; t.done ? r(t.value) : (e = t.value, e instanceof n ? e : new n((function (t) { t(e) }))).then(o, l) } a((i = i.apply(t, e || [])).next()) })) } class vv { constructor(t, e) { this.dialogRef = t, this.data = e } ngOnInit() { } close(t) { this.dialogRef.close(t) } } class bv { constructor(t, e, n) { this.auth = t, this.dialog = e, this.router = n, this.username = "brhilyes@gmail.com", this.password = "12341234" } ngOnInit() { } login() { return yv(this, void 0, void 0, (function* () { let t = yield this.auth.login(this.username, this.password).toPromise(); t.success ? this.router.navigate(["home"]) : this.fail(t.message) })) } fail(t) { return this.dialog.open(vv, { width: "400px", data: { description: t, primary: { icon: "refresh", text: " try again" }, secondary: { icon: "close", text: " cancel" } } }) } } class wv { constructor(t) { this.value = t } call(t, e) { return e.subscribe(new Cv(t, this.value)) } } class Cv extends m { constructor(t, e) { super(t), this.value = e } _next(t) { this.destination.next(this.value) } } class Sv { constructor(t, e) { this.notifier = t, this.source = e } call(t, e) { return e.subscribe(new Ev(t, this.notifier, this.source)) } } class Ev extends U { constructor(t, e, n) { super(t), this.notifier = e, this.source = n } error(t) { if (!this.isStopped) { let n = this.errors, i = this.retries, r = this.retriesSubscription; if (i) this.errors = null, this.retriesSubscription = null; else { n = new k; try { const { notifier: t } = this; i = t(n) } catch (e) { return super.error(e) } r = j(this, i) } this._unsubscribeAndRecycle(), this.errors = n, this.retries = i, this.retriesSubscription = r, n.next(t) } } _unsubscribe() { const { errors: t, retriesSubscription: e } = this; t && (t.unsubscribe(), this.errors = null), e && (e.unsubscribe(), this.retriesSubscription = null), this.retries = null } notifyNext(t, e, n, i, r) { const { _unsubscribe: s } = this; this._unsubscribe = null, this._unsubscribeAndRecycle(), this._unsubscribe = s, this.source.subscribe(this) } } let xv = (() => { class t { constructor(t, e, n) { this.kind = t, this.value = e, this.error = n, this.hasValue = "N" === t } observe(t) { switch (this.kind) { case "N": return t.next && t.next(this.value); case "E": return t.error && t.error(this.error); case "C": return t.complete && t.complete() } } do(t, e, n) { switch (this.kind) { case "N": return t && t(this.value); case "E": return e && e(this.error); case "C": return n && n() } } accept(t, e, n) { return t && "function" == typeof t.next ? this.observe(t) : this.do(t, e, n) } toObservable() { switch (this.kind) { case "N": return oa(this.value); case "E": return qy(this.error); case "C": return ra() }throw new Error("unexpected notification kind value") } static createNext(e) { return void 0 !== e ? new t("N", e) : t.undefinedValueNotification } static createError(e) { return new t("E", void 0, e) } static createComplete() { return t.completeNotification } } return t.completeNotification = new t("C"), t.undefinedValueNotification = new t("N", void 0), t })(); class Tv { constructor(t, e) { this.delay = t, this.scheduler = e } call(t, e) { return e.subscribe(new kv(t, this.delay, this.scheduler)) } } class kv extends m { constructor(t, e, n) { super(t), this.delay = e, this.scheduler = n, this.queue = [], this.active = !1, this.errored = !1 } static dispatch(t) { const e = t.source, n = e.queue, i = t.scheduler, r = t.destination; for (; n.length > 0 && n[0].time - i.now() <= 0;)n.shift().notification.observe(r); if (n.length > 0) { const e = Math.max(0, n[0].time - i.now()); this.schedule(t, e) } else this.unsubscribe(), e.active = !1 } _schedule(t) { this.active = !0, this.destination.add(t.schedule(kv.dispatch, this.delay, { source: this, destination: this.destination, scheduler: t })) } scheduleNotification(t) { if (!0 === this.errored) return; const e = this.scheduler, n = new Pv(e.now() + this.delay, t); this.queue.push(n), !1 === this.active && this._schedule(e) } _next(t) { this.scheduleNotification(xv.createNext(t)) } _error(t) { this.errored = !0, this.queue = [], this.destination.error(t), this.unsubscribe() } _complete() { this.scheduleNotification(xv.createComplete()), this.unsubscribe() } } class Pv { constructor(t, e) { this.time = t, this.notification = e } } class Ov extends _p { constructor(t, e) { super(t, e), this.scheduler = t, this.work = e } schedule(t, e = 0) { return e > 0 ? super.schedule(t, e) : (this.delay = e, this.state = t, this.scheduler.flush(this), this) } execute(t, e) { return e > 0 || this.closed ? super.execute(t, e) : this._execute(t, e) } requestAsyncId(t, e, n = 0) { return null !== n && n > 0 || null === n && this.delay > 0 ? super.requestAsyncId(t, e, n) : t.flush(this) } } class Iv extends vp { } const Av = new Iv(Ov); class Rv extends m { constructor(t, e, n = 0) { super(t), this.scheduler = e, this.delay = n } static dispatch(t) { const { notification: e, destination: n } = t; e.observe(n), this.unsubscribe() } scheduleMessage(t) { this.destination.add(this.scheduler.schedule(Rv.dispatch, this.delay, new Nv(t, this.destination))) } _next(t) { this.scheduleMessage(xv.createNext(t)) } _error(t) { this.scheduleMessage(xv.createError(t)), this.unsubscribe() } _complete() { this.scheduleMessage(xv.createComplete()), this.unsubscribe() } } class Nv { constructor(t, e) { this.notification = t, this.destination = e } } class Mv extends k { constructor(t = Number.POSITIVE_INFINITY, e = Number.POSITIVE_INFINITY, n) { super(), this.scheduler = n, this._events = [], this._infiniteTimeWindow = !1, this._bufferSize = t < 1 ? 1 : t, this._windowTime = e < 1 ? 1 : e, e === Number.POSITIVE_INFINITY ? (this._infiniteTimeWindow = !0, this.next = this.nextInfiniteTimeWindow) : this.next = this.nextTimeWindow } nextInfiniteTimeWindow(t) { const e = this._events; e.push(t), e.length > this._bufferSize && e.shift(), super.next(t) } nextTimeWindow(t) { this._events.push(new Dv(this._getNow(), t)), this._trimBufferThenGetEvents(), super.next(t) } _subscribe(t) { const e = this._infiniteTimeWindow, n = e ? this._events : this._trimBufferThenGetEvents(), i = this.scheduler, r = n.length; let s; if (this.closed) throw new E; if (this.isStopped || this.hasError ? s = d.EMPTY : (this.observers.push(t), s = new x(this, t)), i && t.add(t = new Rv(t, i)), e) for (let o = 0; o < r && !t.closed; o++)t.next(n[o]); else for (let o = 0; o < r && !t.closed; o++)t.next(n[o].value); return this.hasError ? t.error(this.thrownError) : this.isStopped && t.complete(), s } _getNow() { return (this.scheduler || Av).now() } _trimBufferThenGetEvents() { const t = this._getNow(), e = this._bufferSize, n = this._windowTime, i = this._events, r = i.length; let s = 0; for (; s < r && !(t - i[s].time < n);)s++; return r > e && (s = Math.max(s, r - e)), s > 0 && i.splice(0, s), i } } class Dv { constructor(t, e) { this.time = t, this.value = e } } const Fv = { url: "", deserializer: t => JSON.parse(t.data), serializer: t => JSON.stringify(t) }; class Lv extends P { constructor(t, e) { if (super(), t instanceof w) this.destination = e, this.source = t; else { const e = this._config = Object.assign({}, Fv); if (this._output = new k, "string" == typeof t) e.url = t; else for (let n in t) t.hasOwnProperty(n) && (e[n] = t[n]); if (!e.WebSocketCtor && WebSocket) e.WebSocketCtor = WebSocket; else if (!e.WebSocketCtor) throw new Error("no WebSocket constructor can be found"); this.destination = new Mv } } lift(t) { const e = new Lv(this._config, this.destination); return e.operator = t, e.source = this, e } _resetState() { this._socket = null, this.source || (this.destination = new Mv), this._output = new k } multiplex(t, e, n) { const i = this; return new w(r => { try { i.next(t()) } catch (o) { r.error(o) } const s = i.subscribe(t => { try { n(t) && r.next(t) } catch (o) { r.error(o) } }, t => r.error(t), () => r.complete()); return () => { try { i.next(e()) } catch (o) { r.error(o) } s.unsubscribe() } }) } _connectSocket() { const { WebSocketCtor: t, protocol: e, url: n, binaryType: i } = this._config, r = this._output; let s = null; try { s = e ? new t(n, e) : new t(n), this._socket = s, i && (this._socket.binaryType = i) } catch (l) { return void r.error(l) } const o = new d(() => { this._socket = null, s && 1 === s.readyState && s.close() }); s.onopen = t => { const { _socket: e } = this; if (!e) return s.close(), void this._resetState(); const { openObserver: n } = this._config; n && n.next(t); const i = this.destination; this.destination = m.create(e => { if (1 === s.readyState) try { const { serializer: t } = this._config; s.send(t(e)) } catch (t) { this.destination.error(t) } }, t => { const { closingObserver: e } = this._config; e && e.next(void 0), t && t.code ? s.close(t.code, t.reason) : r.error(new TypeError("WebSocketSubject.error must be called with an object with an error code, and an optional reason: { code: number, reason: string }")), this._resetState() }, () => { const { closingObserver: t } = this._config; t && t.next(void 0), s.close(), this._resetState() }), i && i instanceof Mv && o.add(i.subscribe(this.destination)) }, s.onerror = t => { this._resetState(), r.error(t) }, s.onclose = t => { this._resetState(); const { closeObserver: e } = this._config; e && e.next(t), t.wasClean ? r.complete() : r.error(t) }, s.onmessage = t => { try { const { deserializer: e } = this._config; r.next(e(t)) } catch (e) { r.error(e) } } } _subscribe(t) { const { source: e } = this; return e ? e.subscribe(t) : (this._socket || this._connectSocket(), this._output.subscribe(t), t.add(() => { const { _socket: t } = this; 0 === this._output.observers.length && (t && 1 === t.readyState && t.close(), this._resetState()) }), t) } unsubscribe() { const { _socket: t } = this; t && 1 === t.readyState && t.close(), this._resetState(), super.unsubscribe() } } let Vv = (() => { class t { constructor(t) { this.http = t } login(t, e) { return console.log("[LOGIN QUERY]"), this.http.post("https://perfume-dz.herokuapp.com/users/login/", { email: t, password: e }).pipe(H(t => (console.log(t), t))) } addTransaction(t, e) { return this.http.post("https://perfume-dz.herokuapp.com/users/" + e + "/transactions", t).pipe(H(t => (console.log(t), t))).toPromise() } deleteClient(t) { return this.http.delete("https://perfume-dz.herokuapp.com/users/" + t).pipe(H(t => (console.log(t), t))) } getClients() { return console.log("[GET ANOMALIES QUERY]"), this.http.get("https://perfume-dz.herokuapp.com/users/", { params: { filter: '\n    {\n      "include": [\n        {\n          "relation": "transactions"\n        }\n      ]\n    }\n    ' } }).pipe(H(t => (console.log(t), t))) } addClient(t) { return console.log("[ADD ANOMALY QUERY]"), this.http.post("https://perfume-dz.herokuapp.com/users/", t).pipe(Ra(t => (console.log(t), null))).toPromise() } } return t.ngInjectableDef = ft({ factory: function () { return new t(Nt(Iy)) }, token: t, providedIn: "root" }), t })(), zv = (() => { class t { constructor(t, e) { this.http = t, this.router = e, this.JWT_TOKEN = "JWT_TOKEN", this.REFRESH_TOKEN = "REFRESH_TOKEN" } login(t, e) { return this.http.login(t, e).pipe(Sa(e => this.doLoginUser(t, e)), (n = { success: !0, message: "" }, t => t.lift(new wv(n))), Ra(t => (console.log(t.error), oa(422 === t.status ? { success: !1, message: "Mail or password incorrect" } : { success: !1, message: "UNKNOWN ERROR !" })))); var n } AddAnomaly() { return oa("https://perfume-dz.herokuapp.com/").pipe(ma(t => !!t), H(t => t.replace(/^https/, "wss") + "?token=" + this.getJwtToken()), Ua(t => (this.connection$ || (this.connection$ = new Lv(t)), this.connection$)), (t = t => t.pipe(function (t, e = bp) { var n; const i = (n = t) instanceof Date && !isNaN(+n) ? +t - e.now() : Math.abs(t); return t => t.lift(new Tv(i, e)) }(this.RETRY_SECONDS)), e => e.lift(new Sv(t, e)))); var t } logout() { return yv(this, void 0, void 0, (function* () { return this.router.navigate([""]), this.doLogoutUser(), !0 })) } isLoggedIn() { return !!this.getJwtToken() } getJwtToken() { return localStorage.getItem(this.JWT_TOKEN) } doLoginUser(t, e) { this.loggedUser = t, this.storeTokens(e.token, null) } doLogoutUser() { this.loggedUser = null, this.removeTokens() } getRefreshToken() { return localStorage.getItem(this.REFRESH_TOKEN) } storeJwtToken(t) { localStorage.setItem(this.JWT_TOKEN, t), console.log("[new JWT]" + t) } storeTokens(t, e) { localStorage.setItem(this.JWT_TOKEN, t), localStorage.setItem(this.REFRESH_TOKEN, e) } removeTokens() { localStorage.removeItem(this.JWT_TOKEN), localStorage.removeItem(this.REFRESH_TOKEN) } } return t.ngInjectableDef = ft({ factory: function () { return new t(Nt(Vv), Nt(bd)) }, token: t, providedIn: "root" }), t })(); function jv() { throw Error("Host already has a portal attached") } class Uv { attach(t) { return null == t && function () { throw Error("Attempting to attach a portal to a null PortalOutlet") }(), t.hasAttached() && jv(), this._attachedHost = t, t.attach(this) } detach() { let t = this._attachedHost; null == t ? function () { throw Error("Attempting to detach a portal that is not attached to a host") }() : (this._attachedHost = null, t.detach()) } get isAttached() { return null != this._attachedHost } setAttachedHost(t) { this._attachedHost = t } } class Hv extends Uv { constructor(t, e, n, i) { super(), this.component = t, this.viewContainerRef = e, this.injector = n, this.componentFactoryResolver = i } } class Bv extends Uv { constructor(t, e, n) { super(), this.templateRef = t, this.viewContainerRef = e, this.context = n } get origin() { return this.templateRef.elementRef } attach(t, e = this.context) { return this.context = e, super.attach(t) } detach() { return this.context = void 0, super.detach() } } class $v { constructor() { this._isDisposed = !1 } hasAttached() { return !!this._attachedPortal } attach(t) { return t || function () { throw Error("Must provide a portal to attach") }(), this.hasAttached() && jv(), this._isDisposed && function () { throw Error("This PortalOutlet has already been disposed") }(), t instanceof Hv ? (this._attachedPortal = t, this.attachComponentPortal(t)) : t instanceof Bv ? (this._attachedPortal = t, this.attachTemplatePortal(t)) : void function () { throw Error("Attempting to attach an unknown Portal type. BasePortalOutlet accepts either a ComponentPortal or a TemplatePortal.") }() } detach() { this._attachedPortal && (this._attachedPortal.setAttachedHost(null), this._attachedPortal = null), this._invokeDisposeFn() } dispose() { this.hasAttached() && this.detach(), this._invokeDisposeFn(), this._isDisposed = !0 } setDisposeFn(t) { this._disposeFn = t } _invokeDisposeFn() { this._disposeFn && (this._disposeFn(), this._disposeFn = null) } } class Wv extends $v { constructor(t, e, n, i) { super(), this.outletElement = t, this._componentFactoryResolver = e, this._appRef = n, this._defaultInjector = i } attachComponentPortal(t) { const e = (t.componentFactoryResolver || this._componentFactoryResolver).resolveComponentFactory(t.component); let n; return t.viewContainerRef ? (n = t.viewContainerRef.createComponent(e, t.viewContainerRef.length, t.injector || t.viewContainerRef.injector), this.setDisposeFn(() => n.destroy())) : (n = e.create(t.injector || this._defaultInjector), this._appRef.attachView(n.hostView), this.setDisposeFn(() => { this._appRef.detachView(n.hostView), n.destroy() })), this.outletElement.appendChild(this._getComponentRootNode(n)), n } attachTemplatePortal(t) { let e = t.viewContainerRef, n = e.createEmbeddedView(t.templateRef, t.context); return n.detectChanges(), n.rootNodes.forEach(t => this.outletElement.appendChild(t)), this.setDisposeFn(() => { let t = e.indexOf(n); -1 !== t && e.remove(t) }), n } dispose() { super.dispose(), null != this.outletElement.parentNode && this.outletElement.parentNode.removeChild(this.outletElement) } _getComponentRootNode(t) { return t.hostView.rootNodes[0] } } let qv = (() => class extends $v { constructor(t, e) { super(), this._componentFactoryResolver = t, this._viewContainerRef = e, this._isInitialized = !1, this.attached = new vr } get portal() { return this._attachedPortal } set portal(t) { (!this.hasAttached() || t || this._isInitialized) && (this.hasAttached() && super.detach(), t && super.attach(t), this._attachedPortal = t) } get attachedRef() { return this._attachedRef } ngOnInit() { this._isInitialized = !0 } ngOnDestroy() { super.dispose(), this._attachedPortal = null, this._attachedRef = null } attachComponentPortal(t) { t.setAttachedHost(this); const e = null != t.viewContainerRef ? t.viewContainerRef : this._viewContainerRef, n = (t.componentFactoryResolver || this._componentFactoryResolver).resolveComponentFactory(t.component), i = e.createComponent(n, e.length, t.injector || e.injector); return super.setDisposeFn(() => i.destroy()), this._attachedPortal = t, this._attachedRef = i, this.attached.emit(i), i } attachTemplatePortal(t) { t.setAttachedHost(this); const e = this._viewContainerRef.createEmbeddedView(t.templateRef, t.context); return super.setDisposeFn(() => this._viewContainerRef.clear()), this._attachedPortal = t, this._attachedRef = e, this.attached.emit(e), e } })(), Gv = (() => class { })(); class Zv { constructor(t, e) { this._parentInjector = t, this._customTokens = e } get(t, e) { const n = this._customTokens.get(t); return void 0 !== n ? n : this._parentInjector.get(t, e) } } let Qv = (() => { class t { constructor(t, e) { this._ngZone = t, this._platform = e, this._scrolled = new k, this._globalSubscription = null, this._scrolledCount = 0, this.scrollContainers = new Map } register(t) { this.scrollContainers.has(t) || this.scrollContainers.set(t, t.elementScrolled().subscribe(() => this._scrolled.next(t))) } deregister(t) { const e = this.scrollContainers.get(t); e && (e.unsubscribe(), this.scrollContainers.delete(t)) } scrolled(t = 20) { return this._platform.isBrowser ? new w(e => { this._globalSubscription || this._addGlobalListener(); const n = t > 0 ? this._scrolled.pipe(ry(t)).subscribe(e) : this._scrolled.subscribe(e); return this._scrolledCount++, () => { n.unsubscribe(), this._scrolledCount--, this._scrolledCount || this._removeGlobalListener() } }) : oa() } ngOnDestroy() { this._removeGlobalListener(), this.scrollContainers.forEach((t, e) => this.deregister(e)), this._scrolled.complete() } ancestorScrolled(t, e) { const n = this.getAncestorScrollContainers(t); return this.scrolled(e).pipe(ma(t => !t || n.indexOf(t) > -1)) } getAncestorScrollContainers(t) { const e = []; return this.scrollContainers.forEach((n, i) => { this._scrollableContainsElement(i, t) && e.push(i) }), e } _scrollableContainsElement(t, e) { let n = e.nativeElement, i = t.getElementRef().nativeElement; do { if (n == i) return !0 } while (n = n.parentElement); return !1 } _addGlobalListener() { this._globalSubscription = this._ngZone.runOutsideAngular(() => Kp(window.document, "scroll").subscribe(() => this._scrolled.next())) } _removeGlobalListener() { this._globalSubscription && (this._globalSubscription.unsubscribe(), this._globalSubscription = null) } } return t.ngInjectableDef = ft({ factory: function () { return new t(Nt(Zr), Nt(up)) }, token: t, providedIn: "root" }), t })(), Kv = (() => class { })(), Yv = (() => { class t { constructor(t, e) { this._platform = t, e.runOutsideAngular(() => { this._change = t.isBrowser ? X(Kp(window, "resize"), Kp(window, "orientationchange")) : oa(), this._invalidateCache = this.change().subscribe(() => this._updateViewportSize()) }) } ngOnDestroy() { this._invalidateCache.unsubscribe() } getViewportSize() { this._viewportSize || this._updateViewportSize(); const t = { width: this._viewportSize.width, height: this._viewportSize.height }; return this._platform.isBrowser || (this._viewportSize = null), t } getViewportRect() { const t = this.getViewportScrollPosition(), { width: e, height: n } = this.getViewportSize(); return { top: t.top, left: t.left, bottom: t.top + n, right: t.left + e, height: n, width: e } } getViewportScrollPosition() { if (!this._platform.isBrowser) return { top: 0, left: 0 }; const t = document.documentElement, e = t.getBoundingClientRect(); return { top: -e.top || document.body.scrollTop || window.scrollY || t.scrollTop || 0, left: -e.left || document.body.scrollLeft || window.scrollX || t.scrollLeft || 0 } } change(t = 20) { return t > 0 ? this._change.pipe(ry(t)) : this._change } _updateViewportSize() { this._viewportSize = this._platform.isBrowser ? { width: window.innerWidth, height: window.innerHeight } : { width: 0, height: 0 } } } return t.ngInjectableDef = ft({ factory: function () { return new t(Nt(up), Nt(Zr)) }, token: t, providedIn: "root" }), t })(); class Xv { constructor(t, e) { this._viewportRuler = t, this._previousHTMLStyles = { top: "", left: "" }, this._isEnabled = !1, this._document = e } attach() { } enable() { if (this._canBeEnabled()) { const t = this._document.documentElement; this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition(), this._previousHTMLStyles.left = t.style.left || "", this._previousHTMLStyles.top = t.style.top || "", t.style.left = sp(-this._previousScrollPosition.left), t.style.top = sp(-this._previousScrollPosition.top), t.classList.add("cdk-global-scrollblock"), this._isEnabled = !0 } } disable() { if (this._isEnabled) { const t = this._document.documentElement, e = t.style, n = this._document.body.style, i = e.scrollBehavior || "", r = n.scrollBehavior || ""; this._isEnabled = !1, e.left = this._previousHTMLStyles.left, e.top = this._previousHTMLStyles.top, t.classList.remove("cdk-global-scrollblock"), e.scrollBehavior = n.scrollBehavior = "auto", window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top), e.scrollBehavior = i, n.scrollBehavior = r } } _canBeEnabled() { if (this._document.documentElement.classList.contains("cdk-global-scrollblock") || this._isEnabled) return !1; const t = this._document.body, e = this._viewportRuler.getViewportSize(); return t.scrollHeight > e.height || t.scrollWidth > e.width } } function Jv() { return Error("Scroll strategy has already been attached.") } class tb { constructor(t, e, n, i) { this._scrollDispatcher = t, this._ngZone = e, this._viewportRuler = n, this._config = i, this._scrollSubscription = null, this._detach = () => { this.disable(), this._overlayRef.hasAttached() && this._ngZone.run(() => this._overlayRef.detach()) } } attach(t) { if (this._overlayRef) throw Jv(); this._overlayRef = t } enable() { if (this._scrollSubscription) return; const t = this._scrollDispatcher.scrolled(0); this._config && this._config.threshold && this._config.threshold > 1 ? (this._initialScrollPosition = this._viewportRuler.getViewportScrollPosition().top, this._scrollSubscription = t.subscribe(() => { const t = this._viewportRuler.getViewportScrollPosition().top; Math.abs(t - this._initialScrollPosition) > this._config.threshold ? this._detach() : this._overlayRef.updatePosition() })) : this._scrollSubscription = t.subscribe(this._detach) } disable() { this._scrollSubscription && (this._scrollSubscription.unsubscribe(), this._scrollSubscription = null) } detach() { this.disable(), this._overlayRef = null } } class eb { enable() { } disable() { } attach() { } } function nb(t, e) { return e.some(e => t.bottom < e.top || t.top > e.bottom || t.right < e.left || t.left > e.right) } function ib(t, e) { return e.some(e => t.top < e.top || t.bottom > e.bottom || t.left < e.left || t.right > e.right) } class rb { constructor(t, e, n, i) { this._scrollDispatcher = t, this._viewportRuler = e, this._ngZone = n, this._config = i, this._scrollSubscription = null } attach(t) { if (this._overlayRef) throw Jv(); this._overlayRef = t } enable() { this._scrollSubscription || (this._scrollSubscription = this._scrollDispatcher.scrolled(this._config ? this._config.scrollThrottle : 0).subscribe(() => { if (this._overlayRef.updatePosition(), this._config && this._config.autoClose) { const t = this._overlayRef.overlayElement.getBoundingClientRect(), { width: e, height: n } = this._viewportRuler.getViewportSize(); nb(t, [{ width: e, height: n, bottom: n, right: e, top: 0, left: 0 }]) && (this.disable(), this._ngZone.run(() => this._overlayRef.detach())) } })) } disable() { this._scrollSubscription && (this._scrollSubscription.unsubscribe(), this._scrollSubscription = null) } detach() { this.disable(), this._overlayRef = null } } let sb = (() => { class t { constructor(t, e, n, i) { this._scrollDispatcher = t, this._viewportRuler = e, this._ngZone = n, this.noop = () => new eb, this.close = t => new tb(this._scrollDispatcher, this._ngZone, this._viewportRuler, t), this.block = () => new Xv(this._viewportRuler, this._document), this.reposition = t => new rb(this._scrollDispatcher, this._viewportRuler, this._ngZone, t), this._document = i } } return t.ngInjectableDef = ft({ factory: function () { return new t(Nt(Qv), Nt(Yv), Nt(Zr), Nt(ta)) }, token: t, providedIn: "root" }), t })(); class ob { constructor(t) { if (this.scrollStrategy = new eb, this.panelClass = "", this.hasBackdrop = !1, this.backdropClass = "cdk-overlay-dark-backdrop", this.disposeOnNavigation = !1, t) { const e = Object.keys(t); for (const n of e) void 0 !== t[n] && (this[n] = t[n]) } } } class lb { constructor(t, e, n, i, r) { this.offsetX = n, this.offsetY = i, this.panelClass = r, this.originX = t.originX, this.originY = t.originY, this.overlayX = e.overlayX, this.overlayY = e.overlayY } } let ab = (() => class { constructor(t, e) { this.connectionPair = t, this.scrollableViewProperties = e } })(); function cb(t, e) { if ("top" !== e && "bottom" !== e && "center" !== e) throw Error(`ConnectedPosition: Invalid ${t} "${e}". Expected "top", "bottom" or "center".`) } function ub(t, e) { if ("start" !== e && "end" !== e && "center" !== e) throw Error(`ConnectedPosition: Invalid ${t} "${e}". Expected "start", "end" or "center".`) } let hb = (() => { class t { constructor(t) { this._attachedOverlays = [], this._keydownListener = t => { const e = this._attachedOverlays; for (let n = e.length - 1; n > -1; n--)if (e[n]._keydownEventSubscriptions > 0) { e[n]._keydownEvents.next(t); break } }, this._document = t } ngOnDestroy() { this._detach() } add(t) { this.remove(t), this._isAttached || (this._document.body.addEventListener("keydown", this._keydownListener), this._isAttached = !0), this._attachedOverlays.push(t) } remove(t) { const e = this._attachedOverlays.indexOf(t); e > -1 && this._attachedOverlays.splice(e, 1), 0 === this._attachedOverlays.length && this._detach() } _detach() { this._isAttached && (this._document.body.removeEventListener("keydown", this._keydownListener), this._isAttached = !1) } } return t.ngInjectableDef = ft({ factory: function () { return new t(Nt(ta)) }, token: t, providedIn: "root" }), t })(), db = (() => { class t { constructor(t) { this._document = t } ngOnDestroy() { this._containerElement && this._containerElement.parentNode && this._containerElement.parentNode.removeChild(this._containerElement) } getContainerElement() { return this._containerElement || this._createContainer(), this._containerElement } _createContainer() { const t = this._document.getElementsByClassName("cdk-overlay-container"); for (let n = 0; n < t.length; n++)t[n].parentNode.removeChild(t[n]); const e = this._document.createElement("div"); e.classList.add("cdk-overlay-container"), this._document.body.appendChild(e), this._containerElement = e } } return t.ngInjectableDef = ft({ factory: function () { return new t(Nt(ta)) }, token: t, providedIn: "root" }), t })(); class pb { constructor(t, e, n, i, r, s, o, l) { this._portalOutlet = t, this._host = e, this._pane = n, this._config = i, this._ngZone = r, this._keyboardDispatcher = s, this._document = o, this._location = l, this._backdropElement = null, this._backdropClick = new k, this._attachments = new k, this._detachments = new k, this._locationChanges = d.EMPTY, this._backdropClickHandler = t => this._backdropClick.next(t), this._keydownEventsObservable = new w(t => { const e = this._keydownEvents.subscribe(t); return this._keydownEventSubscriptions++, () => { e.unsubscribe(), this._keydownEventSubscriptions-- } }), this._keydownEvents = new k, this._keydownEventSubscriptions = 0, i.scrollStrategy && (this._scrollStrategy = i.scrollStrategy, this._scrollStrategy.attach(this)), this._positionStrategy = i.positionStrategy } get overlayElement() { return this._pane } get backdropElement() { return this._backdropElement } get hostElement() { return this._host } attach(t) { let e = this._portalOutlet.attach(t); return this._positionStrategy && this._positionStrategy.attach(this), !this._host.parentElement && this._previousHostParent && this._previousHostParent.appendChild(this._host), this._updateStackingOrder(), this._updateElementSize(), this._updateElementDirection(), this._scrollStrategy && this._scrollStrategy.enable(), this._ngZone.onStable.asObservable().pipe(Da(1)).subscribe(() => { this.hasAttached() && this.updatePosition() }), this._togglePointerEvents(!0), this._config.hasBackdrop && this._attachBackdrop(), this._config.panelClass && this._toggleClasses(this._pane, this._config.panelClass, !0), this._attachments.next(), this._keyboardDispatcher.add(this), this._config.disposeOnNavigation && this._location && (this._locationChanges = this._location.subscribe(() => this.dispose())), e } detach() { if (!this.hasAttached()) return; this.detachBackdrop(), this._togglePointerEvents(!1), this._positionStrategy && this._positionStrategy.detach && this._positionStrategy.detach(), this._scrollStrategy && this._scrollStrategy.disable(); const t = this._portalOutlet.detach(); return this._detachments.next(), this._keyboardDispatcher.remove(this), this._detachContentWhenStable(), this._locationChanges.unsubscribe(), t } dispose() { const t = this.hasAttached(); this._positionStrategy && this._positionStrategy.dispose(), this._disposeScrollStrategy(), this.detachBackdrop(), this._locationChanges.unsubscribe(), this._keyboardDispatcher.remove(this), this._portalOutlet.dispose(), this._attachments.complete(), this._backdropClick.complete(), this._keydownEvents.complete(), this._host && this._host.parentNode && (this._host.parentNode.removeChild(this._host), this._host = null), this._previousHostParent = this._pane = null, t && this._detachments.next(), this._detachments.complete() } hasAttached() { return this._portalOutlet.hasAttached() } backdropClick() { return this._backdropClick.asObservable() } attachments() { return this._attachments.asObservable() } detachments() { return this._detachments.asObservable() } keydownEvents() { return this._keydownEventsObservable } getConfig() { return this._config } updatePosition() { this._positionStrategy && this._positionStrategy.apply() } updatePositionStrategy(t) { t !== this._positionStrategy && (this._positionStrategy && this._positionStrategy.dispose(), this._positionStrategy = t, this.hasAttached() && (t.attach(this), this.updatePosition())) } updateSize(t) { this._config = Object.assign({}, this._config, t), this._updateElementSize() } setDirection(t) { this._config = Object.assign({}, this._config, { direction: t }), this._updateElementDirection() } addPanelClass(t) { this._pane && this._toggleClasses(this._pane, t, !0) } removePanelClass(t) { this._pane && this._toggleClasses(this._pane, t, !1) } getDirection() { const t = this._config.direction; return t ? "string" == typeof t ? t : t.value : "ltr" } updateScrollStrategy(t) { t !== this._scrollStrategy && (this._disposeScrollStrategy(), this._scrollStrategy = t, this.hasAttached() && (t.attach(this), t.enable())) } _updateElementDirection() { this._host.setAttribute("dir", this.getDirection()) } _updateElementSize() { if (!this._pane) return; const t = this._pane.style; t.width = sp(this._config.width), t.height = sp(this._config.height), t.minWidth = sp(this._config.minWidth), t.minHeight = sp(this._config.minHeight), t.maxWidth = sp(this._config.maxWidth), t.maxHeight = sp(this._config.maxHeight) } _togglePointerEvents(t) { this._pane.style.pointerEvents = t ? "auto" : "none" } _attachBackdrop() { this._backdropElement = this._document.createElement("div"), this._backdropElement.classList.add("cdk-overlay-backdrop"), this._config.backdropClass && this._toggleClasses(this._backdropElement, this._config.backdropClass, !0), this._host.parentElement.insertBefore(this._backdropElement, this._host), this._backdropElement.addEventListener("click", this._backdropClickHandler), "undefined" != typeof requestAnimationFrame ? this._ngZone.runOutsideAngular(() => { requestAnimationFrame(() => { this._backdropElement && this._backdropElement.classList.add("cdk-overlay-backdrop-showing") }) }) : this._backdropElement.classList.add("cdk-overlay-backdrop-showing") } _updateStackingOrder() { this._host.nextSibling && this._host.parentNode.appendChild(this._host) } detachBackdrop() { let t, e = this._backdropElement; if (!e) return; let n = () => { e && (e.removeEventListener("click", this._backdropClickHandler), e.removeEventListener("transitionend", n), e.parentNode && e.parentNode.removeChild(e)), this._backdropElement == e && (this._backdropElement = null), this._config.backdropClass && this._toggleClasses(e, this._config.backdropClass, !1), clearTimeout(t) }; e.classList.remove("cdk-overlay-backdrop-showing"), this._ngZone.runOutsideAngular(() => { e.addEventListener("transitionend", n) }), e.style.pointerEvents = "none", t = this._ngZone.runOutsideAngular(() => setTimeout(n, 500)) } _toggleClasses(t, e, n) { const i = t.classList; rp(e).forEach(t => { t && (n ? i.add(t) : i.remove(t)) }) } _detachContentWhenStable() { this._ngZone.runOutsideAngular(() => { const t = this._ngZone.onStable.asObservable().pipe(Yp(X(this._attachments, this._detachments))).subscribe(() => { this._pane && this._host && 0 !== this._pane.children.length || (this._pane && this._config.panelClass && this._toggleClasses(this._pane, this._config.panelClass, !1), this._host && this._host.parentElement && (this._previousHostParent = this._host.parentElement, this._previousHostParent.removeChild(this._host)), t.unsubscribe()) }) }) } _disposeScrollStrategy() { const t = this._scrollStrategy; t && (t.disable(), t.detach && t.detach()) } } class fb { constructor(t, e, n, i, r) { this._viewportRuler = e, this._document = n, this._platform = i, this._overlayContainer = r, this._lastBoundingBoxSize = { width: 0, height: 0 }, this._isPushed = !1, this._canPush = !0, this._growAfterOpen = !1, this._hasFlexibleDimensions = !0, this._positionLocked = !1, this._viewportMargin = 0, this._scrollables = [], this._preferredPositions = [], this._positionChanges = new k, this._resizeSubscription = d.EMPTY, this._offsetX = 0, this._offsetY = 0, this._appliedPanelClasses = [], this.positionChanges = this._positionChanges.asObservable(), this.setOrigin(t) } get positions() { return this._preferredPositions } attach(t) { if (this._overlayRef && t !== this._overlayRef) throw Error("This position strategy is already attached to an overlay"); this._validatePositions(), t.hostElement.classList.add("cdk-overlay-connected-position-bounding-box"), this._overlayRef = t, this._boundingBox = t.hostElement, this._pane = t.overlayElement, this._isDisposed = !1, this._isInitialRender = !0, this._lastPosition = null, this._resizeSubscription.unsubscribe(), this._resizeSubscription = this._viewportRuler.change().subscribe(() => { this._isInitialRender = !0, this.apply() }) } apply() { if (this._isDisposed || !this._platform.isBrowser) return; if (!this._isInitialRender && this._positionLocked && this._lastPosition) return void this.reapplyLastPosition(); this._clearPanelClasses(), this._resetOverlayElementStyles(), this._resetBoundingBoxStyles(), this._viewportRect = this._getNarrowedViewportRect(), this._originRect = this._getOriginRect(), this._overlayRect = this._pane.getBoundingClientRect(); const t = this._originRect, e = this._overlayRect, n = this._viewportRect, i = []; let r; for (let s of this._preferredPositions) { let o = this._getOriginPoint(t, s), l = this._getOverlayPoint(o, e, s), a = this._getOverlayFit(l, e, n, s); if (a.isCompletelyWithinViewport) return this._isPushed = !1, void this._applyPosition(s, o); this._canFitWithFlexibleDimensions(a, l, n) ? i.push({ position: s, origin: o, overlayRect: e, boundingBoxRect: this._calculateBoundingBoxRect(o, s) }) : (!r || r.overlayFit.visibleArea < a.visibleArea) && (r = { overlayFit: a, overlayPoint: l, originPoint: o, position: s, overlayRect: e }) } if (i.length) { let t = null, e = -1; for (const n of i) { const i = n.boundingBoxRect.width * n.boundingBoxRect.height * (n.position.weight || 1); i > e && (e = i, t = n) } return this._isPushed = !1, void this._applyPosition(t.position, t.origin) } if (this._canPush) return this._isPushed = !0, void this._applyPosition(r.position, r.originPoint); this._applyPosition(r.position, r.originPoint) } detach() { this._clearPanelClasses(), this._lastPosition = null, this._previousPushAmount = null, this._resizeSubscription.unsubscribe() } dispose() { this._isDisposed || (this._boundingBox && mb(this._boundingBox.style, { top: "", left: "", right: "", bottom: "", height: "", width: "", alignItems: "", justifyContent: "" }), this._pane && this._resetOverlayElementStyles(), this._overlayRef && this._overlayRef.hostElement.classList.remove("cdk-overlay-connected-position-bounding-box"), this.detach(), this._positionChanges.complete(), this._overlayRef = this._boundingBox = null, this._isDisposed = !0) } reapplyLastPosition() { if (!this._isDisposed && (!this._platform || this._platform.isBrowser)) { this._originRect = this._getOriginRect(), this._overlayRect = this._pane.getBoundingClientRect(), this._viewportRect = this._getNarrowedViewportRect(); const t = this._lastPosition || this._preferredPositions[0], e = this._getOriginPoint(this._originRect, t); this._applyPosition(t, e) } } withScrollableContainers(t) { return this._scrollables = t, this } withPositions(t) { return this._preferredPositions = t, -1 === t.indexOf(this._lastPosition) && (this._lastPosition = null), this._validatePositions(), this } withViewportMargin(t) { return this._viewportMargin = t, this } withFlexibleDimensions(t = !0) { return this._hasFlexibleDimensions = t, this } withGrowAfterOpen(t = !0) { return this._growAfterOpen = t, this } withPush(t = !0) { return this._canPush = t, this } withLockedPosition(t = !0) { return this._positionLocked = t, this } setOrigin(t) { return this._origin = t, this } withDefaultOffsetX(t) { return this._offsetX = t, this } withDefaultOffsetY(t) { return this._offsetY = t, this } withTransformOriginOn(t) { return this._transformOriginSelector = t, this } _getOriginPoint(t, e) { let n, i; if ("center" == e.originX) n = t.left + t.width / 2; else { const i = this._isRtl() ? t.right : t.left, r = this._isRtl() ? t.left : t.right; n = "start" == e.originX ? i : r } return i = "center" == e.originY ? t.top + t.height / 2 : "top" == e.originY ? t.top : t.bottom, { x: n, y: i } } _getOverlayPoint(t, e, n) { let i, r; return i = "center" == n.overlayX ? -e.width / 2 : "start" === n.overlayX ? this._isRtl() ? -e.width : 0 : this._isRtl() ? 0 : -e.width, r = "center" == n.overlayY ? -e.height / 2 : "top" == n.overlayY ? 0 : -e.height, { x: t.x + i, y: t.y + r } } _getOverlayFit(t, e, n, i) { let { x: r, y: s } = t, o = this._getOffset(i, "x"), l = this._getOffset(i, "y"); o && (r += o), l && (s += l); let a = 0 - s, c = s + e.height - n.height, u = this._subtractOverflows(e.width, 0 - r, r + e.width - n.width), h = this._subtractOverflows(e.height, a, c), d = u * h; return { visibleArea: d, isCompletelyWithinViewport: e.width * e.height === d, fitsInViewportVertically: h === e.height, fitsInViewportHorizontally: u == e.width } } _canFitWithFlexibleDimensions(t, e, n) { if (this._hasFlexibleDimensions) { const i = n.bottom - e.y, r = n.right - e.x, s = this._overlayRef.getConfig().minHeight, o = this._overlayRef.getConfig().minWidth, l = t.fitsInViewportHorizontally || null != o && o <= r; return (t.fitsInViewportVertically || null != s && s <= i) && l } return !1 } _pushOverlayOnScreen(t, e, n) { if (this._previousPushAmount && this._positionLocked) return { x: t.x + this._previousPushAmount.x, y: t.y + this._previousPushAmount.y }; const i = this._viewportRect, r = Math.max(t.x + e.width - i.right, 0), s = Math.max(t.y + e.height - i.bottom, 0), o = Math.max(i.top - n.top - t.y, 0), l = Math.max(i.left - n.left - t.x, 0); let a = 0, c = 0; return a = e.width <= i.width ? l || -r : t.x < this._viewportMargin ? i.left - n.left - t.x : 0, c = e.height <= i.height ? o || -s : t.y < this._viewportMargin ? i.top - n.top - t.y : 0, this._previousPushAmount = { x: a, y: c }, { x: t.x + a, y: t.y + c } } _applyPosition(t, e) { if (this._setTransformOrigin(t), this._setOverlayElementStyles(e, t), this._setBoundingBoxStyles(e, t), t.panelClass && this._addPanelClasses(t.panelClass), this._lastPosition = t, this._positionChanges.observers.length) { const e = this._getScrollVisibility(), n = new ab(t, e); this._positionChanges.next(n) } this._isInitialRender = !1 } _setTransformOrigin(t) { if (!this._transformOriginSelector) return; const e = this._boundingBox.querySelectorAll(this._transformOriginSelector); let n, i = t.overlayY; n = "center" === t.overlayX ? "center" : this._isRtl() ? "start" === t.overlayX ? "right" : "left" : "start" === t.overlayX ? "left" : "right"; for (let r = 0; r < e.length; r++)e[r].style.transformOrigin = `${n} ${i}` } _calculateBoundingBoxRect(t, e) { const n = this._viewportRect, i = this._isRtl(); let r, s, o, l, a, c; if ("top" === e.overlayY) s = t.y, r = n.height - s + this._viewportMargin; else if ("bottom" === e.overlayY) o = n.height - t.y + 2 * this._viewportMargin, r = n.height - o + this._viewportMargin; else { const e = Math.min(n.bottom - t.y + n.top, t.y), i = this._lastBoundingBoxSize.height; r = 2 * e, s = t.y - e, r > i && !this._isInitialRender && !this._growAfterOpen && (s = t.y - i / 2) } if ("end" === e.overlayX && !i || "start" === e.overlayX && i) c = n.width - t.x + this._viewportMargin, l = t.x - this._viewportMargin; else if ("start" === e.overlayX && !i || "end" === e.overlayX && i) a = t.x, l = n.right - t.x; else { const e = Math.min(n.right - t.x + n.left, t.x), i = this._lastBoundingBoxSize.width; l = 2 * e, a = t.x - e, l > i && !this._isInitialRender && !this._growAfterOpen && (a = t.x - i / 2) } return { top: s, left: a, bottom: o, right: c, width: l, height: r } } _setBoundingBoxStyles(t, e) { const n = this._calculateBoundingBoxRect(t, e); this._isInitialRender || this._growAfterOpen || (n.height = Math.min(n.height, this._lastBoundingBoxSize.height), n.width = Math.min(n.width, this._lastBoundingBoxSize.width)); const i = {}; if (this._hasExactPosition()) i.top = i.left = "0", i.bottom = i.right = "", i.width = i.height = "100%"; else { const t = this._overlayRef.getConfig().maxHeight, r = this._overlayRef.getConfig().maxWidth; i.height = sp(n.height), i.top = sp(n.top), i.bottom = sp(n.bottom), i.width = sp(n.width), i.left = sp(n.left), i.right = sp(n.right), i.alignItems = "center" === e.overlayX ? "center" : "end" === e.overlayX ? "flex-end" : "flex-start", i.justifyContent = "center" === e.overlayY ? "center" : "bottom" === e.overlayY ? "flex-end" : "flex-start", t && (i.maxHeight = sp(t)), r && (i.maxWidth = sp(r)) } this._lastBoundingBoxSize = n, mb(this._boundingBox.style, i) } _resetBoundingBoxStyles() { mb(this._boundingBox.style, { top: "0", left: "0", right: "0", bottom: "0", height: "", width: "", alignItems: "", justifyContent: "" }) } _resetOverlayElementStyles() { mb(this._pane.style, { top: "", left: "", bottom: "", right: "", position: "", transform: "" }) } _setOverlayElementStyles(t, e) { const n = {}; if (this._hasExactPosition()) { const i = this._viewportRuler.getViewportScrollPosition(); mb(n, this._getExactOverlayY(e, t, i)), mb(n, this._getExactOverlayX(e, t, i)) } else n.position = "static"; let i = "", r = this._getOffset(e, "x"), s = this._getOffset(e, "y"); r && (i += `translateX(${r}px) `), s && (i += `translateY(${s}px)`), n.transform = i.trim(), this._hasFlexibleDimensions && this._overlayRef.getConfig().maxHeight && (n.maxHeight = ""), this._hasFlexibleDimensions && this._overlayRef.getConfig().maxWidth && (n.maxWidth = ""), mb(this._pane.style, n) } _getExactOverlayY(t, e, n) { let i = { top: null, bottom: null }, r = this._getOverlayPoint(e, this._overlayRect, t); this._isPushed && (r = this._pushOverlayOnScreen(r, this._overlayRect, n)); let s = this._overlayContainer.getContainerElement().getBoundingClientRect().top; return r.y -= s, "bottom" === t.overlayY ? i.bottom = this._document.documentElement.clientHeight - (r.y + this._overlayRect.height) + "px" : i.top = sp(r.y), i } _getExactOverlayX(t, e, n) { let i, r = { left: null, right: null }, s = this._getOverlayPoint(e, this._overlayRect, t); return this._isPushed && (s = this._pushOverlayOnScreen(s, this._overlayRect, n)), i = this._isRtl() ? "end" === t.overlayX ? "left" : "right" : "end" === t.overlayX ? "right" : "left", "right" === i ? r.right = this._document.documentElement.clientWidth - (s.x + this._overlayRect.width) + "px" : r.left = sp(s.x), r } _getScrollVisibility() { const t = this._getOriginRect(), e = this._pane.getBoundingClientRect(), n = this._scrollables.map(t => t.getElementRef().nativeElement.getBoundingClientRect()); return { isOriginClipped: ib(t, n), isOriginOutsideView: nb(t, n), isOverlayClipped: ib(e, n), isOverlayOutsideView: nb(e, n) } } _subtractOverflows(t, ...e) { return e.reduce((t, e) => t - Math.max(e, 0), t) } _getNarrowedViewportRect() { const t = this._document.documentElement.clientWidth, e = this._document.documentElement.clientHeight, n = this._viewportRuler.getViewportScrollPosition(); return { top: n.top + this._viewportMargin, left: n.left + this._viewportMargin, right: n.left + t - this._viewportMargin, bottom: n.top + e - this._viewportMargin, width: t - 2 * this._viewportMargin, height: e - 2 * this._viewportMargin } } _isRtl() { return "rtl" === this._overlayRef.getDirection() } _hasExactPosition() { return !this._hasFlexibleDimensions || this._isPushed } _getOffset(t, e) { return "x" === e ? null == t.offsetX ? this._offsetX : t.offsetX : null == t.offsetY ? this._offsetY : t.offsetY } _validatePositions() { if (!this._preferredPositions.length) throw Error("FlexibleConnectedPositionStrategy: At least one position is required."); this._preferredPositions.forEach(t => { ub("originX", t.originX), cb("originY", t.originY), ub("overlayX", t.overlayX), cb("overlayY", t.overlayY) }) } _addPanelClasses(t) { this._pane && rp(t).forEach(t => { "" !== t && -1 === this._appliedPanelClasses.indexOf(t) && (this._appliedPanelClasses.push(t), this._pane.classList.add(t)) }) } _clearPanelClasses() { this._pane && (this._appliedPanelClasses.forEach(t => { this._pane.classList.remove(t) }), this._appliedPanelClasses = []) } _getOriginRect() { const t = this._origin; if (t instanceof Qe) return t.nativeElement.getBoundingClientRect(); if (t instanceof HTMLElement) return t.getBoundingClientRect(); const e = t.width || 0, n = t.height || 0; return { top: t.y, bottom: t.y + n, left: t.x, right: t.x + e, height: n, width: e } } } function mb(t, e) { for (let n in e) e.hasOwnProperty(n) && (t[n] = e[n]); return t } class gb { constructor(t, e, n, i, r, s, o) { this._preferredPositions = [], this._positionStrategy = new fb(n, i, r, s, o).withFlexibleDimensions(!1).withPush(!1).withViewportMargin(0), this.withFallbackPosition(t, e) } get _isRtl() { return "rtl" === this._overlayRef.getDirection() } get onPositionChange() { return this._positionStrategy.positionChanges } get positions() { return this._preferredPositions } attach(t) { this._overlayRef = t, this._positionStrategy.attach(t), this._direction && (t.setDirection(this._direction), this._direction = null) } dispose() { this._positionStrategy.dispose() } detach() { this._positionStrategy.detach() } apply() { this._positionStrategy.apply() } recalculateLastPosition() { this._positionStrategy.reapplyLastPosition() } withScrollableContainers(t) { this._positionStrategy.withScrollableContainers(t) } withFallbackPosition(t, e, n, i) { const r = new lb(t, e, n, i); return this._preferredPositions.push(r), this._positionStrategy.withPositions(this._preferredPositions), this } withDirection(t) { return this._overlayRef ? this._overlayRef.setDirection(t) : this._direction = t, this } withOffsetX(t) { return this._positionStrategy.withDefaultOffsetX(t), this } withOffsetY(t) { return this._positionStrategy.withDefaultOffsetY(t), this } withLockedPosition(t) { return this._positionStrategy.withLockedPosition(t), this } withPositions(t) { return this._preferredPositions = t.slice(), this._positionStrategy.withPositions(this._preferredPositions), this } setOrigin(t) { return this._positionStrategy.setOrigin(t), this } } class _b { constructor() { this._cssPosition = "static", this._topOffset = "", this._bottomOffset = "", this._leftOffset = "", this._rightOffset = "", this._alignItems = "", this._justifyContent = "", this._width = "", this._height = "" } attach(t) { const e = t.getConfig(); this._overlayRef = t, this._width && !e.width && t.updateSize({ width: this._width }), this._height && !e.height && t.updateSize({ height: this._height }), t.hostElement.classList.add("cdk-global-overlay-wrapper"), this._isDisposed = !1 } top(t = "") { return this._bottomOffset = "", this._topOffset = t, this._alignItems = "flex-start", this } left(t = "") { return this._rightOffset = "", this._leftOffset = t, this._justifyContent = "flex-start", this } bottom(t = "") { return this._topOffset = "", this._bottomOffset = t, this._alignItems = "flex-end", this } right(t = "") { return this._leftOffset = "", this._rightOffset = t, this._justifyContent = "flex-end", this } width(t = "") { return this._overlayRef ? this._overlayRef.updateSize({ width: t }) : this._width = t, this } height(t = "") { return this._overlayRef ? this._overlayRef.updateSize({ height: t }) : this._height = t, this } centerHorizontally(t = "") { return this.left(t), this._justifyContent = "center", this } centerVertically(t = "") { return this.top(t), this._alignItems = "center", this } apply() { if (!this._overlayRef || !this._overlayRef.hasAttached()) return; const t = this._overlayRef.overlayElement.style, e = this._overlayRef.hostElement.style, n = this._overlayRef.getConfig(); t.position = this._cssPosition, t.marginLeft = "100%" === n.width ? "0" : this._leftOffset, t.marginTop = "100%" === n.height ? "0" : this._topOffset, t.marginBottom = this._bottomOffset, t.marginRight = this._rightOffset, "100%" === n.width ? e.justifyContent = "flex-start" : "center" === this._justifyContent ? e.justifyContent = "center" : "rtl" === this._overlayRef.getConfig().direction ? "flex-start" === this._justifyContent ? e.justifyContent = "flex-end" : "flex-end" === this._justifyContent && (e.justifyContent = "flex-start") : e.justifyContent = this._justifyContent, e.alignItems = "100%" === n.height ? "flex-start" : this._alignItems } dispose() { if (this._isDisposed || !this._overlayRef) return; const t = this._overlayRef.overlayElement.style, e = this._overlayRef.hostElement, n = e.style; e.classList.remove("cdk-global-overlay-wrapper"), n.justifyContent = n.alignItems = t.marginTop = t.marginBottom = t.marginLeft = t.marginRight = t.position = "", this._overlayRef = null, this._isDisposed = !0 } } let yb = (() => { class t { constructor(t, e, n, i) { this._viewportRuler = t, this._document = e, this._platform = n, this._overlayContainer = i } global() { return new _b } connectedTo(t, e, n) { return new gb(e, n, t, this._viewportRuler, this._document, this._platform, this._overlayContainer) } flexibleConnectedTo(t) { return new fb(t, this._viewportRuler, this._document, this._platform, this._overlayContainer) } } return t.ngInjectableDef = ft({ factory: function () { return new t(Nt(Yv), Nt(ta), Nt(up), Nt(db)) }, token: t, providedIn: "root" }), t })(), vb = 0, bb = (() => class { constructor(t, e, n, i, r, s, o, l, a, c) { this.scrollStrategies = t, this._overlayContainer = e, this._componentFactoryResolver = n, this._positionBuilder = i, this._keyboardDispatcher = r, this._injector = s, this._ngZone = o, this._document = l, this._directionality = a, this._location = c } create(t) { const e = this._createHostElement(), n = this._createPaneElement(e), i = this._createPortalOutlet(n), r = new ob(t); return r.direction = r.direction || this._directionality.value, new pb(i, e, n, r, this._ngZone, this._keyboardDispatcher, this._document, this._location) } position() { return this._positionBuilder } _createPaneElement(t) { const e = this._document.createElement("div"); return e.id = "cdk-overlay-" + vb++, e.classList.add("cdk-overlay-pane"), t.appendChild(e), e } _createHostElement() { const t = this._document.createElement("div"); return this._overlayContainer.getContainerElement().appendChild(t), t } _createPortalOutlet(t) { return this._appRef || (this._appRef = this._injector.get(ds)), new Wv(t, this._componentFactoryResolver, this._appRef, this._injector) } })(); const wb = new Tt("cdk-connected-overlay-scroll-strategy"); function Cb(t) { return () => t.scrollStrategies.reposition() } let Sb = (() => class { })(); class Eb { constructor() { this.role = "dialog", this.panelClass = "", this.hasBackdrop = !0, this.backdropClass = "", this.disableClose = !1, this.width = "", this.height = "", this.maxWidth = "80vw", this.data = null, this.ariaDescribedBy = null, this.ariaLabelledBy = null, this.ariaLabel = null, this.autoFocus = !0, this.restoreFocus = !0, this.closeOnNavigation = !0 } } function xb() { throw Error("Attempting to attach dialog content after content is already attached") } let Tb = (() => class extends $v { constructor(t, e, n, i, r) { super(), this._elementRef = t, this._focusTrapFactory = e, this._changeDetectorRef = n, this._document = i, this._config = r, this._elementFocusedBeforeDialogWasOpened = null, this._state = "enter", this._animationStateChanged = new vr, this._ariaLabelledBy = r.ariaLabelledBy || null } attachComponentPortal(t) { return this._portalOutlet.hasAttached() && xb(), this._savePreviouslyFocusedElement(), this._portalOutlet.attachComponentPortal(t) } attachTemplatePortal(t) { return this._portalOutlet.hasAttached() && xb(), this._savePreviouslyFocusedElement(), this._portalOutlet.attachTemplatePortal(t) } _trapFocus() { const t = this._elementRef.nativeElement; if (this._focusTrap || (this._focusTrap = this._focusTrapFactory.create(t)), this._config.autoFocus) this._focusTrap.focusInitialElementWhenReady(); else { const e = this._document.activeElement; e === t || t.contains(e) || t.focus() } } _restoreFocus() { const t = this._elementFocusedBeforeDialogWasOpened; this._config.restoreFocus && t && "function" == typeof t.focus && t.focus(), this._focusTrap && this._focusTrap.destroy() } _savePreviouslyFocusedElement() { this._document && (this._elementFocusedBeforeDialogWasOpened = this._document.activeElement, this._elementRef.nativeElement.focus && Promise.resolve().then(() => this._elementRef.nativeElement.focus())) } _onAnimationDone(t) { "enter" === t.toState ? this._trapFocus() : "exit" === t.toState && this._restoreFocus(), this._animationStateChanged.emit(t) } _onAnimationStart(t) { this._animationStateChanged.emit(t) } _startExitAnimation() { this._state = "exit", this._changeDetectorRef.markForCheck() } })(), kb = 0; class Pb { constructor(t, e, n, i = "mat-dialog-" + kb++) { this._overlayRef = t, this._containerInstance = e, this.id = i, this.disableClose = this._containerInstance._config.disableClose, this._afterOpened = new k, this._afterClosed = new k, this._beforeClosed = new k, this._state = 0, e._id = i, e._animationStateChanged.pipe(ma(t => "done" === t.phaseName && "enter" === t.toState), Da(1)).subscribe(() => { this._afterOpened.next(), this._afterOpened.complete() }), e._animationStateChanged.pipe(ma(t => "done" === t.phaseName && "exit" === t.toState), Da(1)).subscribe(() => { clearTimeout(this._closeFallbackTimeout), this._overlayRef.dispose() }), t.detachments().subscribe(() => { this._beforeClosed.next(this._result), this._beforeClosed.complete(), this._afterClosed.next(this._result), this._afterClosed.complete(), this.componentInstance = null, this._overlayRef.dispose() }), t.keydownEvents().pipe(ma(t => 27 === t.keyCode && !this.disableClose && !function (t, ...e) { return e.length ? e.some(e => t[e]) : t.altKey || t.shiftKey || t.ctrlKey || t.metaKey }(t))).subscribe(t => { t.preventDefault(), this.close() }) } close(t) { this._result = t, this._containerInstance._animationStateChanged.pipe(ma(t => "start" === t.phaseName), Da(1)).subscribe(e => { this._beforeClosed.next(t), this._beforeClosed.complete(), this._state = 2, this._overlayRef.detachBackdrop(), this._closeFallbackTimeout = setTimeout(() => { this._overlayRef.dispose() }, e.totalTime + 100) }), this._containerInstance._startExitAnimation(), this._state = 1 } afterOpened() { return this._afterOpened.asObservable() } afterClosed() { return this._afterClosed.asObservable() } beforeClosed() { return this._beforeClosed.asObservable() } backdropClick() { return this._overlayRef.backdropClick() } keydownEvents() { return this._overlayRef.keydownEvents() } updatePosition(t) { let e = this._getPositionStrategy(); return t && (t.left || t.right) ? t.left ? e.left(t.left) : e.right(t.right) : e.centerHorizontally(), t && (t.top || t.bottom) ? t.top ? e.top(t.top) : e.bottom(t.bottom) : e.centerVertically(), this._overlayRef.updatePosition(), this } updateSize(t = "", e = "") { return this._getPositionStrategy().width(t).height(e), this._overlayRef.updatePosition(), this } addPanelClass(t) { return this._overlayRef.addPanelClass(t), this } removePanelClass(t) { return this._overlayRef.removePanelClass(t), this } afterOpen() { return this.afterOpened() } beforeClose() { return this.beforeClosed() } getState() { return this._state } _getPositionStrategy() { return this._overlayRef.getConfig().positionStrategy } } const Ob = new Tt("MatDialogData"), Ib = new Tt("mat-dialog-default-options"), Ab = new Tt("mat-dialog-scroll-strategy"); function Rb(t) { return () => t.scrollStrategies.block() } let Nb = (() => class { constructor(t, e, n, i, r, s, o) { this._overlay = t, this._injector = e, this._location = n, this._defaultOptions = i, this._parentDialog = s, this._overlayContainer = o, this._openDialogsAtThisLevel = [], this._afterAllClosedAtThisLevel = new k, this._afterOpenedAtThisLevel = new k, this._ariaHiddenElements = new Map, this.afterAllClosed = pa(() => this.openDialogs.length ? this._afterAllClosed : this._afterAllClosed.pipe($a(void 0))), this._scrollStrategy = r } get openDialogs() { return this._parentDialog ? this._parentDialog.openDialogs : this._openDialogsAtThisLevel } get afterOpened() { return this._parentDialog ? this._parentDialog.afterOpened : this._afterOpenedAtThisLevel } get afterOpen() { return this.afterOpened } get _afterAllClosed() { const t = this._parentDialog; return t ? t._afterAllClosed : this._afterAllClosedAtThisLevel } open(t, e) { if ((e = function (t, e) { return Object.assign({}, e, t) }(e, this._defaultOptions || new Eb)).id && this.getDialogById(e.id)) throw Error(`Dialog with id "${e.id}" exists already. The dialog id must be unique.`); const n = this._createOverlay(e), i = this._attachDialogContainer(n, e), r = this._attachDialogContent(t, i, n, e); return this.openDialogs.length || this._hideNonDialogContentFromAssistiveTechnology(), this.openDialogs.push(r), r.afterClosed().subscribe(() => this._removeOpenDialog(r)), this.afterOpened.next(r), r } closeAll() { this._closeDialogs(this.openDialogs) } getDialogById(t) { return this.openDialogs.find(e => e.id === t) } ngOnDestroy() { this._closeDialogs(this._openDialogsAtThisLevel), this._afterAllClosedAtThisLevel.complete(), this._afterOpenedAtThisLevel.complete() } _createOverlay(t) { const e = this._getOverlayConfig(t); return this._overlay.create(e) } _getOverlayConfig(t) { const e = new ob({ positionStrategy: this._overlay.position().global(), scrollStrategy: t.scrollStrategy || this._scrollStrategy(), panelClass: t.panelClass, hasBackdrop: t.hasBackdrop, direction: t.direction, minWidth: t.minWidth, minHeight: t.minHeight, maxWidth: t.maxWidth, maxHeight: t.maxHeight, disposeOnNavigation: t.closeOnNavigation }); return t.backdropClass && (e.backdropClass = t.backdropClass), e } _attachDialogContainer(t, e) { const n = new Zv(e && e.viewContainerRef && e.viewContainerRef.injector || this._injector, new WeakMap([[Eb, e]])), i = new Hv(Tb, e.viewContainerRef, n, e.componentFactoryResolver); return t.attach(i).instance } _attachDialogContent(t, e, n, i) { const r = new Pb(n, e, this._location, i.id); if (i.hasBackdrop && n.backdropClick().subscribe(() => { r.disableClose || r.close() }), t instanceof Cn) e.attachTemplatePortal(new Bv(t, null, { $implicit: i.data, dialogRef: r })); else { const n = this._createInjector(i, r, e), s = e.attachComponentPortal(new Hv(t, void 0, n)); r.componentInstance = s.instance } return r.updateSize(i.width, i.height).updatePosition(i.position), r } _createInjector(t, e, n) { const i = t && t.viewContainerRef && t.viewContainerRef.injector, r = new WeakMap([[Tb, n], [Ob, t.data], [Pb, e]]); return !t.direction || i && i.get(yf, null) || r.set(yf, { value: t.direction, change: oa() }), new Zv(i || this._injector, r) } _removeOpenDialog(t) { const e = this.openDialogs.indexOf(t); e > -1 && (this.openDialogs.splice(e, 1), this.openDialogs.length || (this._ariaHiddenElements.forEach((t, e) => { t ? e.setAttribute("aria-hidden", t) : e.removeAttribute("aria-hidden") }), this._ariaHiddenElements.clear(), this._afterAllClosed.next())) } _hideNonDialogContentFromAssistiveTechnology() { const t = this._overlayContainer.getContainerElement(); if (t.parentElement) { const e = t.parentElement.children; for (let n = e.length - 1; n > -1; n--) { let i = e[n]; i === t || "SCRIPT" === i.nodeName || "STYLE" === i.nodeName || i.hasAttribute("aria-live") || (this._ariaHiddenElements.set(i, i.getAttribute("aria-hidden")), i.setAttribute("aria-hidden", "true")) } } } _closeDialogs(t) { let e = t.length; for (; e--;)t[e].close() } })(), Mb = 0, Db = (() => class { constructor(t, e, n) { this.dialogRef = t, this._elementRef = e, this._dialog = n, this.type = "button" } ngOnInit() { this.dialogRef || (this.dialogRef = zb(this._elementRef, this._dialog.openDialogs)) } ngOnChanges(t) { const e = t._matDialogClose || t._matDialogCloseResult; e && (this.dialogResult = e.currentValue) } })(), Fb = (() => class { constructor(t, e, n) { this._dialogRef = t, this._elementRef = e, this._dialog = n, this.id = "mat-dialog-title-" + Mb++ } ngOnInit() { this._dialogRef || (this._dialogRef = zb(this._elementRef, this._dialog.openDialogs)), this._dialogRef && Promise.resolve().then(() => { const t = this._dialogRef._containerInstance; t && !t._ariaLabelledBy && (t._ariaLabelledBy = this.id) }) } })(), Lb = (() => class { })(), Vb = (() => class { })(); function zb(t, e) { let n = t.nativeElement.parentElement; for (; n && !n.classList.contains("mat-dialog-container");)n = n.parentElement; return n ? e.find(t => t.id === n.id) : null } let jb = (() => class { })(); var Ub = jn({ encapsulation: 0, styles: [["[_nghost-%COMP%]{display:-webkit-box;display:flex;-webkit-box-align:center;align-items:center;-webkit-box-pack:center;justify-content:center;width:100%;min-height:100vh;overflow:hidden}.login-container[_ngcontent-%COMP%]{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column;-webkit-box-align:center;align-items:center;width:100%;height:-webkit-fit-content;height:-moz-fit-content;height:fit-content;max-width:500px;padding:48px;border-radius:8px}.login-container[_ngcontent-%COMP%]   .logo[_ngcontent-%COMP%]{width:124px}.login-container[_ngcontent-%COMP%]   .input[_ngcontent-%COMP%]{height:100%;width:320px}.login-container[_ngcontent-%COMP%]   .input.login[_ngcontent-%COMP%]{margin-top:18px}.login-container[_ngcontent-%COMP%]   .actions[_ngcontent-%COMP%]{display:-webkit-box;display:flex;-webkit-box-align:baseline;align-items:baseline;-webkit-box-pack:justify;justify-content:space-between;width:320px}.login-container[_ngcontent-%COMP%], .shadow[_ngcontent-%COMP%]{box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12)}"]], data: {} }); function Hb(t) { return Zs(0, [(t()(), Rs(0, 0, null, null, 2, "mat-hint", [["class", "mat-hint"]], [[2, "mat-right", null], [1, "id", 0], [1, "align", 0]], null, null, null, null)), Ki(1, 16384, [[7, 4]], 0, rf, [], null, null), (t()(), Ws(-1, null, ["Hint"]))], null, (function (t, e) { t(e, 0, 0, "end" == Li(e, 1).align, Li(e, 1).id, null) })) } function Bb(t) { return Zs(0, [(t()(), Rs(0, 0, null, null, 2, "mat-hint", [["class", "mat-hint"]], [[2, "mat-right", null], [1, "id", 0], [1, "align", 0]], null, null, null, null)), Ki(1, 16384, [[16, 4]], 0, rf, [], null, null), (t()(), Ws(-1, null, ["Hint"]))], null, (function (t, e) { t(e, 0, 0, "end" == Li(e, 1).align, Li(e, 1).id, null) })) } function $b(t) { return Zs(0, [(t()(), Rs(0, 0, null, null, 67, "div", [["class", "login-container"]], null, null, null, null, null)), (t()(), Rs(1, 0, null, null, 0, "img", [["alt", ""], ["class", "logo"], ["src", "/assets/gavel.svg"]], null, null, null, null, null)), (t()(), Rs(2, 0, null, null, 1, "h2", [], null, null, null, null, null)), (t()(), Ws(-1, null, ["Login to Cipher"])), (t()(), Rs(4, 0, null, null, 27, "mat-form-field", [["appearance", "outline"], ["class", "input login mat-form-field"]], [[2, "mat-form-field-appearance-standard", null], [2, "mat-form-field-appearance-fill", null], [2, "mat-form-field-appearance-outline", null], [2, "mat-form-field-appearance-legacy", null], [2, "mat-form-field-invalid", null], [2, "mat-form-field-can-float", null], [2, "mat-form-field-should-float", null], [2, "mat-form-field-has-label", null], [2, "mat-form-field-hide-placeholder", null], [2, "mat-form-field-disabled", null], [2, "mat-form-field-autofilled", null], [2, "mat-focused", null], [2, "mat-accent", null], [2, "mat-warn", null], [2, "ng-untouched", null], [2, "ng-touched", null], [2, "ng-pristine", null], [2, "ng-dirty", null], [2, "ng-valid", null], [2, "ng-invalid", null], [2, "ng-pending", null], [2, "_mat-animation-noopable", null]], null, null, Wg, Ng)), Ki(5, 7520256, null, 9, hf, [Qe, _n, [2, Qp], [2, yf], [2, uf], up, Zr, [2, Ag]], { appearance: [0, "appearance"] }, null), Ls(603979776, 1, { _controlNonStatic: 0 }), Ls(335544320, 2, { _controlStatic: 0 }), Ls(603979776, 3, { _labelChildNonStatic: 0 }), Ls(335544320, 4, { _labelChildStatic: 0 }), Ls(603979776, 5, { _placeholderChild: 0 }), Ls(603979776, 6, { _errorChildren: 1 }), Ls(603979776, 7, { _hintChildren: 1 }), Ls(603979776, 8, { _prefixChildren: 1 }), Ls(603979776, 9, { _suffixChildren: 1 }), (t()(), Rs(15, 0, null, 3, 2, "mat-label", [], null, null, null, null, null)), Ki(16, 16384, [[3, 4], [4, 4]], 0, sf, [], null, null), (t()(), Ws(-1, null, ["Email"])), (t()(), Rs(18, 0, null, 1, 7, "input", [["class", "mat-input-element mat-form-field-autofill-control"], ["matInput", ""], ["placeholder", "Placeholder"]], [[2, "ng-untouched", null], [2, "ng-touched", null], [2, "ng-pristine", null], [2, "ng-dirty", null], [2, "ng-valid", null], [2, "ng-invalid", null], [2, "ng-pending", null], [2, "mat-input-server", null], [1, "id", 0], [1, "placeholder", 0], [8, "disabled", 0], [8, "required", 0], [1, "readonly", 0], [1, "aria-describedby", 0], [1, "aria-invalid", 0], [1, "aria-required", 0]], [[null, "ngModelChange"], [null, "input"], [null, "blur"], [null, "compositionstart"], [null, "compositionend"], [null, "focus"]], (function (t, e, n) { var i = !0, r = t.component; return "input" === e && (i = !1 !== Li(t, 19)._handleInput(n.target.value) && i), "blur" === e && (i = !1 !== Li(t, 19).onTouched() && i), "compositionstart" === e && (i = !1 !== Li(t, 19)._compositionStart() && i), "compositionend" === e && (i = !1 !== Li(t, 19)._compositionEnd(n.target.value) && i), "blur" === e && (i = !1 !== Li(t, 24)._focusChanged(!1) && i), "focus" === e && (i = !1 !== Li(t, 24)._focusChanged(!0) && i), "input" === e && (i = !1 !== Li(t, 24)._onInput() && i), "ngModelChange" === e && (i = !1 !== (r.username = n) && i), i }), null, null)), Ki(19, 16384, null, 0, Yg, [tn, Qe, [2, Kg]], null, null), Yi(1024, null, Zg, (function (t) { return [t] }), [Yg]), Ki(21, 671744, null, 0, q_, [[8, null], [8, null], [8, null], [6, Zg]], { model: [0, "model"] }, { update: "ngModelChange" }), Yi(2048, null, e_, null, [q_]), Ki(23, 16384, null, 0, n_, [[4, e_]], null, null), Ki(24, 999424, null, 0, dy, [Qe, up, [6, e_], [2, j_], [2, Q_], jp, [8, null], oy, Zr], { placeholder: [0, "placeholder"] }, null), Yi(2048, [[1, 4], [2, 4]], tf, null, [dy]), (t()(), Rs(26, 0, null, 4, 3, "mat-icon", [["class", "mat-icon notranslate"], ["matSuffix", ""], ["role", "img"]], [[2, "mat-icon-inline", null], [2, "mat-icon-no-color", null]], null, null, uv, cv)), Ki(27, 16384, [[9, 4]], 0, of, [], null, null), Ki(28, 9158656, null, 0, lv, [Qe, Xy, [8, null], [2, iv], [2, Te]], null, null), (t()(), Ws(-1, 0, ["sentiment_very_satisfied"])), (t()(), As(16777216, null, 6, 1, null, Hb)), Ki(31, 16384, null, 0, ql, [En, Cn], { ngIf: [0, "ngIf"] }, null), (t()(), Rs(32, 0, null, null, 27, "mat-form-field", [["appearance", "outline"], ["class", "input mat-form-field"]], [[2, "mat-form-field-appearance-standard", null], [2, "mat-form-field-appearance-fill", null], [2, "mat-form-field-appearance-outline", null], [2, "mat-form-field-appearance-legacy", null], [2, "mat-form-field-invalid", null], [2, "mat-form-field-can-float", null], [2, "mat-form-field-should-float", null], [2, "mat-form-field-has-label", null], [2, "mat-form-field-hide-placeholder", null], [2, "mat-form-field-disabled", null], [2, "mat-form-field-autofilled", null], [2, "mat-focused", null], [2, "mat-accent", null], [2, "mat-warn", null], [2, "ng-untouched", null], [2, "ng-touched", null], [2, "ng-pristine", null], [2, "ng-dirty", null], [2, "ng-valid", null], [2, "ng-invalid", null], [2, "ng-pending", null], [2, "_mat-animation-noopable", null]], null, null, Wg, Ng)), Ki(33, 7520256, null, 9, hf, [Qe, _n, [2, Qp], [2, yf], [2, uf], up, Zr, [2, Ag]], { appearance: [0, "appearance"] }, null), Ls(603979776, 10, { _controlNonStatic: 0 }), Ls(335544320, 11, { _controlStatic: 0 }), Ls(603979776, 12, { _labelChildNonStatic: 0 }), Ls(335544320, 13, { _labelChildStatic: 0 }), Ls(603979776, 14, { _placeholderChild: 0 }), Ls(603979776, 15, { _errorChildren: 1 }), Ls(603979776, 16, { _hintChildren: 1 }), Ls(603979776, 17, { _prefixChildren: 1 }), Ls(603979776, 18, { _suffixChildren: 1 }), (t()(), Rs(43, 0, null, 3, 2, "mat-label", [], null, null, null, null, null)), Ki(44, 16384, [[12, 4], [13, 4]], 0, sf, [], null, null), (t()(), Ws(-1, null, ["Passwords"])), (t()(), Rs(46, 0, null, 1, 7, "input", [["class", "mat-input-element mat-form-field-autofill-control"], ["matInput", ""], ["placeholder", "Placeholder"], ["type", "password"]], [[2, "ng-untouched", null], [2, "ng-touched", null], [2, "ng-pristine", null], [2, "ng-dirty", null], [2, "ng-valid", null], [2, "ng-invalid", null], [2, "ng-pending", null], [2, "mat-input-server", null], [1, "id", 0], [1, "placeholder", 0], [8, "disabled", 0], [8, "required", 0], [1, "readonly", 0], [1, "aria-describedby", 0], [1, "aria-invalid", 0], [1, "aria-required", 0]], [[null, "ngModelChange"], [null, "input"], [null, "blur"], [null, "compositionstart"], [null, "compositionend"], [null, "focus"]], (function (t, e, n) { var i = !0, r = t.component; return "input" === e && (i = !1 !== Li(t, 47)._handleInput(n.target.value) && i), "blur" === e && (i = !1 !== Li(t, 47).onTouched() && i), "compositionstart" === e && (i = !1 !== Li(t, 47)._compositionStart() && i), "compositionend" === e && (i = !1 !== Li(t, 47)._compositionEnd(n.target.value) && i), "blur" === e && (i = !1 !== Li(t, 52)._focusChanged(!1) && i), "focus" === e && (i = !1 !== Li(t, 52)._focusChanged(!0) && i), "input" === e && (i = !1 !== Li(t, 52)._onInput() && i), "ngModelChange" === e && (i = !1 !== (r.password = n) && i), i }), null, null)), Ki(47, 16384, null, 0, Yg, [tn, Qe, [2, Kg]], null, null), Yi(1024, null, Zg, (function (t) { return [t] }), [Yg]), Ki(49, 671744, null, 0, q_, [[8, null], [8, null], [8, null], [6, Zg]], { model: [0, "model"] }, { update: "ngModelChange" }), Yi(2048, null, e_, null, [q_]), Ki(51, 16384, null, 0, n_, [[4, e_]], null, null), Ki(52, 999424, null, 0, dy, [Qe, up, [6, e_], [2, j_], [2, Q_], jp, [8, null], oy, Zr], { placeholder: [0, "placeholder"], type: [1, "type"] }, null), Yi(2048, [[10, 4], [11, 4]], tf, null, [dy]), (t()(), Rs(54, 0, null, 4, 3, "mat-icon", [["class", "mat-icon notranslate"], ["matSuffix", ""], ["role", "img"]], [[2, "mat-icon-inline", null], [2, "mat-icon-no-color", null]], null, null, uv, cv)), Ki(55, 16384, [[18, 4]], 0, of, [], null, null), Ki(56, 9158656, null, 0, lv, [Qe, Xy, [8, null], [2, iv], [2, Te]], null, null), (t()(), Ws(-1, 0, ["sentiment_very_satisfied"])), (t()(), As(16777216, null, 6, 1, null, Bb)), Ki(59, 16384, null, 0, ql, [En, Cn], { ngIf: [0, "ngIf"] }, null), (t()(), Rs(60, 0, null, null, 7, "div", [["class", "actions"]], null, null, null, null, null)), (t()(), Rs(61, 0, null, null, 3, "a", [], [[1, "target", 0], [8, "href", 4]], [[null, "click"]], (function (t, e, n) { var i = !0; return "click" === e && (i = !1 !== Li(t, 62).onClick(n.button, n.ctrlKey, n.metaKey, n.shiftKey) && i), i }), null, null)), Ki(62, 671744, null, 0, wd, [bd, uh, ol], { routerLink: [0, "routerLink"] }, null), $s(32, 63, new Array(1)), (t()(), Ws(-1, null, ["forget password ?"])), (t()(), Rs(65, 0, null, null, 2, "button", [["color", "primary"], ["mat-raised-button", ""]], [[1, "disabled", 0], [2, "_mat-animation-noopable", null]], [[null, "click"]], (function (t, e, n) { var i = !0; return "click" === e && (i = !1 !== t.component.login() && i), i }), _v, gv)), Ki(66, 180224, null, 0, fv, [Qe, Ap, [2, Ag]], { color: [0, "color"] }, null), (t()(), Ws(-1, 0, ["Login"]))], (function (t, e) { var n = e.component; t(e, 5, 0, "outline"), t(e, 21, 0, n.username), t(e, 24, 0, "Placeholder"), t(e, 28, 0), t(e, 31, 0, !1), t(e, 33, 0, "outline"), t(e, 49, 0, n.password), t(e, 52, 0, "Placeholder", "password"), t(e, 56, 0), t(e, 59, 0, !1); var i = t(e, 63, 0, "/forgetPassword"); t(e, 62, 0, i), t(e, 66, 0, "primary") }), (function (t, e) { t(e, 4, 1, ["standard" == Li(e, 5).appearance, "fill" == Li(e, 5).appearance, "outline" == Li(e, 5).appearance, "legacy" == Li(e, 5).appearance, Li(e, 5)._control.errorState, Li(e, 5)._canLabelFloat, Li(e, 5)._shouldLabelFloat(), Li(e, 5)._hasFloatingLabel(), Li(e, 5)._hideControlPlaceholder(), Li(e, 5)._control.disabled, Li(e, 5)._control.autofilled, Li(e, 5)._control.focused, "accent" == Li(e, 5).color, "warn" == Li(e, 5).color, Li(e, 5)._shouldForward("untouched"), Li(e, 5)._shouldForward("touched"), Li(e, 5)._shouldForward("pristine"), Li(e, 5)._shouldForward("dirty"), Li(e, 5)._shouldForward("valid"), Li(e, 5)._shouldForward("invalid"), Li(e, 5)._shouldForward("pending"), !Li(e, 5)._animationsEnabled]), t(e, 18, 1, [Li(e, 23).ngClassUntouched, Li(e, 23).ngClassTouched, Li(e, 23).ngClassPristine, Li(e, 23).ngClassDirty, Li(e, 23).ngClassValid, Li(e, 23).ngClassInvalid, Li(e, 23).ngClassPending, Li(e, 24)._isServer, Li(e, 24).id, Li(e, 24).placeholder, Li(e, 24).disabled, Li(e, 24).required, Li(e, 24).readonly && !Li(e, 24)._isNativeSelect || null, Li(e, 24)._ariaDescribedby || null, Li(e, 24).errorState, Li(e, 24).required.toString()]), t(e, 26, 0, Li(e, 28).inline, "primary" !== Li(e, 28).color && "accent" !== Li(e, 28).color && "warn" !== Li(e, 28).color), t(e, 32, 1, ["standard" == Li(e, 33).appearance, "fill" == Li(e, 33).appearance, "outline" == Li(e, 33).appearance, "legacy" == Li(e, 33).appearance, Li(e, 33)._control.errorState, Li(e, 33)._canLabelFloat, Li(e, 33)._shouldLabelFloat(), Li(e, 33)._hasFloatingLabel(), Li(e, 33)._hideControlPlaceholder(), Li(e, 33)._control.disabled, Li(e, 33)._control.autofilled, Li(e, 33)._control.focused, "accent" == Li(e, 33).color, "warn" == Li(e, 33).color, Li(e, 33)._shouldForward("untouched"), Li(e, 33)._shouldForward("touched"), Li(e, 33)._shouldForward("pristine"), Li(e, 33)._shouldForward("dirty"), Li(e, 33)._shouldForward("valid"), Li(e, 33)._shouldForward("invalid"), Li(e, 33)._shouldForward("pending"), !Li(e, 33)._animationsEnabled]), t(e, 46, 1, [Li(e, 51).ngClassUntouched, Li(e, 51).ngClassTouched, Li(e, 51).ngClassPristine, Li(e, 51).ngClassDirty, Li(e, 51).ngClassValid, Li(e, 51).ngClassInvalid, Li(e, 51).ngClassPending, Li(e, 52)._isServer, Li(e, 52).id, Li(e, 52).placeholder, Li(e, 52).disabled, Li(e, 52).required, Li(e, 52).readonly && !Li(e, 52)._isNativeSelect || null, Li(e, 52)._ariaDescribedby || null, Li(e, 52).errorState, Li(e, 52).required.toString()]), t(e, 54, 0, Li(e, 56).inline, "primary" !== Li(e, 56).color && "accent" !== Li(e, 56).color && "warn" !== Li(e, 56).color), t(e, 61, 0, Li(e, 62).target, Li(e, 62).href), t(e, 65, 0, Li(e, 66).disabled || null, "NoopAnimations" === Li(e, 66)._animationMode) })) } function Wb(t) { return Zs(0, [(t()(), Rs(0, 0, null, null, 1, "app-login", [], null, null, null, $b, Ub)), Ki(1, 114688, null, 0, bv, [zv, Nb, bd], null, null)], (function (t, e) { t(e, 1, 0) }), null) } var qb = Ti("app-login", bv, Wb, {}, {}, []); class Gb { constructor(t) { this.eventType = void 0, this.handlers = {}, this.startX = 0, this.startY = 0, this.lastTap = 0, this.doubleTapMinTimeout = 300, this.tapMinTimeout = 200, this.touchstartTime = 0, this.i = 0, this.isMousedown = !1, this.touchListeners = { touchstart: "handleTouchstart", touchmove: "handleTouchmove", touchend: "handleTouchend" }, this.mouseListeners = { mousedown: "handleMousedown", mousemove: "handleMousemove", mouseup: "handleMouseup", wheel: "handleWheel" }, this.otherListeners = { resize: "handleResize" }, this.handleTouchstart = t => { this.elementPosition = this.getElementPosition(), this.touchstartTime = (new Date).getTime(), void 0 === this.eventType && this.getTouchstartPosition(t), this.runHandler("touchstart", t) }, this.handleTouchmove = t => { switch (this.detectPan(t.touches) && this.runHandler("pan", t), this.detectPinch(t) && this.runHandler("pinch", t), this.detectLinearSwipe(t)) { case "horizontal-swipe": t.swipeType = "horizontal-swipe", this.runHandler("horizontal-swipe", t); break; case "vertical-swipe": t.swipeType = "vertical-swipe", this.runHandler("vertical-swipe", t) }(this.detectLinearSwipe(t) || "horizontal-swipe" === this.eventType || "vertical-swipe" === this.eventType) && this.handleLinearSwipe(t) }, this.handleTouchend = t => { const e = t.touches; this.detectDoubleTap() && this.runHandler("double-tap", t), this.detectTap(), this.runHandler("touchend", t), this.eventType = "touchend", e && 0 === e.length && (this.eventType = void 0, this.i = 0) }, this.handleMousedown = t => { this.isMousedown = !0, this.elementPosition = this.getElementPosition(), this.touchstartTime = (new Date).getTime(), void 0 === this.eventType && this.getMousedownPosition(t), this.runHandler("mousedown", t) }, this.handleMousemove = t => { if (this.isMousedown) { switch (this.runHandler("pan", t), this.detectLinearSwipe(t)) { case "horizontal-swipe": t.swipeType = "horizontal-swipe", this.runHandler("horizontal-swipe", t); break; case "vertical-swipe": t.swipeType = "vertical-swipe", this.runHandler("vertical-swipe", t) }(this.detectLinearSwipe(t) || "horizontal-swipe" === this.eventType || "vertical-swipe" === this.eventType) && this.handleLinearSwipe(t) } }, this.handleMouseup = t => { this.detectTap(), this.isMousedown = !1, this.runHandler("mouseup", t), this.eventType = void 0, this.i = 0 }, this.handleWheel = t => { this.runHandler("wheel", t) }, this.handleResize = t => { this.runHandler("resize", t) }, this.properties = t, this.element = this.properties.element, this.elementPosition = this.getElementPosition(), this.toggleEventListeners("addEventListener") } destroy() { this.toggleEventListeners("removeEventListener") } toggleEventListeners(t) { let e; for (var n in e = "mouse and touch" === this.properties.listeners ? Object.assign(this.touchListeners, this.mouseListeners) : this.detectTouchScreen() ? this.touchListeners : this.mouseListeners, this.properties.resize && (e = Object.assign(e, this.otherListeners)), e) { const i = e[n]; "resize" === n ? ("addEventListener" === t && window.addEventListener(n, this[i], !1), "removeEventListener" === t && window.removeEventListener(n, this[i], !1)) : "mouseup" === n || "mousemove" === n ? ("addEventListener" === t && document.addEventListener(n, this[i], !1), "removeEventListener" === t && document.removeEventListener(n, this[i], !1)) : ("addEventListener" === t && this.element.addEventListener(n, this[i], !1), "removeEventListener" === t && this.element.removeEventListener(n, this[i], !1)) } } handleLinearSwipe(t) { this.i++, this.i > 3 && (this.eventType = this.getLinearSwipeType(t)), "horizontal-swipe" === this.eventType && this.runHandler("horizontal-swipe", t), "vertical-swipe" === this.eventType && this.runHandler("vertical-swipe", t) } runHandler(t, e) { this.handlers[t] && this.handlers[t](e) } detectPan(t) { return 1 === t.length && !this.eventType || "pan" === this.eventType } detectDoubleTap() { if (null != this.eventType) return; const t = (new Date).getTime(), e = t - this.lastTap; if (clearTimeout(this.doubleTapTimeout), e < this.doubleTapMinTimeout && e > 0) return !0; this.doubleTapTimeout = setTimeout(() => { clearTimeout(this.doubleTapTimeout) }, this.doubleTapMinTimeout), this.lastTap = t } detectTap() { if (null != this.eventType) return; const t = (new Date).getTime() - this.touchstartTime; t > 0 && this.runHandler(t < this.tapMinTimeout ? "tap" : "longtap", event) } detectPinch(t) { return 2 === t.touches.length && void 0 === this.eventType || "pinch" === this.eventType } detectLinearSwipe(t) { const e = t.touches; if (e) { if (1 === e.length && !this.eventType || "horizontal-swipe" === this.eventType || "vertical-swipe" === this.eventType) return this.getLinearSwipeType(t) } else if (!this.eventType || "horizontal-swipe" === this.eventType || "vertical-swipe" === this.eventType) return this.getLinearSwipeType(t) } getLinearSwipeType(t) { if ("horizontal-swipe" !== this.eventType && "vertical-swipe" !== this.eventType) { const e = Math.abs(this.moveLeft(0, t) - this.startX); return 3 * Math.abs(this.moveTop(0, t) - this.startY) > e ? "vertical-swipe" : "horizontal-swipe" } return this.eventType } getElementPosition() { return this.element.getBoundingClientRect() } getTouchstartPosition(t) { this.startX = t.touches[0].clientX - this.elementPosition.left, this.startY = t.touches[0].clientY - this.elementPosition.top } getMousedownPosition(t) { this.startX = t.clientX - this.elementPosition.left, this.startY = t.clientY - this.elementPosition.top } moveLeft(t, e) { const n = e.touches; return n ? n[t].clientX - this.elementPosition.left : e.clientX - this.elementPosition.left } moveTop(t, e) { const n = e.touches; return n ? n[t].clientY - this.elementPosition.top : e.clientY - this.elementPosition.top } detectTouchScreen() { var t, e = " -webkit- -moz- -o- -ms- ".split(" "); return "ontouchstart" in window || (t = ["(", e.join("touch-enabled),("), "heartz", ")"].join(""), window.matchMedia(t).matches) } on(t, e) { t && (this.handlers[t] = e) } } class Zb { constructor(t) { this.initialPositionX = 0, this.newContainerPositionIndex = 0, this.preliminarySlideCounter = 0, this.slideCounter = 0, this.previousSlideCounter = 0, this.isContentImages = !0, this.isLazyLoad = !0, this.isContainerLocked = !0, this.alignCells = "left", this.initialContainerPosition = 0, this.handleTouchstart = t => { if (this.isTouchstart = !0, this.isSlideInProgress) return; const e = t.touches; this.startX = e ? e[0].clientX - this.getCarouselElementPosition().left : t.clientX - this.getCarouselElementPosition().left, this.containerInitialPositionX = this.getElementPosition().left - this.getCarouselElementPosition().left, this.isMoveInProgress = !0 }, this.handleHorizontalSwipe = t => { if (this.isSlideInProgress) return; const e = t.touches; this.moveX = e ? e[0].clientX - this.getCarouselElementPosition().left : t.clientX - this.getCarouselElementPosition().left, this.distanceAbs = this.getDistanceAbs(), this.direction = this.getDirection(), this.moveContainer() }, this.handleTouchend = t => { !this.isSlideInProgress && this.isTouchstart ? (this.isMoveInProgress = !1, this.detectSlide() ? this.handleSlide() : (this.newContainerPositionIndex = 0, this.alignContainer()), this.startX = this.moveX = this.distanceAbs = void 0, this.isTouchstart = !1) : this.isTouchstart = !1 }, this.element = t.element, this.properties = t, this.cells = this.element.children, this.visibleWidth = this.properties.visibleWidth || this.element.parentElement.clientWidth, this.setContainerWidth(), this.alignContainer(0) } get cellLength() { return this.images ? this.images.length : this.cells.length } get totalContainerCellsCount() { if (this.images) { let t = this.visibleCellsCount + 2 * this.overflowCellsLimit; return t > this.images.length && (t = this.images.length), t } return this.cellLength } get isFirstCell() { return 0 === this.slideCounter } get lastCellIndex() { return this.images.length ? this.images.length - 1 : this.cells.length - 1 } get overflowCellsLimit() { return this.images && this.isImagesLessCellLimit ? Math.floor((this.images.length - this.visibleCellsCount) / 2) : this.properties.overflowCellsLimit } get isImagesLessCellLimit() { return 2 * this.properties.overflowCellsLimit + this.visibleCellsCount > this.images.length } get cellLimit() { return this.visibleCellsCount + 2 * this.overflowCellsLimit } get images() { return this.properties.images } get margin() { return this.properties.margin } get minSwipeDistance() { return this.properties.minSwipeDistance } get transitionDuration() { return this.properties.transitionDuration } get transitionTimingFunction() { return this.properties.transitionTimingFunction } get fullCellWidth() { return this.properties.cellWidth + this.margin } get visibleCellsCount() { return Math.ceil(this.visibleWidth / this.fullCellWidth) } get lapCounter() { return Math.floor(this.slideCounter / this.totalContainerCellsCount) } get visibleCellsOverflowContainer() { return this.visibleCellsCount * this.fullCellWidth - this.margin > this.visibleWidth } moveContainer() { let t = this.getMovePositionX(); this.transformPositionX(t, 0) } getMovePositionX() { const t = this.getDistance(); return this.containerInitialPositionX - t } alignContainer(t = this.transitionDuration) { let e = this.getContainerPosition(); this.transformPositionX(e, t), this.setInitialContainerPosition(e) } getContainerPosition() { let t = this.getContainerPositionCorrection(); return this.isContainerPositionCorrection = 0 != t, this.initialContainerPosition + this.newContainerPositionIndex * this.fullCellWidth + t } setInitialContainerPosition(t) { let e = this.getContainerPositionCorrection(); this.initialContainerPosition = t - e } getContainerPositionCorrection() { let t = 0; return this.properties.loop ? 0 : ((this.cellLength - this.preliminarySlideCounter < this.visibleCellsCount || this.isSlideLengthLimited) && (this.visibleWidth < this.totalContainerCellsCount * this.fullCellWidth && (t = -(this.visibleCellsCount * this.fullCellWidth - this.visibleWidth - this.margin)), t >= -this.margin && (t = 0)), t) } quicklyPositionContainer() { let t = this.getContainerPositionCorrection(); const e = this.getNewContainerPosition() + t; this.transformPositionX(e, 0), this.setInitialContainerPosition(e) } getNewContainerPosition() { return this.slideCounter > this.overflowCellsLimit && "left" === this.alignCells ? (this.lineUpCells(), -this.overflowCellsLimit * this.fullCellWidth) : this.slideCounter <= this.overflowCellsLimit ? (this.previousSlideCounter > this.overflowCellsLimit && this.lineUpCells(), -this.slideCounter * this.fullCellWidth) : void 0 } setContainerWidth() { const t = this.getContainerWidth(); this.element.style.width = t + "px" } getContainerWidth() { let t = this.totalContainerCellsCount * this.fullCellWidth, e = this.cellLength * this.fullCellWidth; return e < t && (t = e), t } getFile(t) { let e = this.getFileIndex(t), n = this.images[e]; return n && !n.type && (n.type = "image"), { image: this.images[e], imageIndex: e } } getFileIndex(t) { const e = this.getPositionIndex(t); let n, i = this.slideCounter; return this.isContainerLocked ? ("left" === this.alignCells && (n = i > this.overflowCellsLimit ? e + (i - this.overflowCellsLimit) : t), !(n > this.lastCellIndex && !this.properties.loop) && n) : i <= this.overflowCellsLimit ? t : (n = e + (i - this.overflowCellsLimit), this.images && this.properties.loop && (n %= this.images.length), n) } transformPositionX(t, e = this.transitionDuration) { this.element.style.transition = "transform " + e + "ms " + this.transitionTimingFunction, this.element.style.transform = "translateX(" + t + "px)" } detectSlide() { return this.distanceAbs >= this.minSwipeDistance } next() { this.isSlideInProgress || (this.direction = "left", this.handleSlide(1)) } prev() { this.isSlideInProgress || (this.direction = "right", this.handleSlide(1)) } select(t) { this.slideCounter = t, this.quicklyPositionContainer() } handleSlide(t) { this.slideLength = this.getSlideLength(), this.slideLength = t || this.limitSlideLength(this.slideLength), "left" !== this.direction || this.isSlideInProgress || (this.preliminarySlideCounter = this.slideCounter + this.slideLength, this.detectLastSlide(this.slideCounter + this.slideLength) || (this.newContainerPositionIndex = this.newContainerPositionIndex - this.slideLength, this.isSlideInProgress = !0, this.isLazyLoad && (this.isContainerLocked = this.preliminarySlideCounter > this.overflowCellsLimit, this.detectContainerUnlock() && (this.isContainerLocked = !1)))), "right" !== this.direction || this.isSlideInProgress || (this.slideCounter - this.slideLength < 0 && (this.slideLength = this.slideCounter), this.preliminarySlideCounter = this.slideCounter - this.slideLength, this.isFirstCell || (this.newContainerPositionIndex = this.newContainerPositionIndex + this.slideLength, this.isSlideInProgress = !0, this.isLazyLoad && (this.isContainerLocked = this.preliminarySlideCounter > this.overflowCellsLimit, this.detectContainerUnlock() && (this.isContainerLocked = !1)))), this.alignContainer() } getSlideLength() { let t = this.getContainerPositionCorrection(), e = Math.floor((this.distanceAbs + t) / this.fullCellWidth); return this.distanceAbs % this.fullCellWidth >= this.minSwipeDistance && e++, e } limitSlideLength(t) { if (t > 1) for (var e = 0; e < t; e++)if (!this.detectLastSlide(this.slideCounter + (t - e))) { t -= e, this.isSlideLengthLimited = e > 0; break } return t } detectLastSlide(t) { return !this.properties.loop && this.cellLength - t < this.visibleCellsCount } isNextArrowDisabled() { return this.visibleCellsOverflowContainer ? this.detectLastSlide(this.slideCounter + 1) && this.isContainerPositionCorrection : this.detectLastSlide(this.slideCounter + 1) } isPrevArrowDisabled() { return 0 === this.slideCounter } detectContainerUnlock() { return this.cellLength - this.preliminarySlideCounter < this.visibleCellsCount + this.overflowCellsLimit } handleSlideEnd() { this.isSlideInProgress && (this.transformSlideEnd(), this.isSlideInProgress = !1, this.newContainerPositionIndex = 0, this.isSlideLengthLimited = void 0) } transformSlideEnd() { this.isLazyLoad && (this.setSlideCounter(), (this.images || !this.images && this.properties.loop) && this.quicklyPositionContainer()), this.previousSlideCounter = this.slideCounter } setSlideCounter() { "left" === this.direction && (this.slideCounter = this.slideCounter + this.slideLength), "right" === this.direction && (this.slideCounter = this.slideCounter - this.slideLength), this.direction = void 0, this.slideLength = 0 } resetTransition() { this.element.style.transition = "" } getElementPosition() { return this.element.getBoundingClientRect() } getCarouselElementPosition() { return this.properties.container.getBoundingClientRect() } getDistance() { return this.startX - this.moveX } getDistanceAbs() { return Math.abs(this.startX - this.moveX) } getDirection() { const t = Math.sign(this.startX - this.moveX); return -1 === t ? "right" : 1 === t ? "left" : void 0 } lineUpCells() { const t = this.element.children; for (var e = 0; e < t.length; e++) { let n = t[e], i = this.getCellPositionX(e); n.style.transform = "translateX(" + i + "px)", n.style.width = this.properties.cellWidth + "px" } } getCellPositionX(t) { return this.getPositionIndex(t) * this.fullCellWidth } getPositionIndex(t) { let e, n = this.totalContainerCellsCount, i = this.slideCounter - this.overflowCellsLimit; return i > n && (i %= n), i < 0 ? t : (e = t - i, e < 0 && (e = n + e), e) } getCenterPositionIndex() { return (this.totalContainerCellsCount - 1) / 2 } autoplay() { this.autoplayId = setInterval(() => { this.next() }, this.properties.autoplayInterval) } stopAutoplay() { this.autoplayId && clearInterval(this.autoplayId) } destroy() { this.stopAutoplay() } } let Qb = (() => class { constructor(t, e) { this.elementRef = t, this.ref = e, this.minTimeout = 30, this._cellWidth = 200, this.events = new vr, this.height = 200, this.loop = !1, this.autoplay = !1, this.autoplayInterval = 5e3, this.pauseOnHover = !0, this.dots = !1, this.margin = 10, this.objectFit = "cover", this.minSwipeDistance = 50, this.transitionDuration = 200, this.transitionTimingFunction = "ease", this.counterSeparator = " / ", this.overflowCellsLimit = 3, this.listeners = "mouse and touch", this.arrows = !0, this.arrowsTheme = "light", this.hostClassCarousel = !0, this.handleTouchstart = t => { t.preventDefault(), this.carousel.handleTouchstart(t), this.isMoving = !0, this.events.emit({ type: "touchstart", event: t }) }, this.handleHorizontalSwipe = t => { t.preventDefault(), this.carousel.handleHorizontalSwipe(t), this.events.emit({ type: "swipe", event: t }) }, this.handleTouchend = t => { this.carousel.handleTouchend(t), this.isMoving = !1, this.events.emit({ type: "touchend", event: t }) }, this.handleTap = t => { const e = this.carousel.currentCellIndex, n = this.carousel.getFileIndex(this.carousel.slideCounter), i = this.carousel.getFile(e); this.events.emit({ type: "click", file: i, index: n }) } } get isContainerLocked() { return this.carousel.isContainerLocked } get slideCounter() { return this.carousel.slideCounter } get previousSlideCounter() { return this.carousel.previousSlideCounter } get lapCounter() { return this.carousel.lapCounter } lineUpCells() { this.carousel.lineUpCells() } quicklyPositionContainer() { this.carousel.quicklyPositionContainer() } get isLandscape() { return window.innerWidth > window.innerHeight } get isSafari() { const t = navigator.userAgent.toLowerCase(); if (-1 !== t.indexOf("safari")) return !(t.indexOf("chrome") > -1) } get counter() { let t; return t = this.loop ? this.slideCounter % this.cellLength : this.slideCounter, t + 1 + this.counterSeparator + this.cellLength } get cellsElement() { return this.elementRef.nativeElement.querySelector(".carousel-cells") } set images(t) { this._images = t } get images() { return this._images } set cellWidth(t) { t && (this._cellWidth = t) } set isCounter(t) { t && (this._isCounter = t) } get isCounter() { return this._isCounter && this.cellLength > 1 } get activeDotIndex() { return this.slideCounter % this.cellLength } get cellLimit() { if (this.carousel) return this.carousel.cellLimit } onWindowResize(t) { this.landscapeMode = this.isLandscape, this.ref.detectChanges(), this.initCarousel(), this.carousel.lineUpCells() } onMousemove(t) { this.autoplay && this.pauseOnHover && this.carousel.stopAutoplay() } onMouseleave(t) { this.autoplay && this.pauseOnHover && this.carousel.autoplay() } ngOnInit() { this.isNgContent = this.cellsElement.children.length > 0, this.touches = new Gb({ element: this.cellsElement, listeners: this.listeners }), this.touches.on("touchstart", this.handleTouchstart), this.touches.on("horizontal-swipe", this.handleHorizontalSwipe), this.touches.on("touchend", this.handleTouchend), this.touches.on("mousedown", this.handleTouchstart), this.touches.on("mouseup", this.handleTouchend), this.touches.on("tap", this.handleTap), this.initCarousel(), this.setDimensions(), this.autoplay && this.carousel.autoplay() } ngAfterViewInit() { this.cellLength = this.getCellLength(), this.dotsArr = Array(this.cellLength).fill(1), this.ref.detectChanges(), this.carousel.lineUpCells() } ngOnChanges(t) { (t.width || t.height) && (this.setDimensions(), this.initCarousel(), this.carousel.lineUpCells()) } ngOnDestroy() { this.touches.destroy(), this.carousel.destroy() } initCarousel() { this.carousel = new Zb({ element: this.elementRef.nativeElement.querySelector(".carousel-cells"), container: this.elementRef.nativeElement, images: this.images, cellWidth: this.getCellWidth(), loop: this.loop, autoplayInterval: this.autoplayInterval, overflowCellsLimit: this.overflowCellsLimit, visibleWidth: this.width, margin: this.margin, minSwipeDistance: this.minSwipeDistance, transitionDuration: this.transitionDuration, transitionTimingFunction: this.transitionTimingFunction, videoProperties: this.videoProperties }) } setDimensions() { this.hostStyleHeight = this.height + "px", this.hostStyleWidth = this.width + "px" } getFile(t) { return this.carousel.getFile(t) } handleTransitionendCellContainer(t) { this.carousel.handleSlideEnd() } toggleVideo(t) { event.preventDefault(), this.videoProperties.noPlay || (t.paused ? (t.play(), this.isVideoPlaying = !0) : (t.pause(), this.isVideoPlaying = !1), this.ref.detectChanges()) } getCurrentIndex() { return this.carousel.slideCounter } getCellWidth() { return "100%" === this._cellWidth ? this.elementRef.nativeElement.clientWidth : this._cellWidth } next() { this.carousel.next(1), this.carousel.stopAutoplay() } prev() { this.carousel.prev(1), this.carousel.stopAutoplay() } select(t) { this.carousel.select(t) } isNextArrowDisabled() { return this.carousel.isNextArrowDisabled() } isPrevArrowDisabled() { return this.carousel.isPrevArrowDisabled() } getCellLength() { return this.images ? this.images.length : this.cellsElement.children.length } })(), Kb = (() => class { })(); var Yb = jn({ encapsulation: 0, styles: ["[_nghost-%COMP%]{-moz-user-select:none;-webkit-user-select:none;box-sizing:border-box;display:block;height:100%;left:0;position:relative;top:0;transform-origin:top left;user-select:none;width:100%;z-index:10000}[_nghost-%COMP%]   .carousel-container[_ngcontent-%COMP%]{cursor:grab;height:100%;overflow:hidden;width:100%}[_nghost-%COMP%]   .carousel-container.carousel-moving[_ngcontent-%COMP%]{cursor:grabbing}[_nghost-%COMP%]   .carousel-counter[_ngcontent-%COMP%]{background-color:rgba(23,37,68,.3);border-radius:13px;color:#fff;font-size:11px;line-height:normal;padding:5px 7px;position:absolute;right:24px;text-align:right;top:8px;transition:opacity .2s;z-index:30}[_nghost-%COMP%]     .carousel-cells{display:block;height:100%;transition:transform .2s;width:100%}[_nghost-%COMP%]     .carousel-cells .carousel-cell.swiper-prev-image{transform:translate3d(-100%,0,0)}[_nghost-%COMP%]     .carousel-cells .carousel-cell.swiper-next-image{transform:translate3d(100%,0,0)}[_nghost-%COMP%]     .carousel-cells .carousel-cell{align-items:center;display:flex;height:100%;justify-content:center;overflow:hidden;position:absolute;text-align:center;width:100%}[_nghost-%COMP%]     .carousel-cells .carousel-cell img, [_nghost-%COMP%]     .carousel-cells .carousel-cell video{height:100%;object-fit:contain;position:relative;width:100%}[_nghost-%COMP%]     .carousel-cells .carousel-cell img.swiper-hide{display:none}[_nghost-%COMP%]     .carousel-cells .carousel-cell .carousel-play{bottom:0;left:0;position:absolute;right:0;top:0;z-index:1}[_nghost-%COMP%]   .carousel-arrow[_ngcontent-%COMP%]{background-color:#fff;background-position:50%;background-repeat:no-repeat;background-size:31px;border-radius:100px;box-shadow:0 0 5px rgba(0,0,0,.15);cursor:pointer;height:40px;margin-top:-20px;position:absolute;top:50%;width:40px;z-index:10}[_nghost-%COMP%]   .carousel-arrow-prev[_ngcontent-%COMP%]{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0Ij48cGF0aCBkPSJNMTUuNDEgMTYuNTlMMTAuODMgMTJsNC41OC00LjU5TDE0IDZsLTYgNiA2IDYgMS40MS0xLjQxeiIvPjxwYXRoIGQ9Ik0wIDBoMjR2MjRIMFYweiIgZmlsbD0ibm9uZSIvPjwvc3ZnPg==);left:10px}[_nghost-%COMP%]   .carousel-arrow-next[_ngcontent-%COMP%]{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0Ij48cGF0aCBkPSJNOC41OSAxNi41OUwxMy4xNyAxMiA4LjU5IDcuNDEgMTAgNmw2IDYtNiA2LTEuNDEtMS40MXoiLz48cGF0aCBkPSJNMCAwaDI0djI0SDBWMHoiIGZpbGw9Im5vbmUiLz48L3N2Zz4=);right:10px}[_nghost-%COMP%]   .carousel-arrows-outside[_ngcontent-%COMP%]   .carousel-arrow-prev[_ngcontent-%COMP%]{left:-60px}[_nghost-%COMP%]   .carousel-arrows-outside[_ngcontent-%COMP%]   .carousel-arrow-next[_ngcontent-%COMP%]{right:-60px}[_nghost-%COMP%]   .carousel-dark-arrows[_ngcontent-%COMP%]   .carousel-arrow[_ngcontent-%COMP%]{filter:invert(1)}[_nghost-%COMP%]   .carousel-arrow-disabled[_ngcontent-%COMP%]{cursor:default;opacity:.5}[_nghost-%COMP%]   .carousel-dots[_ngcontent-%COMP%]{bottom:0;left:0;position:absolute;right:0;text-align:center;z-index:10}[_nghost-%COMP%]   .carousel-dots[_ngcontent-%COMP%]   .carousel-dot[_ngcontent-%COMP%]{border:2px solid #fff;border-radius:100px;display:inline-block;height:8px;margin:4px;width:8px}[_nghost-%COMP%]   .carousel-dots[_ngcontent-%COMP%]   .carousel-dot-active[_ngcontent-%COMP%]{background-color:#fff}"], data: {} }); function Xb(t) { return Zs(0, [(t()(), Rs(0, 0, null, null, 1, "div", [["class", "carousel-counter"]], null, null, null, null, null)), (t()(), Ws(1, null, ["", ""]))], null, (function (t, e) { t(e, 1, 0, e.component.counter) })) } function Jb(t) { return Zs(0, [(t()(), Rs(0, 0, null, null, 0, "img", [["draggable", "false"]], [[8, "src", 4], [4, "object-fit", null]], null, null, null, null))], null, (function (t, e) { var n = e.component; t(e, 0, 0, n.getFile(e.parent.parent.context.index).image.path, n.objectFit) })) } function tw(t) { return Zs(0, [(t()(), Rs(0, 0, null, null, 0, "div", [["class", "carousel-play"]], null, [[null, "click"]], (function (t, e, n) { var i = !0; return "click" === e && (i = !1 !== t.component.toggleVideo(Li(t, 1)) && i), i }), null, null)), (t()(), Rs(1, 0, [["video", 1]], null, 1, "video", [], [[8, "loop", 0], [8, "muted", 0], [8, "controls", 0], [4, "object-fit", null], [4, "border-radius", null]], null, null, null, null)), (t()(), Rs(2, 0, null, null, 0, "source", [["type", "video/mp4"]], [[8, "src", 4]], null, null, null, null))], null, (function (t, e) { var n = e.component; t(e, 1, 0, n.videoProperties.loop, n.videoProperties.muted, n.isSafari, n.objectFit, n.borderRadius + "px"), t(e, 2, 0, n.getFile(e.parent.parent.context.index).path) })) } function ew(t) { return Zs(0, [(t()(), Rs(0, 0, null, null, 4, "div", [["class", "carousel-cell"]], [[4, "width", null], [4, "border-radius", null]], null, null, null, null)), (t()(), As(16777216, null, null, 1, null, Jb)), Ki(2, 16384, null, 0, ql, [En, Cn], { ngIf: [0, "ngIf"] }, null), (t()(), As(16777216, null, null, 1, null, tw)), Ki(4, 16384, null, 0, ql, [En, Cn], { ngIf: [0, "ngIf"] }, null)], (function (t, e) { var n = e.component; t(e, 2, 0, n.getFile(e.parent.context.index) && n.getFile(e.parent.context.index).image), t(e, 4, 0, n.getFile(e.parent.context.index) && "video" === n.getFile(e.parent.context.index).type) }), (function (t, e) { var n = e.component; t(e, 0, 0, n.getCellWidth() + "px", n.borderRadius + "px") })) } function nw(t) { return Zs(0, [(t()(), As(16777216, null, null, 1, null, ew)), Ki(1, 16384, null, 0, ql, [En, Cn], { ngIf: [0, "ngIf"] }, null), (t()(), As(0, null, null, 0))], (function (t, e) { t(e, 1, 0, e.context.index < e.component.cellLimit) }), null) } function iw(t) { return Zs(0, [(t()(), Rs(0, 0, null, null, 0, "div", [["class", "carousel-dot"]], [[2, "carousel-dot-active", null]], null, null, null, null))], null, (function (t, e) { t(e, 0, 0, e.context.index === e.component.activeDotIndex) })) } function rw(t) { return Zs(0, [(t()(), Rs(0, 0, null, null, 2, "div", [["class", "carousel-dots"]], null, null, null, null, null)), (t()(), As(16777216, null, null, 1, null, iw)), Ki(2, 278528, null, 0, $l, [En, Cn, mn], { ngForOf: [0, "ngForOf"] }, null)], (function (t, e) { t(e, 2, 0, e.component.dotsArr) }), null) } function sw(t) { return Zs(0, [(t()(), Rs(0, 0, null, null, 2, "div", [["class", "carousel-arrows"]], [[2, "carousel-arrows-outside", null], [2, "carousel-dark-arrows", null]], null, null, null, null)), (t()(), Rs(1, 0, null, null, 0, "div", [["class", "carousel-arrow carousel-arrow-prev"]], [[2, "carousel-arrow-disabled", null]], [[null, "click"]], (function (t, e, n) { var i = !0; return "click" === e && (i = !1 !== t.component.prev() && i), i }), null, null)), (t()(), Rs(2, 0, null, null, 0, "div", [["class", "carousel-arrow carousel-arrow-next"]], [[2, "carousel-arrow-disabled", null]], [[null, "click"]], (function (t, e, n) { var i = !0; return "click" === e && (i = !1 !== t.component.next() && i), i }), null, null))], null, (function (t, e) { var n = e.component; t(e, 0, 0, n.arrowsOutside, "dark" === n.arrowsTheme), t(e, 1, 0, n.isPrevArrowDisabled()), t(e, 2, 0, n.isNextArrowDisabled()) })) } function ow(t) { return Zs(0, [(t()(), As(16777216, null, null, 1, null, Xb)), Ki(1, 16384, null, 0, ql, [En, Cn], { ngIf: [0, "ngIf"] }, null), (t()(), Rs(2, 0, null, null, 6, "div", [["class", "carousel-container"]], [[2, "carousel-moving", null]], null, null, null, null)), (t()(), Rs(3, 0, [["cells", 1]], null, 3, "div", [["class", "carousel-cells"]], null, [[null, "transitionend"]], (function (t, e, n) { var i = !0; return "transitionend" === e && (i = !1 !== t.component.handleTransitionendCellContainer(n) && i), i }), null, null)), Hs(null, 0), (t()(), As(16777216, null, null, 1, null, nw)), Ki(6, 278528, null, 0, $l, [En, Cn, mn], { ngForOf: [0, "ngForOf"] }, null), (t()(), As(16777216, null, null, 1, null, rw)), Ki(8, 16384, null, 0, ql, [En, Cn], { ngIf: [0, "ngIf"] }, null), (t()(), As(16777216, null, null, 1, null, sw)), Ki(10, 16384, null, 0, ql, [En, Cn], { ngIf: [0, "ngIf"] }, null)], (function (t, e) { var n = e.component; t(e, 1, 0, n.isCounter), t(e, 6, 0, n.images), t(e, 8, 0, n.dots), t(e, 10, 0, n.arrows) }), (function (t, e) { t(e, 2, 0, e.component.isMoving) })) } function lw(t) { return Zs(0, [(t()(), Rs(0, 0, null, null, 1, "carousel", [], [[2, "carousel", null], [4, "height", null], [4, "width", null]], [["window", "resize"], [null, "mousemove"], [null, "mouseleave"]], (function (t, e, n) { var i = !0; return "window:resize" === e && (i = !1 !== Li(t, 1).onWindowResize(n) && i), "mousemove" === e && (i = !1 !== Li(t, 1).onMousemove(n) && i), "mouseleave" === e && (i = !1 !== Li(t, 1).onMouseleave(n) && i), i }), ow, Yb)), Ki(1, 4964352, null, 0, Qb, [Qe, _n], null, null)], (function (t, e) { t(e, 1, 0) }), (function (t, e) { t(e, 0, 0, Li(e, 1).hostClassCarousel, Li(e, 1).hostStyleHeight, Li(e, 1).hostStyleWidth) })) } var aw = Ti("carousel, [carousel]", Qb, lw, { images: "images", height: "height", width: "width", loop: "loop", autoplay: "autoplay", autoplayInterval: "autoplayInterval", pauseOnHover: "pauseOnHover", dots: "dots", borderRadius: "borderRadius", margin: "margin", objectFit: "objectFit", minSwipeDistance: "minSwipeDistance", transitionDuration: "transitionDuration", transitionTimingFunction: "transitionTimingFunction", videoProperties: "videoProperties", counterSeparator: "counterSeparator", overflowCellsLimit: "overflowCellsLimit", listeners: "listeners", cellWidth: "cellWidth", isCounter: "counter", arrows: "arrows", arrowsOutside: "arrowsOutside", arrowsTheme: "arrowsTheme" }, { events: "events" }, ["*"]); class cw { constructor(t) { this._elementRef = t } } const uw = Lp(cw); let hw = (() => class extends uw { constructor(t, e, n) { super(t), this._platform = e, this._document = n } ngAfterViewInit() { Yt() && this._platform.isBrowser && (this._checkToolbarMixedModes(), this._toolbarRows.changes.subscribe(() => this._checkToolbarMixedModes())) } _checkToolbarMixedModes() { this._toolbarRows.length && Array.from(this._elementRef.nativeElement.childNodes).filter(t => !(t.classList && t.classList.contains("mat-toolbar-row"))).filter(t => t.nodeType !== (this._document ? this._document.COMMENT_NODE : 8)).some(t => !(!t.textContent || !t.textContent.trim())) && function () { throw Error("MatToolbar: Attempting to combine different toolbar modes. Either specify multiple `<mat-toolbar-row>` elements explicitly or just place content inside of a `<mat-toolbar>` for a single row.") }() } })(), dw = (() => class { })(); var pw = jn({ encapsulation: 2, styles: ["@media (-ms-high-contrast:active){.mat-toolbar{outline:solid 1px}}.mat-toolbar-row,.mat-toolbar-single-row{display:flex;box-sizing:border-box;padding:0 16px;width:100%;flex-direction:row;align-items:center;white-space:nowrap}.mat-toolbar-multiple-rows{display:flex;box-sizing:border-box;flex-direction:column;width:100%}.mat-toolbar-multiple-rows{min-height:64px}.mat-toolbar-row,.mat-toolbar-single-row{height:64px}@media (max-width:599px){.mat-toolbar-multiple-rows{min-height:56px}.mat-toolbar-row,.mat-toolbar-single-row{height:56px}}"], data: {} }); function fw(t) { return Zs(2, [Hs(null, 0), Hs(null, 1)], null, null) } class mw { } class gw { constructor(t, e) { this.dialogRef = t, this.data = e, this.client = { fullName: "" }, this.transition = { perfume: "", value: 0 } } ngOnInit() { } close() { let t; switch (this.data.type) { case "client": t = this.client; break; case "transition": t = this.transition }this.dialogRef.close(t) } } class _w { constructor(t, e) { this.dialogRef = t, this.data = e } } class yw { constructor(t, e, n, i) { this.dialog = t, this.auth = e, this.http = n, this.cdr = i, this.clients = [], this.search = new F_(""), this.filter = [] } ngOnInit() { return yv(this, void 0, void 0, (function* () { this.clients = yield this.http.getClients().toPromise(), this.filter = this.clients, this.search.valueChanges.pipe(wp(1e3)).subscribe(t => { console.log(t), this.filter = "" === t ? this.clients : this.clients.filter(e => e.fullName.search(t) > -1) }) })) } disconnect() { this.auth.logout() } addTransaction(t) { return yv(this, void 0, void 0, (function* () { const e = this.dialog.open(gw, { width: "400px", data: { type: "transition" } }); let n = yield e.afterClosed().toPromise(); if (!n) return; n.value = Number.parseInt(n.value); let i = yield this.http.addTransaction(n, t.id).catch(t => { this.fail("cant add this user try again") }); if (i) { t.transactions || (t.transactions = []), t.average = i.average, t.count = i.count, 0 === i.count && this.gift(t), t.transactions.push(i.transaction); let e = [...this.filter]; this.filter = [], setTimeout(() => { this.filter = [...e] }, 200) } })) } createClient() { return yv(this, void 0, void 0, (function* () { this.dialog.open(gw, { width: "400px", data: { type: "client" } }).afterClosed().subscribe(t => yv(this, void 0, void 0, (function* () { if (!t) return; let e = yield this.http.addClient(t).catch(t => { this.fail("cant add this user try again") }); e && this.clients.push(e) }))) })) } deleteClient(t) { return yv(this, void 0, void 0, (function* () { let e = yield this.dialog.open(mw).afterClosed().toPromise(); if (console.log(e), e) { yield this.http.deleteClient(t.id).toPromise(), this.clients = this.clients.filter(e => e.id !== t.id), this.filter = this.filter.filter(e => e.id !== t.id); let e = [...this.filter]; this.filter = [], setTimeout(() => { this.filter = [...e] }, 200) } })) } gift(t) { return yv(this, void 0, void 0, (function* () { const e = this.dialog.open(_w, { width: "400px", data: t }); yield e.afterClosed().toPromise() })) } fail(t) { return yv(this, void 0, void 0, (function* () { const e = this.dialog.open(vv, { width: "400px", data: { description: t, primary: { icon: "refresh", text: " OK" }, secondary: { icon: "close", text: " cancel" } } }); yield e.afterClosed().toPromise() })) } trackbyfnclient(t, e) { return `${t}-${e.fullName}` } trackbyfntransaction(t, e) { return t } } var vw = jn({ encapsulation: 0, styles: [['[_nghost-%COMP%]{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column;-webkit-box-align:center;align-items:center;-webkit-box-pack:start;justify-content:flex-start;min-height:100vh;padding-bottom:100px;background-color:#f5f5f5}.search-bar[_ngcontent-%COMP%]{position:relative;margin-top:36px;padding:6px 16px;border-radius:24px;background-color:#fff}.search-bar[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{border:none;outline:0;margin-right:8px}.search-bar[_ngcontent-%COMP%]   .add[_ngcontent-%COMP%]{position:absolute;right:-60px;top:7px}.user-card[_ngcontent-%COMP%]{position:relative;width:100%;min-height:280px;max-width:900px;margin-top:32px;background-color:#fff;overflow:hidden}.user-card[_ngcontent-%COMP%]   .name[_ngcontent-%COMP%]{margin-top:22px;margin-left:22px;font-size:26px;font-weight:800}.user-card[_ngcontent-%COMP%] > .amount[_ngcontent-%COMP%]{position:absolute;bottom:12px;right:12px;display:-webkit-box;display:flex;-webkit-box-align:center;align-items:center;-webkit-box-pack:center;justify-content:center}.user-card[_ngcontent-%COMP%] > .amount[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{font-size:18px;font-weight:800}.user-card[_ngcontent-%COMP%]   .count[_ngcontent-%COMP%]{position:absolute;right:0;top:0}.user-card[_ngcontent-%COMP%]   .count[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{position:absolute;top:12px;left:-32px;z-index:2;font-size:28px;font-weight:800}.user-card[_ngcontent-%COMP%]   .count[_ngcontent-%COMP%]:after{content:"";position:absolute;right:-40px;top:-12px;-webkit-transform:rotate(45deg);transform:rotate(45deg);width:120px;height:64px;background-color:#7fff00}.user-card[_ngcontent-%COMP%]   .delete[_ngcontent-%COMP%]{position:absolute;left:8px;bottom:8px;color:red}.user-card[_ngcontent-%COMP%]   .carousel[_ngcontent-%COMP%]{margin-left:70px;margin-top:40px;width:calc(100% - 140px)!important}.user-card[_ngcontent-%COMP%]   .carousel-cell[_ngcontent-%COMP%]{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column;align-content:center;-webkit-box-pack:center;justify-content:center;height:100px;margin-top:4px;margin-left:4px}.user-card[_ngcontent-%COMP%]   .carousel-cell[_ngcontent-%COMP%]   .amount[_ngcontent-%COMP%]{display:-webkit-box;display:flex;-webkit-box-align:center;align-items:center;margin-top:2px;color:grey}.user-card[_ngcontent-%COMP%]   .carousel-cell[_ngcontent-%COMP%]   .amount[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{font-size:20px;margin-right:6px}.user-card[_ngcontent-%COMP%]   .carousel-cell[_ngcontent-%COMP%]   .perfume[_ngcontent-%COMP%]{margin-top:2px;font-size:26px}.user-card[_ngcontent-%COMP%]   .carousel-cell[_ngcontent-%COMP%]   .date[_ngcontent-%COMP%]{margin-top:8px;color:grey;font-size:16px}.disconnect[_ngcontent-%COMP%]{position:fixed;right:24px;bottom:24px;z-index:40000}.search-bar[_ngcontent-%COMP%], .shadow[_ngcontent-%COMP%], .user-card[_ngcontent-%COMP%], .user-card[_ngcontent-%COMP%]   .carousel-cell[_ngcontent-%COMP%], mat-toolbar[_ngcontent-%COMP%]{box-shadow:0 3px 1px -2px rgba(0,0,0,.2),0 2px 2px 0 rgba(0,0,0,.14),0 1px 5px 0 rgba(0,0,0,.12)}.ripple[_ngcontent-%COMP%], .user-card[_ngcontent-%COMP%]   .count[_ngcontent-%COMP%], .user-card[_ngcontent-%COMP%]   .count[_ngcontent-%COMP%]:after{cursor:pointer;background-position:center;-webkit-transition:background .8s;transition:background .8s}.ripple[_ngcontent-%COMP%]:active, .user-card[_ngcontent-%COMP%]   .count[_ngcontent-%COMP%]:active, .user-card[_ngcontent-%COMP%]   .count[_ngcontent-%COMP%]:active:after{background-color:#c7c4c4;background-size:100%;-webkit-transition:background;transition:background 0s}']], data: {} }); function bw(t) { return Zs(0, [(t()(), Rs(0, 0, null, null, 8, "div", [["class", "carousel-cell"]], null, null, null, null, null)), (t()(), Rs(1, 0, null, null, 1, "span", [["class", "perfume"]], null, null, null, null, null)), (t()(), Ws(2, null, ["", ""])), (t()(), Rs(3, 0, null, null, 2, "div", [["class", "amount"]], null, null, null, null, null)), (t()(), Rs(4, 0, null, null, 1, "span", [], null, null, null, null, null)), (t()(), Ws(5, null, ["", " DA"])), (t()(), Rs(6, 0, null, null, 2, "div", [["class", "date"]], null, null, null, null, null)), (t()(), Ws(7, null, ["", ""])), $s(128, 8, new Array(2))], null, (function (t, e) { t(e, 2, 0, e.context.$implicit.perfume), t(e, 5, 0, e.context.$implicit.value); var n = function (t, e, n, i) { if (Ne.isWrapped(i)) { i = Ne.unwrap(i); const e = t.def.nodes[7].bindingIndex + 0, n = Ne.unwrap(t.oldValues[e]); t.oldValues[e] = new Ne(n) } return i }(e, 0, 0, t(e, 8, 0, Li(e.parent.parent, 0), e.context.$implicit.createdAt)); t(e, 7, 0, n) })) } function ww(t) { return Zs(0, [(t()(), Rs(0, 0, null, null, 20, "div", [["class", "user-card"]], null, null, null, null, null)), (t()(), Rs(1, 0, null, null, 1, "div", [["class", "name"]], null, null, null, null, null)), (t()(), Ws(2, null, ["", ""])), (t()(), Rs(3, 0, null, null, 2, "div", [["class", "count"]], null, [[null, "click"]], (function (t, e, n) { var i = !0; return "click" === e && (i = !1 !== t.component.addTransaction(t.context.$implicit) && i), i }), null, null)), (t()(), Rs(4, 0, null, null, 1, "span", [], null, null, null, null, null)), (t()(), Ws(5, null, ["", ""])), (t()(), Rs(6, 0, null, null, 5, "div", [["class", "amount"]], null, null, null, null, null)), (t()(), Rs(7, 0, null, null, 2, "mat-icon", [["class", "mat-icon notranslate"], ["role", "img"], ["style", "margin-right: 8px;"]], [[2, "mat-icon-inline", null], [2, "mat-icon-no-color", null]], null, null, uv, cv)), Ki(8, 9158656, null, 0, lv, [Qe, Xy, [8, null], [2, iv], [2, Te]], null, null), (t()(), Ws(-1, 0, ["functions"])), (t()(), Rs(10, 0, null, null, 1, "span", [], null, null, null, null, null)), (t()(), Ws(11, null, ["", " DA"])), (t()(), Rs(12, 0, null, null, 4, "button", [["class", "delete"], ["mat-icon-button", ""]], [[1, "disabled", 0], [2, "_mat-animation-noopable", null]], [[null, "click"]], (function (t, e, n) { var i = !0; return "click" === e && (i = !1 !== t.component.deleteClient(t.context.$implicit) && i), i }), _v, gv)), Ki(13, 180224, null, 0, fv, [Qe, Ap, [2, Ag]], null, null), (t()(), Rs(14, 0, null, 0, 2, "mat-icon", [["class", "mat-icon notranslate"], ["role", "img"]], [[2, "mat-icon-inline", null], [2, "mat-icon-no-color", null]], null, null, uv, cv)), Ki(15, 9158656, null, 0, lv, [Qe, Xy, [8, null], [2, iv], [2, Te]], null, null), (t()(), Ws(-1, 0, ["delete"])), (t()(), Rs(17, 0, null, null, 3, "carousel", [["arrowsOutside", "true"]], [[2, "carousel", null], [4, "height", null], [4, "width", null]], [["window", "resize"], [null, "mousemove"], [null, "mouseleave"]], (function (t, e, n) { var i = !0; return "window:resize" === e && (i = !1 !== Li(t, 18).onWindowResize(n) && i), "mousemove" === e && (i = !1 !== Li(t, 18).onMousemove(n) && i), "mouseleave" === e && (i = !1 !== Li(t, 18).onMouseleave(n) && i), i }), ow, Yb)), Ki(18, 4964352, null, 0, Qb, [Qe, _n], { height: [0, "height"], width: [1, "width"], arrowsOutside: [2, "arrowsOutside"] }, null), (t()(), As(16777216, null, 0, 1, null, bw)), Ki(20, 278528, null, 0, $l, [En, Cn, mn], { ngForOf: [0, "ngForOf"], ngForTrackBy: [1, "ngForTrackBy"] }, null)], (function (t, e) { var n = e.component; t(e, 8, 0), t(e, 15, 0), t(e, 18, 0, 108, "90%", "true"), t(e, 20, 0, e.context.$implicit.transactions, n.trackbyfntransaction) }), (function (t, e) { t(e, 2, 0, e.context.$implicit.fullName), t(e, 5, 0, e.context.$implicit.count), t(e, 7, 0, Li(e, 8).inline, "primary" !== Li(e, 8).color && "accent" !== Li(e, 8).color && "warn" !== Li(e, 8).color), t(e, 11, 0, e.context.$implicit.average), t(e, 12, 0, Li(e, 13).disabled || null, "NoopAnimations" === Li(e, 13)._animationMode), t(e, 14, 0, Li(e, 15).inline, "primary" !== Li(e, 15).color && "accent" !== Li(e, 15).color && "warn" !== Li(e, 15).color), t(e, 17, 0, Li(e, 18).hostClassCarousel, Li(e, 18).hostStyleHeight, Li(e, 18).hostStyleWidth) })) } function Cw(t) { return Zs(0, [(e = 0, n = Xl, i = [Ar], Xi(-1, e |= 16, null, 0, n, n, i)), (t()(), Rs(1, 0, null, null, 4, "mat-toolbar", [["class", "mat-toolbar"], ["color", "primary"]], [[2, "mat-toolbar-multiple-rows", null], [2, "mat-toolbar-single-row", null]], null, null, fw, pw)), Ki(2, 4243456, null, 1, hw, [Qe, up, ta], { color: [0, "color"] }, null), Ls(603979776, 1, { _toolbarRows: 1 }), (t()(), Rs(4, 0, null, 0, 1, "span", [], null, null, null, null, null)), (t()(), Ws(-1, null, ["Parfumerie nour el houda"])), (t()(), Rs(6, 0, null, null, 4, "button", [["class", "disconnect"], ["color", "accent"], ["mat-fab", ""]], [[1, "disabled", 0], [2, "_mat-animation-noopable", null]], [[null, "click"]], (function (t, e, n) { var i = !0; return "click" === e && (i = !1 !== t.component.disconnect() && i), i }), _v, gv)), Ki(7, 180224, null, 0, fv, [Qe, Ap, [2, Ag]], { color: [0, "color"] }, null), (t()(), Rs(8, 0, null, 0, 2, "mat-icon", [["class", "mat-icon notranslate"], ["role", "img"]], [[2, "mat-icon-inline", null], [2, "mat-icon-no-color", null]], null, null, uv, cv)), Ki(9, 9158656, null, 0, lv, [Qe, Xy, [8, null], [2, iv], [2, Te]], null, null), (t()(), Ws(-1, 0, ["exit_to_app"])), (t()(), Rs(11, 0, null, null, 21, "div", [["class", "search-bar"]], null, null, null, null, null)), (t()(), Rs(12, 0, null, null, 4, "button", [["mat-icon-button", ""]], [[1, "disabled", 0], [2, "_mat-animation-noopable", null]], null, null, _v, gv)), Ki(13, 180224, null, 0, fv, [Qe, Ap, [2, Ag]], null, null), (t()(), Rs(14, 0, null, 0, 2, "mat-icon", [["class", "mat-icon notranslate"], ["role", "img"]], [[2, "mat-icon-inline", null], [2, "mat-icon-no-color", null]], null, null, uv, cv)), Ki(15, 9158656, null, 0, lv, [Qe, Xy, [8, null], [2, iv], [2, Te]], null, null), (t()(), Ws(-1, 0, ["search"])), (t()(), Rs(17, 0, null, null, 5, "input", [["type", "text"]], [[2, "ng-untouched", null], [2, "ng-touched", null], [2, "ng-pristine", null], [2, "ng-dirty", null], [2, "ng-valid", null], [2, "ng-invalid", null], [2, "ng-pending", null]], [[null, "input"], [null, "blur"], [null, "compositionstart"], [null, "compositionend"]], (function (t, e, n) { var i = !0; return "input" === e && (i = !1 !== Li(t, 18)._handleInput(n.target.value) && i), "blur" === e && (i = !1 !== Li(t, 18).onTouched() && i), "compositionstart" === e && (i = !1 !== Li(t, 18)._compositionStart() && i), "compositionend" === e && (i = !1 !== Li(t, 18)._compositionEnd(n.target.value) && i), i }), null, null)), Ki(18, 16384, null, 0, Yg, [tn, Qe, [2, Kg]], null, null), Yi(1024, null, Zg, (function (t) { return [t] }), [Yg]), Ki(20, 540672, null, 0, Z_, [[8, null], [8, null], [6, Zg], [2, G_]], { form: [0, "form"] }, null), Yi(2048, null, e_, null, [Z_]), Ki(22, 16384, null, 0, n_, [[4, e_]], null, null), (t()(), Rs(23, 0, null, null, 4, "button", [["mat-icon-button", ""]], [[1, "disabled", 0], [2, "_mat-animation-noopable", null]], null, null, _v, gv)), Ki(24, 180224, null, 0, fv, [Qe, Ap, [2, Ag]], null, null), (t()(), Rs(25, 0, null, 0, 2, "mat-icon", [["class", "mat-icon notranslate"], ["role", "img"]], [[2, "mat-icon-inline", null], [2, "mat-icon-no-color", null]], null, null, uv, cv)), Ki(26, 9158656, null, 0, lv, [Qe, Xy, [8, null], [2, iv], [2, Te]], null, null), (t()(), Ws(-1, 0, ["settings"])), (t()(), Rs(28, 0, null, null, 4, "button", [["class", "add"], ["color", "primary"], ["mat-mini-fab", ""]], [[1, "disabled", 0], [2, "_mat-animation-noopable", null]], [[null, "click"]], (function (t, e, n) { var i = !0; return "click" === e && (i = !1 !== t.component.createClient() && i), i }), _v, gv)), Ki(29, 180224, null, 0, fv, [Qe, Ap, [2, Ag]], { color: [0, "color"] }, null), (t()(), Rs(30, 0, null, 0, 2, "mat-icon", [["class", "mat-icon notranslate"], ["role", "img"]], [[2, "mat-icon-inline", null], [2, "mat-icon-no-color", null]], null, null, uv, cv)), Ki(31, 9158656, null, 0, lv, [Qe, Xy, [8, null], [2, iv], [2, Te]], null, null), (t()(), Ws(-1, 0, ["add"])), (t()(), As(16777216, null, null, 1, null, ww)), Ki(34, 278528, null, 0, $l, [En, Cn, mn], { ngForOf: [0, "ngForOf"], ngForTrackBy: [1, "ngForTrackBy"] }, null)], (function (t, e) { var n = e.component; t(e, 2, 0, "primary"), t(e, 7, 0, "accent"), t(e, 9, 0), t(e, 15, 0), t(e, 20, 0, n.search), t(e, 26, 0), t(e, 29, 0, "primary"), t(e, 31, 0), t(e, 34, 0, n.filter, n.trackbyfnclient) }), (function (t, e) { t(e, 1, 0, Li(e, 2)._toolbarRows.length > 0, 0 === Li(e, 2)._toolbarRows.length), t(e, 6, 0, Li(e, 7).disabled || null, "NoopAnimations" === Li(e, 7)._animationMode), t(e, 8, 0, Li(e, 9).inline, "primary" !== Li(e, 9).color && "accent" !== Li(e, 9).color && "warn" !== Li(e, 9).color), t(e, 12, 0, Li(e, 13).disabled || null, "NoopAnimations" === Li(e, 13)._animationMode), t(e, 14, 0, Li(e, 15).inline, "primary" !== Li(e, 15).color && "accent" !== Li(e, 15).color && "warn" !== Li(e, 15).color), t(e, 17, 0, Li(e, 22).ngClassUntouched, Li(e, 22).ngClassTouched, Li(e, 22).ngClassPristine, Li(e, 22).ngClassDirty, Li(e, 22).ngClassValid, Li(e, 22).ngClassInvalid, Li(e, 22).ngClassPending), t(e, 23, 0, Li(e, 24).disabled || null, "NoopAnimations" === Li(e, 24)._animationMode), t(e, 25, 0, Li(e, 26).inline, "primary" !== Li(e, 26).color && "accent" !== Li(e, 26).color && "warn" !== Li(e, 26).color), t(e, 28, 0, Li(e, 29).disabled || null, "NoopAnimations" === Li(e, 29)._animationMode), t(e, 30, 0, Li(e, 31).inline, "primary" !== Li(e, 31).color && "accent" !== Li(e, 31).color && "warn" !== Li(e, 31).color) })); var e, n, i } function Sw(t) { return Zs(0, [(t()(), Rs(0, 0, null, null, 1, "app-board", [], null, null, null, Cw, vw)), Ki(1, 114688, null, 0, yw, [Nb, zv, Vv, _n], null, null)], (function (t, e) { t(e, 1, 0) }), null) } var Ew = Ti("app-board", yw, Sw, {}, {}, []), xw = jn({ encapsulation: 2, styles: [".mat-dialog-container{display:block;padding:24px;border-radius:4px;box-sizing:border-box;overflow:auto;outline:0;width:100%;height:100%;min-height:inherit;max-height:inherit}@media (-ms-high-contrast:active){.mat-dialog-container{outline:solid 1px}}.mat-dialog-content{display:block;margin:0 -24px;padding:0 24px;max-height:65vh;overflow:auto;-webkit-overflow-scrolling:touch}.mat-dialog-title{margin:0 0 20px;display:block}.mat-dialog-actions{padding:8px 0;display:flex;flex-wrap:wrap;min-height:52px;align-items:center;margin-bottom:-24px}.mat-dialog-actions[align=end]{justify-content:flex-end}.mat-dialog-actions[align=center]{justify-content:center}.mat-dialog-actions .mat-button-base+.mat-button-base{margin-left:8px}[dir=rtl] .mat-dialog-actions .mat-button-base+.mat-button-base{margin-left:0;margin-right:8px}"], data: { animation: [{ type: 7, name: "dialogContainer", definitions: [{ type: 0, name: "void, exit", styles: { type: 6, styles: { opacity: 0, transform: "scale(0.7)" }, offset: null }, options: void 0 }, { type: 0, name: "enter", styles: { type: 6, styles: { transform: "none" }, offset: null }, options: void 0 }, { type: 1, expr: "* => enter", animation: { type: 4, styles: { type: 6, styles: { transform: "none", opacity: 1 }, offset: null }, timings: "150ms cubic-bezier(0, 0, 0.2, 1)" }, options: null }, { type: 1, expr: "* => void, * => exit", animation: { type: 4, styles: { type: 6, styles: { opacity: 0 }, offset: null }, timings: "75ms cubic-bezier(0.4, 0.0, 0.2, 1)" }, options: null }], options: {} }] } }); function Tw(t) { return Zs(0, [(t()(), As(0, null, null, 0))], null, null) } function kw(t) { return Zs(0, [Ls(402653184, 1, { _portalOutlet: 0 }), (t()(), As(16777216, null, null, 1, null, Tw)), Ki(2, 212992, [[1, 4]], 0, qv, [Be, En], { portal: [0, "portal"] }, null)], (function (t, e) { t(e, 2, 0, "") }), null) } function Pw(t) { return Zs(0, [(t()(), Rs(0, 0, null, null, 1, "mat-dialog-container", [["aria-modal", "true"], ["class", "mat-dialog-container"], ["tabindex", "-1"]], [[1, "id", 0], [1, "role", 0], [1, "aria-labelledby", 0], [1, "aria-label", 0], [1, "aria-describedby", 0], [40, "@dialogContainer", 0]], [["component", "@dialogContainer.start"], ["component", "@dialogContainer.done"]], (function (t, e, n) { var i = !0; return "component:@dialogContainer.start" === e && (i = !1 !== Li(t, 1)._onAnimationStart(n) && i), "component:@dialogContainer.done" === e && (i = !1 !== Li(t, 1)._onAnimationDone(n) && i), i }), kw, xw)), Ki(1, 49152, null, 0, Tb, [Qe, Op, _n, [2, ta], Eb], null, null)], null, (function (t, e) { t(e, 0, 0, Li(e, 1)._id, Li(e, 1)._config.role, Li(e, 1)._config.ariaLabel ? null : Li(e, 1)._ariaLabelledBy, Li(e, 1)._config.ariaLabel, Li(e, 1)._config.ariaDescribedBy || null, Li(e, 1)._state) })) } var Ow = Ti("mat-dialog-container", Tb, Pw, {}, {}, []), Iw = jn({ encapsulation: 2, styles: [], data: {} }); function Aw(t) { return Zs(0, [(t()(), Rs(0, 0, null, null, 2, "h2", [["class", "mat-dialog-title"], ["mat-dialog-title", ""]], [[8, "id", 0]], null, null, null, null)), Ki(1, 81920, null, 0, Fb, [[2, Pb], Qe, Nb], null, null), (t()(), Ws(2, null, ["", ""])), (t()(), Rs(3, 0, null, null, 5, "mat-dialog-content", [["class", "mat-dialog-content"]], null, null, null, null, null)), Ki(4, 16384, null, 0, Lb, [], null, null), (t()(), Ws(-1, null, [" Averege of the last 5 buys is "])), (t()(), Rs(6, 0, null, null, 1, "span", [["style", "margin-left: 4px;font-weight: 800;margin-right: 2px;"]], null, null, null, null, null)), (t()(), Ws(7, null, ["", ""])), (t()(), Ws(-1, null, [" DA\n"])), (t()(), Rs(9, 0, null, null, 5, "mat-dialog-actions", [["class", "mat-dialog-actions"]], null, null, null, null, null)), Ki(10, 16384, null, 0, Vb, [], null, null), (t()(), Rs(11, 0, null, null, 3, "button", [["mat-button", ""]], [[1, "disabled", 0], [2, "_mat-animation-noopable", null], [1, "aria-label", 0], [1, "type", 0]], [[null, "click"]], (function (t, e, n) { var i = !0; return "click" === e && (i = !1 !== Li(t, 13).dialogRef.close(Li(t, 13).dialogResult) && i), i }), _v, gv)), Ki(12, 180224, null, 0, fv, [Qe, Ap, [2, Ag]], null, null), Ki(13, 606208, null, 0, Db, [[2, Pb], Qe, Nb], { dialogResult: [0, "dialogResult"] }, null), (t()(), Ws(-1, 0, ["OK"]))], (function (t, e) { t(e, 1, 0), t(e, 13, 0, !0) }), (function (t, e) { var n = e.component; t(e, 0, 0, Li(e, 1).id), t(e, 2, 0, n.data.fullName), t(e, 7, 0, n.data.average), t(e, 11, 0, Li(e, 12).disabled || null, "NoopAnimations" === Li(e, 12)._animationMode, Li(e, 13).ariaLabel || null, Li(e, 13).type) })) } function Rw(t) { return Zs(0, [(t()(), Rs(0, 0, null, null, 1, "gift-overlay", [], null, null, null, Aw, Iw)), Ki(1, 49152, null, 0, _w, [Pb, Ob], null, null)], null, null) } var Nw = Ti("gift-overlay", _w, Rw, {}, {}, []), Mw = jn({ encapsulation: 0, styles: [['.content-container[_ngcontent-%COMP%]{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column;justify-items:center;-webkit-box-align:center;align-items:center;width:100%;height:100%;border-radius:4px;margin:0;padding:0;background-color:#fff;overflow:hidden}.content-container[_ngcontent-%COMP%]   .send[_ngcontent-%COMP%]{margin-top:37px}.content-container[_ngcontent-%COMP%]   .description[_ngcontent-%COMP%]{max-width:300px;margin-top:24px;font-size:16px;font-weight:500;font-style:normal;font-stretch:normal;line-height:1.5;letter-spacing:normal;text-align:center;color:#3b3b3b}.content-container[_ngcontent-%COMP%]   .actions[_ngcontent-%COMP%]{display:-webkit-box;display:flex;margin:32px 0}.content-container[_ngcontent-%COMP%]   .actions[_ngcontent-%COMP%]   .close[_ngcontent-%COMP%]{height:40px;margin-right:24px;font-size:14px;font-weight:500;font-style:normal;font-stretch:normal;line-height:normal;letter-spacing:.54px;text-align:center;color:#a7a7a7}.content-container[_ngcontent-%COMP%]   .actions[_ngcontent-%COMP%]   .next[_ngcontent-%COMP%]{width:167px;height:40px;border-radius:4px;font-size:14px;font-weight:500;font-style:normal;font-stretch:normal;line-height:normal;letter-spacing:.54px;text-align:center;color:#fff}.lds-roller[_ngcontent-%COMP%]{display:inline-block;position:relative;width:64px;height:64px;margin:100px 0;-webkit-transform:scale(2);transform:scale(2)}.lds-roller[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]{-webkit-animation:1.2s cubic-bezier(.5,0,.5,1) infinite lds-roller;animation:1.2s cubic-bezier(.5,0,.5,1) infinite lds-roller;-webkit-transform-origin:32px 32px;transform-origin:32px 32px}.lds-roller[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:after{content:" ";display:block;position:absolute;width:6px;height:6px;border-radius:50%;background:#7dc40c;margin:-3px 0 0 -3px}.lds-roller[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:nth-child(1){-webkit-animation-delay:-36ms;animation-delay:-36ms}.lds-roller[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:nth-child(1):after{top:50px;left:50px}.lds-roller[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:nth-child(2){-webkit-animation-delay:-72ms;animation-delay:-72ms}.lds-roller[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:nth-child(2):after{top:54px;left:45px}.lds-roller[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:nth-child(3){-webkit-animation-delay:-108ms;animation-delay:-108ms}.lds-roller[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:nth-child(3):after{top:57px;left:39px}.lds-roller[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:nth-child(4){-webkit-animation-delay:-144ms;animation-delay:-144ms}.lds-roller[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:nth-child(4):after{top:58px;left:32px}.lds-roller[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:nth-child(5){-webkit-animation-delay:-.18s;animation-delay:-.18s}.lds-roller[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:nth-child(5):after{top:57px;left:25px}.lds-roller[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:nth-child(6){-webkit-animation-delay:-216ms;animation-delay:-216ms}.lds-roller[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:nth-child(6):after{top:54px;left:19px}.lds-roller[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:nth-child(7){-webkit-animation-delay:-252ms;animation-delay:-252ms}.lds-roller[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:nth-child(7):after{top:50px;left:14px}.lds-roller[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:nth-child(8){-webkit-animation-delay:-288ms;animation-delay:-288ms}.lds-roller[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:nth-child(8):after{top:45px;left:10px}@-webkit-keyframes lds-roller{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes lds-roller{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}']], data: {} }); function Dw(t) { return Zs(0, [(t()(), Rs(0, 0, null, null, 0, null, null, null, null, null, null, null))], null, null) } function Fw(t) { return Zs(0, [(t()(), Rs(0, 0, null, null, 1, "span", [["class", "description"]], null, null, null, null, null)), (t()(), Ws(1, null, ["", ""])), (t()(), Rs(2, 0, null, null, 12, "div", [["class", "actions"]], null, null, null, null, null)), (t()(), Rs(3, 0, null, null, 5, "button", [["class", "close"], ["mat-button", ""]], [[1, "disabled", 0], [2, "_mat-animation-noopable", null]], [[null, "click"]], (function (t, e, n) { var i = !0; return "click" === e && (i = !1 !== t.component.close(!1) && i), i }), _v, gv)), Ki(4, 180224, null, 0, fv, [Qe, Ap, [2, Ag]], null, null), (t()(), Rs(5, 0, null, 0, 2, "mat-icon", [["class", "mat-icon notranslate"], ["role", "img"]], [[2, "mat-icon-inline", null], [2, "mat-icon-no-color", null]], null, null, uv, cv)), Ki(6, 9158656, null, 0, lv, [Qe, Xy, [8, null], [2, iv], [2, Te]], null, null), (t()(), Ws(7, 0, ["", ""])), (t()(), Ws(8, 0, ["", " "])), (t()(), Rs(9, 0, null, null, 5, "button", [["class", "next"], ["color", "primary"], ["mat-raised-button", ""]], [[1, "disabled", 0], [2, "_mat-animation-noopable", null]], [[null, "click"]], (function (t, e, n) { var i = !0; return "click" === e && (i = !1 !== t.component.close(!0) && i), i }), _v, gv)), Ki(10, 180224, null, 0, fv, [Qe, Ap, [2, Ag]], { color: [0, "color"] }, null), (t()(), Rs(11, 0, null, 0, 2, "mat-icon", [["class", "mat-icon notranslate"], ["role", "img"]], [[2, "mat-icon-inline", null], [2, "mat-icon-no-color", null]], null, null, uv, cv)), Ki(12, 9158656, null, 0, lv, [Qe, Xy, [8, null], [2, iv], [2, Te]], null, null), (t()(), Ws(13, 0, ["", ""])), (t()(), Ws(14, 0, ["", " "]))], (function (t, e) { t(e, 6, 0), t(e, 10, 0, "primary"), t(e, 12, 0) }), (function (t, e) { var n = e.component; t(e, 1, 0, n.data.description), t(e, 3, 0, Li(e, 4).disabled || null, "NoopAnimations" === Li(e, 4)._animationMode), t(e, 5, 0, Li(e, 6).inline, "primary" !== Li(e, 6).color && "accent" !== Li(e, 6).color && "warn" !== Li(e, 6).color), t(e, 7, 0, n.data.secondary.icon), t(e, 8, 0, n.data.secondary.text), t(e, 9, 0, Li(e, 10).disabled || null, "NoopAnimations" === Li(e, 10)._animationMode), t(e, 11, 0, Li(e, 12).inline, "primary" !== Li(e, 12).color && "accent" !== Li(e, 12).color && "warn" !== Li(e, 12).color), t(e, 13, 0, n.data.primary.icon), t(e, 14, 0, n.data.primary.text) })) } function Lw(t) { return Zs(0, [(t()(), Rs(0, 0, null, null, 8, "div", [["class", "lds-roller"]], null, null, null, null, null)), (t()(), Rs(1, 0, null, null, 0, "div", [], null, null, null, null, null)), (t()(), Rs(2, 0, null, null, 0, "div", [], null, null, null, null, null)), (t()(), Rs(3, 0, null, null, 0, "div", [], null, null, null, null, null)), (t()(), Rs(4, 0, null, null, 0, "div", [], null, null, null, null, null)), (t()(), Rs(5, 0, null, null, 0, "div", [], null, null, null, null, null)), (t()(), Rs(6, 0, null, null, 0, "div", [], null, null, null, null, null)), (t()(), Rs(7, 0, null, null, 0, "div", [], null, null, null, null, null)), (t()(), Rs(8, 0, null, null, 0, "div", [], null, null, null, null, null))], null, null) } function Vw(t) { return Zs(0, [(t()(), Rs(0, 0, null, null, 5, "div", [["class", "content-container mat-dialog-content"], ["mat-dialog-content", ""]], null, null, null, null, null)), Ki(1, 16384, null, 0, Lb, [], null, null), (t()(), As(16777216, null, null, 1, null, Dw)), Ki(3, 16384, null, 0, ql, [En, Cn], { ngIf: [0, "ngIf"], ngIfThen: [1, "ngIfThen"], ngIfElse: [2, "ngIfElse"] }, null), (t()(), As(0, [["thenTemplate", 2]], null, 0, null, Fw)), (t()(), As(0, [["elseTemplate", 2]], null, 0, null, Lw))], (function (t, e) { t(e, 3, 0, "waiting" != e.component.data.src, Li(e, 4), Li(e, 5)) }), null) } function zw(t) { return Zs(0, [(t()(), Rs(0, 0, null, null, 1, "app-overlay-view", [], null, null, null, Vw, Mw)), Ki(1, 114688, null, 0, vv, [Pb, Ob], null, null)], (function (t, e) { t(e, 1, 0) }), null) } var jw = Ti("app-overlay-view", vv, zw, {}, {}, []), Uw = jn({ encapsulation: 2, styles: [], data: {} }); function Hw(t) { return Zs(0, [(t()(), Rs(0, 0, null, null, 2, "h2", [["class", "mat-dialog-title"], ["mat-dialog-title", ""]], [[8, "id", 0]], null, null, null, null)), Ki(1, 81920, null, 0, Fb, [[2, Pb], Qe, Nb], null, null), (t()(), Ws(-1, null, ["Delete this client?"])), (t()(), Rs(3, 0, null, null, 2, "mat-dialog-content", [["class", "mat-dialog-content"]], null, null, null, null, null)), Ki(4, 16384, null, 0, Lb, [], null, null), (t()(), Ws(-1, null, ["This will delete this client that is currently on this page and cannot be undone.\n"])), (t()(), Rs(6, 0, null, null, 9, "mat-dialog-actions", [["class", "mat-dialog-actions"]], null, null, null, null, null)), Ki(7, 16384, null, 0, Vb, [], null, null), (t()(), Rs(8, 0, null, null, 3, "button", [["mat-button", ""], ["mat-dialog-close", ""]], [[1, "disabled", 0], [2, "_mat-animation-noopable", null], [1, "aria-label", 0], [1, "type", 0]], [[null, "click"]], (function (t, e, n) { var i = !0; return "click" === e && (i = !1 !== Li(t, 10).dialogRef.close(Li(t, 10).dialogResult) && i), i }), _v, gv)), Ki(9, 180224, null, 0, fv, [Qe, Ap, [2, Ag]], null, null), Ki(10, 606208, null, 0, Db, [[2, Pb], Qe, Nb], { dialogResult: [0, "dialogResult"] }, null), (t()(), Ws(-1, 0, ["Cancel"])), (t()(), Rs(12, 0, null, null, 3, "button", [["mat-button", ""]], [[1, "disabled", 0], [2, "_mat-animation-noopable", null], [1, "aria-label", 0], [1, "type", 0]], [[null, "click"]], (function (t, e, n) { var i = !0; return "click" === e && (i = !1 !== Li(t, 14).dialogRef.close(Li(t, 14).dialogResult) && i), i }), _v, gv)), Ki(13, 180224, null, 0, fv, [Qe, Ap, [2, Ag]], null, null), Ki(14, 606208, null, 0, Db, [[2, Pb], Qe, Nb], { dialogResult: [0, "dialogResult"] }, null), (t()(), Ws(-1, 0, ["Delete"]))], (function (t, e) { t(e, 1, 0), t(e, 10, 0, ""), t(e, 14, 0, !0) }), (function (t, e) { t(e, 0, 0, Li(e, 1).id), t(e, 8, 0, Li(e, 9).disabled || null, "NoopAnimations" === Li(e, 9)._animationMode, Li(e, 10).ariaLabel || null, Li(e, 10).type), t(e, 12, 0, Li(e, 13).disabled || null, "NoopAnimations" === Li(e, 13)._animationMode, Li(e, 14).ariaLabel || null, Li(e, 14).type) })) } function Bw(t) { return Zs(0, [(t()(), Rs(0, 0, null, null, 1, "confirmation-dialogue", [], null, null, null, Hw, Uw)), Ki(1, 49152, null, 0, mw, [], null, null)], null, null) } var $w = Ti("confirmation-dialogue", mw, Bw, {}, {}, []), Ww = jn({ encapsulation: 0, styles: [['.content-container[_ngcontent-%COMP%]{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column;justify-items:center;-webkit-box-align:center;align-items:center;width:100%;height:100%;border-radius:4px;margin:0;padding:0;background-color:#fff;overflow:hidden}.content-container[_ngcontent-%COMP%]   .create-client[_ngcontent-%COMP%]{display:-webkit-box;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column;-webkit-box-align:center;align-items:center}.content-container[_ngcontent-%COMP%]   .actions[_ngcontent-%COMP%]{display:-webkit-box;display:flex;margin:32px 0}.content-container[_ngcontent-%COMP%]   .actions[_ngcontent-%COMP%]   .close[_ngcontent-%COMP%]{height:40px;margin-right:24px;font-size:14px;font-weight:500;font-style:normal;font-stretch:normal;line-height:normal;letter-spacing:.54px;text-align:center;color:#a7a7a7}.content-container[_ngcontent-%COMP%]   .actions[_ngcontent-%COMP%]   .next[_ngcontent-%COMP%]{width:167px;height:40px;border-radius:4px;font-size:14px;font-weight:500;font-style:normal;font-stretch:normal;line-height:normal;letter-spacing:.54px;text-align:center;color:#fff}.lds-roller[_ngcontent-%COMP%]{display:inline-block;position:relative;width:64px;height:64px;margin:100px 0;-webkit-transform:scale(2);transform:scale(2)}.lds-roller[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]{-webkit-animation:1.2s cubic-bezier(.5,0,.5,1) infinite lds-roller;animation:1.2s cubic-bezier(.5,0,.5,1) infinite lds-roller;-webkit-transform-origin:32px 32px;transform-origin:32px 32px}.lds-roller[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:after{content:" ";display:block;position:absolute;width:6px;height:6px;border-radius:50%;background:#7dc40c;margin:-3px 0 0 -3px}.lds-roller[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:nth-child(1){-webkit-animation-delay:-36ms;animation-delay:-36ms}.lds-roller[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:nth-child(1):after{top:50px;left:50px}.lds-roller[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:nth-child(2){-webkit-animation-delay:-72ms;animation-delay:-72ms}.lds-roller[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:nth-child(2):after{top:54px;left:45px}.lds-roller[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:nth-child(3){-webkit-animation-delay:-108ms;animation-delay:-108ms}.lds-roller[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:nth-child(3):after{top:57px;left:39px}.lds-roller[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:nth-child(4){-webkit-animation-delay:-144ms;animation-delay:-144ms}.lds-roller[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:nth-child(4):after{top:58px;left:32px}.lds-roller[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:nth-child(5){-webkit-animation-delay:-.18s;animation-delay:-.18s}.lds-roller[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:nth-child(5):after{top:57px;left:25px}.lds-roller[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:nth-child(6){-webkit-animation-delay:-216ms;animation-delay:-216ms}.lds-roller[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:nth-child(6):after{top:54px;left:19px}.lds-roller[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:nth-child(7){-webkit-animation-delay:-252ms;animation-delay:-252ms}.lds-roller[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:nth-child(7):after{top:50px;left:14px}.lds-roller[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:nth-child(8){-webkit-animation-delay:-288ms;animation-delay:-288ms}.lds-roller[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:nth-child(8):after{top:45px;left:10px}@-webkit-keyframes lds-roller{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes lds-roller{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}']], data: {} }); function qw(t) { return Zs(0, [(t()(), Rs(0, 0, null, null, 2, "mat-hint", [["class", "mat-hint"]], [[2, "mat-right", null], [1, "id", 0], [1, "align", 0]], null, null, null, null)), Ki(1, 16384, [[7, 4]], 0, rf, [], null, null), (t()(), Ws(-1, null, ["Hint"]))], null, (function (t, e) { t(e, 0, 0, "end" == Li(e, 1).align, Li(e, 1).id, null) })) } function Gw(t) { return Zs(0, [(t()(), Rs(0, 0, null, null, 28, "div", [["class", "create-client"]], null, null, null, null, null)), (t()(), Rs(1, 0, null, null, 27, "mat-form-field", [["appearance", "outline"], ["class", "input login mat-form-field"]], [[2, "mat-form-field-appearance-standard", null], [2, "mat-form-field-appearance-fill", null], [2, "mat-form-field-appearance-outline", null], [2, "mat-form-field-appearance-legacy", null], [2, "mat-form-field-invalid", null], [2, "mat-form-field-can-float", null], [2, "mat-form-field-should-float", null], [2, "mat-form-field-has-label", null], [2, "mat-form-field-hide-placeholder", null], [2, "mat-form-field-disabled", null], [2, "mat-form-field-autofilled", null], [2, "mat-focused", null], [2, "mat-accent", null], [2, "mat-warn", null], [2, "ng-untouched", null], [2, "ng-touched", null], [2, "ng-pristine", null], [2, "ng-dirty", null], [2, "ng-valid", null], [2, "ng-invalid", null], [2, "ng-pending", null], [2, "_mat-animation-noopable", null]], null, null, Wg, Ng)), Ki(2, 7520256, null, 9, hf, [Qe, _n, [2, Qp], [2, yf], [2, uf], up, Zr, [2, Ag]], { appearance: [0, "appearance"] }, null), Ls(603979776, 1, { _controlNonStatic: 0 }), Ls(335544320, 2, { _controlStatic: 0 }), Ls(603979776, 3, { _labelChildNonStatic: 0 }), Ls(335544320, 4, { _labelChildStatic: 0 }), Ls(603979776, 5, { _placeholderChild: 0 }), Ls(603979776, 6, { _errorChildren: 1 }), Ls(603979776, 7, { _hintChildren: 1 }), Ls(603979776, 8, { _prefixChildren: 1 }), Ls(603979776, 9, { _suffixChildren: 1 }), (t()(), Rs(12, 0, null, 3, 2, "mat-label", [], null, null, null, null, null)), Ki(13, 16384, [[3, 4], [4, 4]], 0, sf, [], null, null), (t()(), Ws(-1, null, ["Client name"])), (t()(), Rs(15, 0, null, 1, 7, "input", [["class", "mat-input-element mat-form-field-autofill-control"], ["matInput", ""], ["placeholder", "Client name"]], [[2, "ng-untouched", null], [2, "ng-touched", null], [2, "ng-pristine", null], [2, "ng-dirty", null], [2, "ng-valid", null], [2, "ng-invalid", null], [2, "ng-pending", null], [2, "mat-input-server", null], [1, "id", 0], [1, "placeholder", 0], [8, "disabled", 0], [8, "required", 0], [1, "readonly", 0], [1, "aria-describedby", 0], [1, "aria-invalid", 0], [1, "aria-required", 0]], [[null, "ngModelChange"], [null, "input"], [null, "blur"], [null, "compositionstart"], [null, "compositionend"], [null, "focus"]], (function (t, e, n) { var i = !0, r = t.component; return "input" === e && (i = !1 !== Li(t, 16)._handleInput(n.target.value) && i), "blur" === e && (i = !1 !== Li(t, 16).onTouched() && i), "compositionstart" === e && (i = !1 !== Li(t, 16)._compositionStart() && i), "compositionend" === e && (i = !1 !== Li(t, 16)._compositionEnd(n.target.value) && i), "blur" === e && (i = !1 !== Li(t, 21)._focusChanged(!1) && i), "focus" === e && (i = !1 !== Li(t, 21)._focusChanged(!0) && i), "input" === e && (i = !1 !== Li(t, 21)._onInput() && i), "ngModelChange" === e && (i = !1 !== (r.client.fullName = n) && i), i }), null, null)), Ki(16, 16384, null, 0, Yg, [tn, Qe, [2, Kg]], null, null), Yi(1024, null, Zg, (function (t) { return [t] }), [Yg]), Ki(18, 671744, null, 0, q_, [[8, null], [8, null], [8, null], [6, Zg]], { model: [0, "model"] }, { update: "ngModelChange" }), Yi(2048, null, e_, null, [q_]), Ki(20, 16384, null, 0, n_, [[4, e_]], null, null), Ki(21, 999424, null, 0, dy, [Qe, up, [6, e_], [2, j_], [2, Q_], jp, [8, null], oy, Zr], { placeholder: [0, "placeholder"] }, null), Yi(2048, [[1, 4], [2, 4]], tf, null, [dy]), (t()(), Rs(23, 0, null, 4, 3, "mat-icon", [["class", "mat-icon notranslate"], ["matSuffix", ""], ["role", "img"]], [[2, "mat-icon-inline", null], [2, "mat-icon-no-color", null]], null, null, uv, cv)), Ki(24, 16384, [[9, 4]], 0, of, [], null, null), Ki(25, 9158656, null, 0, lv, [Qe, Xy, [8, null], [2, iv], [2, Te]], null, null), (t()(), Ws(-1, 0, ["sentiment_very_satisfied"])), (t()(), As(16777216, null, 6, 1, null, qw)), Ki(28, 16384, null, 0, ql, [En, Cn], { ngIf: [0, "ngIf"] }, null)], (function (t, e) { var n = e.component; t(e, 2, 0, "outline"), t(e, 18, 0, n.client.fullName), t(e, 21, 0, "Client name"), t(e, 25, 0), t(e, 28, 0, !1) }), (function (t, e) { t(e, 1, 1, ["standard" == Li(e, 2).appearance, "fill" == Li(e, 2).appearance, "outline" == Li(e, 2).appearance, "legacy" == Li(e, 2).appearance, Li(e, 2)._control.errorState, Li(e, 2)._canLabelFloat, Li(e, 2)._shouldLabelFloat(), Li(e, 2)._hasFloatingLabel(), Li(e, 2)._hideControlPlaceholder(), Li(e, 2)._control.disabled, Li(e, 2)._control.autofilled, Li(e, 2)._control.focused, "accent" == Li(e, 2).color, "warn" == Li(e, 2).color, Li(e, 2)._shouldForward("untouched"), Li(e, 2)._shouldForward("touched"), Li(e, 2)._shouldForward("pristine"), Li(e, 2)._shouldForward("dirty"), Li(e, 2)._shouldForward("valid"), Li(e, 2)._shouldForward("invalid"), Li(e, 2)._shouldForward("pending"), !Li(e, 2)._animationsEnabled]), t(e, 15, 1, [Li(e, 20).ngClassUntouched, Li(e, 20).ngClassTouched, Li(e, 20).ngClassPristine, Li(e, 20).ngClassDirty, Li(e, 20).ngClassValid, Li(e, 20).ngClassInvalid, Li(e, 20).ngClassPending, Li(e, 21)._isServer, Li(e, 21).id, Li(e, 21).placeholder, Li(e, 21).disabled, Li(e, 21).required, Li(e, 21).readonly && !Li(e, 21)._isNativeSelect || null, Li(e, 21)._ariaDescribedby || null, Li(e, 21).errorState, Li(e, 21).required.toString()]), t(e, 23, 0, Li(e, 25).inline, "primary" !== Li(e, 25).color && "accent" !== Li(e, 25).color && "warn" !== Li(e, 25).color) })) } function Zw(t) { return Zs(0, [(t()(), Rs(0, 0, null, null, 2, "mat-hint", [["class", "mat-hint"]], [[2, "mat-right", null], [1, "id", 0], [1, "align", 0]], null, null, null, null)), Ki(1, 16384, [[16, 4]], 0, rf, [], null, null), (t()(), Ws(-1, null, ["Hint"]))], null, (function (t, e) { t(e, 0, 0, "end" == Li(e, 1).align, Li(e, 1).id, null) })) } function Qw(t) { return Zs(0, [(t()(), Rs(0, 0, null, null, 2, "mat-hint", [["class", "mat-hint"]], [[2, "mat-right", null], [1, "id", 0], [1, "align", 0]], null, null, null, null)), Ki(1, 16384, [[25, 4]], 0, rf, [], null, null), (t()(), Ws(-1, null, ["Hint"]))], null, (function (t, e) { t(e, 0, 0, "end" == Li(e, 1).align, Li(e, 1).id, null) })) } function Kw(t) { return Zs(0, [(t()(), Rs(0, 0, null, null, 56, "div", [["class", "create-client"]], null, null, null, null, null)), (t()(), Rs(1, 0, null, null, 27, "mat-form-field", [["appearance", "outline"], ["class", "input login mat-form-field"]], [[2, "mat-form-field-appearance-standard", null], [2, "mat-form-field-appearance-fill", null], [2, "mat-form-field-appearance-outline", null], [2, "mat-form-field-appearance-legacy", null], [2, "mat-form-field-invalid", null], [2, "mat-form-field-can-float", null], [2, "mat-form-field-should-float", null], [2, "mat-form-field-has-label", null], [2, "mat-form-field-hide-placeholder", null], [2, "mat-form-field-disabled", null], [2, "mat-form-field-autofilled", null], [2, "mat-focused", null], [2, "mat-accent", null], [2, "mat-warn", null], [2, "ng-untouched", null], [2, "ng-touched", null], [2, "ng-pristine", null], [2, "ng-dirty", null], [2, "ng-valid", null], [2, "ng-invalid", null], [2, "ng-pending", null], [2, "_mat-animation-noopable", null]], null, null, Wg, Ng)), Ki(2, 7520256, null, 9, hf, [Qe, _n, [2, Qp], [2, yf], [2, uf], up, Zr, [2, Ag]], { appearance: [0, "appearance"] }, null), Ls(603979776, 10, { _controlNonStatic: 0 }), Ls(335544320, 11, { _controlStatic: 0 }), Ls(603979776, 12, { _labelChildNonStatic: 0 }), Ls(335544320, 13, { _labelChildStatic: 0 }), Ls(603979776, 14, { _placeholderChild: 0 }), Ls(603979776, 15, { _errorChildren: 1 }), Ls(603979776, 16, { _hintChildren: 1 }), Ls(603979776, 17, { _prefixChildren: 1 }), Ls(603979776, 18, { _suffixChildren: 1 }), (t()(), Rs(12, 0, null, 3, 2, "mat-label", [], null, null, null, null, null)), Ki(13, 16384, [[12, 4], [13, 4]], 0, sf, [], null, null), (t()(), Ws(-1, null, ["Perfume name"])), (t()(), Rs(15, 0, null, 1, 7, "input", [["class", "mat-input-element mat-form-field-autofill-control"], ["matInput", ""], ["placeholder", "Perfume name"]], [[2, "ng-untouched", null], [2, "ng-touched", null], [2, "ng-pristine", null], [2, "ng-dirty", null], [2, "ng-valid", null], [2, "ng-invalid", null], [2, "ng-pending", null], [2, "mat-input-server", null], [1, "id", 0], [1, "placeholder", 0], [8, "disabled", 0], [8, "required", 0], [1, "readonly", 0], [1, "aria-describedby", 0], [1, "aria-invalid", 0], [1, "aria-required", 0]], [[null, "ngModelChange"], [null, "input"], [null, "blur"], [null, "compositionstart"], [null, "compositionend"], [null, "focus"]], (function (t, e, n) { var i = !0, r = t.component; return "input" === e && (i = !1 !== Li(t, 16)._handleInput(n.target.value) && i), "blur" === e && (i = !1 !== Li(t, 16).onTouched() && i), "compositionstart" === e && (i = !1 !== Li(t, 16)._compositionStart() && i), "compositionend" === e && (i = !1 !== Li(t, 16)._compositionEnd(n.target.value) && i), "blur" === e && (i = !1 !== Li(t, 21)._focusChanged(!1) && i), "focus" === e && (i = !1 !== Li(t, 21)._focusChanged(!0) && i), "input" === e && (i = !1 !== Li(t, 21)._onInput() && i), "ngModelChange" === e && (i = !1 !== (r.transition.perfume = n) && i), i }), null, null)), Ki(16, 16384, null, 0, Yg, [tn, Qe, [2, Kg]], null, null), Yi(1024, null, Zg, (function (t) { return [t] }), [Yg]), Ki(18, 671744, null, 0, q_, [[8, null], [8, null], [8, null], [6, Zg]], { model: [0, "model"] }, { update: "ngModelChange" }), Yi(2048, null, e_, null, [q_]), Ki(20, 16384, null, 0, n_, [[4, e_]], null, null), Ki(21, 999424, null, 0, dy, [Qe, up, [6, e_], [2, j_], [2, Q_], jp, [8, null], oy, Zr], { placeholder: [0, "placeholder"] }, null), Yi(2048, [[10, 4], [11, 4]], tf, null, [dy]), (t()(), Rs(23, 0, null, 4, 3, "mat-icon", [["class", "mat-icon notranslate"], ["matSuffix", ""], ["role", "img"]], [[2, "mat-icon-inline", null], [2, "mat-icon-no-color", null]], null, null, uv, cv)), Ki(24, 16384, [[18, 4]], 0, of, [], null, null), Ki(25, 9158656, null, 0, lv, [Qe, Xy, [8, null], [2, iv], [2, Te]], null, null), (t()(), Ws(-1, 0, ["sentiment_very_satisfied"])), (t()(), As(16777216, null, 6, 1, null, Zw)), Ki(28, 16384, null, 0, ql, [En, Cn], { ngIf: [0, "ngIf"] }, null), (t()(), Rs(29, 0, null, null, 27, "mat-form-field", [["appearance", "outline"], ["class", "input login mat-form-field"]], [[2, "mat-form-field-appearance-standard", null], [2, "mat-form-field-appearance-fill", null], [2, "mat-form-field-appearance-outline", null], [2, "mat-form-field-appearance-legacy", null], [2, "mat-form-field-invalid", null], [2, "mat-form-field-can-float", null], [2, "mat-form-field-should-float", null], [2, "mat-form-field-has-label", null], [2, "mat-form-field-hide-placeholder", null], [2, "mat-form-field-disabled", null], [2, "mat-form-field-autofilled", null], [2, "mat-focused", null], [2, "mat-accent", null], [2, "mat-warn", null], [2, "ng-untouched", null], [2, "ng-touched", null], [2, "ng-pristine", null], [2, "ng-dirty", null], [2, "ng-valid", null], [2, "ng-invalid", null], [2, "ng-pending", null], [2, "_mat-animation-noopable", null]], null, null, Wg, Ng)), Ki(30, 7520256, null, 9, hf, [Qe, _n, [2, Qp], [2, yf], [2, uf], up, Zr, [2, Ag]], { appearance: [0, "appearance"] }, null), Ls(603979776, 19, { _controlNonStatic: 0 }), Ls(335544320, 20, { _controlStatic: 0 }), Ls(603979776, 21, { _labelChildNonStatic: 0 }), Ls(335544320, 22, { _labelChildStatic: 0 }), Ls(603979776, 23, { _placeholderChild: 0 }), Ls(603979776, 24, { _errorChildren: 1 }), Ls(603979776, 25, { _hintChildren: 1 }), Ls(603979776, 26, { _prefixChildren: 1 }), Ls(603979776, 27, { _suffixChildren: 1 }), (t()(), Rs(40, 0, null, 3, 2, "mat-label", [], null, null, null, null, null)), Ki(41, 16384, [[21, 4], [22, 4]], 0, sf, [], null, null), (t()(), Ws(-1, null, ["Price"])), (t()(), Rs(43, 0, null, 1, 7, "input", [["class", "mat-input-element mat-form-field-autofill-control"], ["matInput", ""], ["placeholder", "Perfume price"]], [[2, "ng-untouched", null], [2, "ng-touched", null], [2, "ng-pristine", null], [2, "ng-dirty", null], [2, "ng-valid", null], [2, "ng-invalid", null], [2, "ng-pending", null], [2, "mat-input-server", null], [1, "id", 0], [1, "placeholder", 0], [8, "disabled", 0], [8, "required", 0], [1, "readonly", 0], [1, "aria-describedby", 0], [1, "aria-invalid", 0], [1, "aria-required", 0]], [[null, "ngModelChange"], [null, "input"], [null, "blur"], [null, "compositionstart"], [null, "compositionend"], [null, "focus"]], (function (t, e, n) { var i = !0, r = t.component; return "input" === e && (i = !1 !== Li(t, 44)._handleInput(n.target.value) && i), "blur" === e && (i = !1 !== Li(t, 44).onTouched() && i), "compositionstart" === e && (i = !1 !== Li(t, 44)._compositionStart() && i), "compositionend" === e && (i = !1 !== Li(t, 44)._compositionEnd(n.target.value) && i), "blur" === e && (i = !1 !== Li(t, 49)._focusChanged(!1) && i), "focus" === e && (i = !1 !== Li(t, 49)._focusChanged(!0) && i), "input" === e && (i = !1 !== Li(t, 49)._onInput() && i), "ngModelChange" === e && (i = !1 !== (r.transition.value = n) && i), i }), null, null)), Ki(44, 16384, null, 0, Yg, [tn, Qe, [2, Kg]], null, null), Yi(1024, null, Zg, (function (t) { return [t] }), [Yg]), Ki(46, 671744, null, 0, q_, [[8, null], [8, null], [8, null], [6, Zg]], { model: [0, "model"] }, { update: "ngModelChange" }), Yi(2048, null, e_, null, [q_]), Ki(48, 16384, null, 0, n_, [[4, e_]], null, null), Ki(49, 999424, null, 0, dy, [Qe, up, [6, e_], [2, j_], [2, Q_], jp, [8, null], oy, Zr], { placeholder: [0, "placeholder"] }, null), Yi(2048, [[19, 4], [20, 4]], tf, null, [dy]), (t()(), Rs(51, 0, null, 4, 3, "mat-icon", [["class", "mat-icon notranslate"], ["matSuffix", ""], ["role", "img"]], [[2, "mat-icon-inline", null], [2, "mat-icon-no-color", null]], null, null, uv, cv)), Ki(52, 16384, [[27, 4]], 0, of, [], null, null), Ki(53, 9158656, null, 0, lv, [Qe, Xy, [8, null], [2, iv], [2, Te]], null, null), (t()(), Ws(-1, 0, ["sentiment_very_satisfied"])), (t()(), As(16777216, null, 6, 1, null, Qw)), Ki(56, 16384, null, 0, ql, [En, Cn], { ngIf: [0, "ngIf"] }, null)], (function (t, e) { var n = e.component; t(e, 2, 0, "outline"), t(e, 18, 0, n.transition.perfume), t(e, 21, 0, "Perfume name"), t(e, 25, 0), t(e, 28, 0, !1), t(e, 30, 0, "outline"), t(e, 46, 0, n.transition.value), t(e, 49, 0, "Perfume price"), t(e, 53, 0), t(e, 56, 0, !1) }), (function (t, e) { t(e, 1, 1, ["standard" == Li(e, 2).appearance, "fill" == Li(e, 2).appearance, "outline" == Li(e, 2).appearance, "legacy" == Li(e, 2).appearance, Li(e, 2)._control.errorState, Li(e, 2)._canLabelFloat, Li(e, 2)._shouldLabelFloat(), Li(e, 2)._hasFloatingLabel(), Li(e, 2)._hideControlPlaceholder(), Li(e, 2)._control.disabled, Li(e, 2)._control.autofilled, Li(e, 2)._control.focused, "accent" == Li(e, 2).color, "warn" == Li(e, 2).color, Li(e, 2)._shouldForward("untouched"), Li(e, 2)._shouldForward("touched"), Li(e, 2)._shouldForward("pristine"), Li(e, 2)._shouldForward("dirty"), Li(e, 2)._shouldForward("valid"), Li(e, 2)._shouldForward("invalid"), Li(e, 2)._shouldForward("pending"), !Li(e, 2)._animationsEnabled]), t(e, 15, 1, [Li(e, 20).ngClassUntouched, Li(e, 20).ngClassTouched, Li(e, 20).ngClassPristine, Li(e, 20).ngClassDirty, Li(e, 20).ngClassValid, Li(e, 20).ngClassInvalid, Li(e, 20).ngClassPending, Li(e, 21)._isServer, Li(e, 21).id, Li(e, 21).placeholder, Li(e, 21).disabled, Li(e, 21).required, Li(e, 21).readonly && !Li(e, 21)._isNativeSelect || null, Li(e, 21)._ariaDescribedby || null, Li(e, 21).errorState, Li(e, 21).required.toString()]), t(e, 23, 0, Li(e, 25).inline, "primary" !== Li(e, 25).color && "accent" !== Li(e, 25).color && "warn" !== Li(e, 25).color), t(e, 29, 1, ["standard" == Li(e, 30).appearance, "fill" == Li(e, 30).appearance, "outline" == Li(e, 30).appearance, "legacy" == Li(e, 30).appearance, Li(e, 30)._control.errorState, Li(e, 30)._canLabelFloat, Li(e, 30)._shouldLabelFloat(), Li(e, 30)._hasFloatingLabel(), Li(e, 30)._hideControlPlaceholder(), Li(e, 30)._control.disabled, Li(e, 30)._control.autofilled, Li(e, 30)._control.focused, "accent" == Li(e, 30).color, "warn" == Li(e, 30).color, Li(e, 30)._shouldForward("untouched"), Li(e, 30)._shouldForward("touched"), Li(e, 30)._shouldForward("pristine"), Li(e, 30)._shouldForward("dirty"), Li(e, 30)._shouldForward("valid"), Li(e, 30)._shouldForward("invalid"), Li(e, 30)._shouldForward("pending"), !Li(e, 30)._animationsEnabled]), t(e, 43, 1, [Li(e, 48).ngClassUntouched, Li(e, 48).ngClassTouched, Li(e, 48).ngClassPristine, Li(e, 48).ngClassDirty, Li(e, 48).ngClassValid, Li(e, 48).ngClassInvalid, Li(e, 48).ngClassPending, Li(e, 49)._isServer, Li(e, 49).id, Li(e, 49).placeholder, Li(e, 49).disabled, Li(e, 49).required, Li(e, 49).readonly && !Li(e, 49)._isNativeSelect || null, Li(e, 49)._ariaDescribedby || null, Li(e, 49).errorState, Li(e, 49).required.toString()]), t(e, 51, 0, Li(e, 53).inline, "primary" !== Li(e, 53).color && "accent" !== Li(e, 53).color && "warn" !== Li(e, 53).color) })) } function Yw(t) { return Zs(0, [(t()(), Rs(0, 0, null, null, 12, "div", [["class", "content-container mat-dialog-content"], ["mat-dialog-content", ""]], null, null, null, null, null)), Ki(1, 16384, null, 0, Lb, [], null, null), (t()(), As(16777216, null, null, 1, null, Gw)), Ki(3, 16384, null, 0, ql, [En, Cn], { ngIf: [0, "ngIf"] }, null), (t()(), As(16777216, null, null, 1, null, Kw)), Ki(5, 16384, null, 0, ql, [En, Cn], { ngIf: [0, "ngIf"] }, null), (t()(), Rs(6, 0, null, null, 6, "div", [["class", "actions"]], null, null, null, null, null)), (t()(), Rs(7, 0, null, null, 2, "button", [["class", "close"], ["mat-button", ""]], [[1, "disabled", 0], [2, "_mat-animation-noopable", null]], [[null, "click"]], (function (t, e, n) { var i = !0; return "click" === e && (i = !1 !== t.component.close() && i), i }), _v, gv)), Ki(8, 180224, null, 0, fv, [Qe, Ap, [2, Ag]], null, null), (t()(), Ws(-1, 0, ["Cancel"])), (t()(), Rs(10, 0, null, null, 2, "button", [["class", "next"], ["color", "primary"], ["mat-raised-button", ""]], [[1, "disabled", 0], [2, "_mat-animation-noopable", null]], [[null, "click"]], (function (t, e, n) { var i = !0; return "click" === e && (i = !1 !== t.component.close() && i), i }), _v, gv)), Ki(11, 180224, null, 0, fv, [Qe, Ap, [2, Ag]], { color: [0, "color"] }, null), (t()(), Ws(-1, 0, ["Save"]))], (function (t, e) { var n = e.component; t(e, 3, 0, "client" === n.data.type), t(e, 5, 0, "transition" === n.data.type), t(e, 11, 0, "primary") }), (function (t, e) { t(e, 7, 0, Li(e, 8).disabled || null, "NoopAnimations" === Li(e, 8)._animationMode), t(e, 10, 0, Li(e, 11).disabled || null, "NoopAnimations" === Li(e, 11)._animationMode) })) } function Xw(t) { return Zs(0, [(t()(), Rs(0, 0, null, null, 1, "create-overlay-view", [], null, null, null, Yw, Ww)), Ki(1, 114688, null, 0, gw, [Pb, Ob], null, null)], (function (t, e) { t(e, 1, 0) }), null) } var Jw = Ti("create-overlay-view", gw, Xw, {}, {}, []), tC = jn({ encapsulation: 0, styles: [[""]], data: {} }); function eC(t) { return Zs(0, [(t()(), Rs(0, 16777216, null, null, 1, "router-outlet", [], null, null, null, null, null)), Ki(1, 212992, null, 0, xd, [Ed, En, Be, [8, null], _n], null, null)], (function (t, e) { t(e, 1, 0) }), null) } function nC(t) { return Zs(0, [(t()(), Rs(0, 0, null, null, 1, "app-root", [], null, null, null, eC, tC)), Ki(1, 49152, null, 0, il, [], null, null)], null, null) } var iC = Ti("app-root", il, nC, {}, {}, []); class rC { constructor(t, e) { this.authService = t, this.router = e, this.isRefreshing = !1, this.refreshTokenSubject = new la(null) } intercept(t, e) { return this.authService.getJwtToken() && (t = this.addToken(t, this.authService.getJwtToken())), e.handle(t).pipe(Ra(t => t instanceof Py && 401 === t.status ? (this.authService.logout(), qy(t)) : qy(t))) } addToken(t, e) { let n; return n = { setHeaders: { Authorization: "Bearer " + e } }, t.clone(n) } } class sC { } let oC = (() => class { })(); var lC = tl(nl, [il], (function (t) { return function (t) { const e = {}, n = []; let i = !1; for (let r = 0; r < t.length; r++) { const s = t[r]; s.token === Lt && !0 === s.value && (i = !0), 1073741824 & s.flags && n.push(s.token), s.index = r, e[zn(s.token)] = s } return { factory: null, providersByKey: e, providers: t, modules: n, isRoot: i } }([_i(512, Be, $e, [[8, [Kd, qb, Ew, aw, Ow, Nw, jw, $w, Jw, iC]], [3, Be], qe]), _i(5120, Ar, Ps, [[3, Ar]]), _i(4608, jl, Ul, [Ar, [2, zl]]), _i(5120, dr, Os, [Zr]), _i(5120, Er, xr, []), _i(5120, mn, Ts, []), _i(5120, gn, ks, []), _i(4608, Gc, Zc, [ta]), _i(6144, be, null, [Gc]), _i(4608, jc, Hc, []), _i(5120, mc, (function (t, e, n, i, r, s, o, l) { return [new Vc(t, e, n), new qc(i), new Bc(r, s, o, l)] }), [ta, Zr, Pr, ta, ta, jc, Ir, [2, Uc]]), _i(4608, gc, gc, [mc, Zr]), _i(135680, vc, vc, [ta]), _i(4608, Ec, Ec, [gc, vc, Er]), _i(5120, jf, Pg, []), _i(5120, Om, Og, []), _i(4608, ng, kg, [ta, jf, Om]), _i(5120, Xe, Ig, [Ec, ng, Zr]), _i(6144, yc, null, [vc]), _i(4608, es, es, [Zr]), _i(5120, uh, Hd, [bd]), _i(4608, Od, Od, []), _i(6144, kd, null, [Od]), _i(135680, Id, Id, [bd, fs, zr, zt, kd]), _i(4608, Pd, Pd, []), _i(5120, Ad, Ld, [bd, ea, Rd]), _i(5120, qd, Wd, [Bd]), _i(5120, Or, (function (t) { return [t] }), [qd]), _i(4608, jy, Uy, [ta, Pr, Vy]), _i(4608, Hy, Hy, [jy, zy]), _i(5120, Ry, (function (t, e, n) { return [t, new rC(e, n)] }), [Hy, zv, bd]), _i(4608, Fy, Fy, []), _i(6144, Dy, null, [Fy]), _i(4608, Ly, Ly, [Dy]), _i(6144, my, null, [Ly]), _i(4608, fy, By, [my, zt]), _i(4608, Iy, Iy, [fy]), _i(4608, Yd, bg, [Xe, ta]), _i(4608, d_, d_, []), _i(4608, Y_, Y_, []), _i(4608, pf, pf, []), _i(4608, jp, jp, []), _i(4608, bb, bb, [sb, db, Be, yb, hb, zt, Zr, ta, yf, [2, al]]), _i(5120, wb, Cb, [bb]), _i(5120, Ab, Rb, [bb]), _i(135680, Nb, Nb, [bb, zt, [2, al], [2, Ib], Ab, [3, Nb], db]), _i(1073742336, Jl, Jl, []), _i(1024, Te, nu, []), _i(1024, ls, (function () { return [Dd()] }), []), _i(512, Bd, Bd, [zt]), _i(1024, Cr, (function (t, e) { return [(n = t, dc("probe", fc), dc("coreTokens", Object.assign({}, pc, (n || []).reduce((t, e) => (t[e.name] = e.token, t), {}))), () => fc), $d(e)]; var n }), [[2, ls], Bd]), _i(512, Sr, Sr, [[2, Cr]]), _i(131584, ds, ds, [Zr, Ir, zt, Te, Be, Sr]), _i(1073742336, Is, Is, [ds]), _i(1073742336, iu, iu, [[3, iu]]), _i(1024, Nd, zd, [[3, bd]]), _i(512, Hu, Bu, []), _i(512, Ed, Ed, []), _i(256, Rd, {}, []), _i(1024, ol, Vd, [rl, [2, ll], Rd]), _i(512, al, al, [ol, rl]), _i(512, zr, zr, []), _i(512, fs, _s, [zr, [2, ms]]), _i(1024, pd, (function () { return [[{ path: "", component: bv }, { path: "home", component: yw }]] }), []), _i(1024, bd, Ud, [ds, Hu, Ed, al, zt, fs, zr, pd, Rd, [2, md], [2, hd]]), _i(1073742336, Fd, Fd, [[2, Nd], [2, bd]]), _i(1073742336, sC, sC, []), _i(1073742336, $y, $y, []), _i(1073742336, Wy, Wy, []), _i(1073742336, Rg, Rg, []), _i(1073742336, K_, K_, []), _i(1073742336, X_, X_, []), _i(1073742336, J_, J_, []), _i(1073742336, Kb, Kb, []), _i(1073742336, gf, gf, []), _i(1073742336, df, df, []), _i(1073742336, hp, hp, []), _i(1073742336, ly, ly, []), _i(1073742336, py, py, []), _i(1073742336, vf, vf, []), _i(1073742336, Dp, Dp, [[2, Np], [2, Uc]]), _i(1073742336, av, av, []), _i(1073742336, Zp, Zp, []), _i(1073742336, mv, mv, []), _i(1073742336, dw, dw, []), _i(1073742336, oC, oC, []), _i(1073742336, Gv, Gv, []), _i(1073742336, Kv, Kv, []), _i(1073742336, Sb, Sb, []), _i(1073742336, jb, jb, []), _i(1073742336, nl, nl, []), _i(256, Lt, !0, []), _i(256, Vy, "XSRF-TOKEN", []), _i(256, zy, "X-XSRF-TOKEN", []), _i(256, Ag, "BrowserAnimations", [])]) })); eu().bootstrapModuleFactory(lC).catch(t => console.error(t)) }, zn8P: function (t, e) { function n(t) { return Promise.resolve().then((function () { var e = new Error("Cannot find module '" + t + "'"); throw e.code = "MODULE_NOT_FOUND", e })) } n.keys = function () { return [] }, n.resolve = n, t.exports = n, n.id = "zn8P" } }, [[0, 0]]]);
